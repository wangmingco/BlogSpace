{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"7234af2a10a9fa7e9f1124bf3ad9ac29ec4cbc7a","modified":1572848374914},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1572848091957},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1572848091957},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1572848091957},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1572848091957},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1572848091957},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1572848091964},{"_id":"source/_posts/.DS_Store","hash":"0f37e84be623db6299b1a92192021885ebd9722d","modified":1572836972446},{"_id":"source/_posts/agent-mock.md","hash":"e4445ff2d57b5605d8ddfca0f5cfea0d8ae7366c","modified":1572846542502},{"_id":"source/_posts/distributed-id.md","hash":"c57e66acfc389668d89938948fa016f6b5d00438","modified":1572846542503},{"_id":"source/_posts/java-books.md","hash":"459e7ca982ebb23fffeff925ad1b5b0e72c75181","modified":1572846542503},{"_id":"source/_posts/pegjs-document.md","hash":"7e3add97615eeabe149fd133eaec5eee6faf0280","modified":1572846542511},{"_id":"source/_posts/work-knife.md","hash":"54f514f7a345891d74a089921cf205e70f9dcef3","modified":1572846542512},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1572848091958},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1572848091957},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1572848091958},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1572848091958},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1572848091958},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1572848091958},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1572848091958},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1572848091958},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1572848091959},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1572848091959},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1572848091959},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1572848091959},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1572848091963},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1572848091963},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1572848091963},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1572848091964},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1572848091964},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1572848091964},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1572848091964},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1572848091965},{"_id":"source/_posts/javassist/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1572836944519},{"_id":"source/_posts/javassist/Javasist 1 Reading and writing bytecode.md","hash":"57d729462ec9c3b7b02a38110d28ec6921dc35be","modified":1572846542504},{"_id":"source/_posts/javassist/Javasist 2 ClassPool.md","hash":"88a75079b35bf0251f94eff1c524f6d5063aa61f","modified":1572846542505},{"_id":"source/_posts/javassist/Javasist 3 Class loader.md","hash":"05ac117e7a180da2f3735929e7635238ed191a6e","modified":1572846542506},{"_id":"source/_posts/javassist/Javasist 4 Introspection and customization.md","hash":"4e5536901e3bfa031006a0c0058e606a20053ad9","modified":1572846542507},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1572848091959},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1572848091959},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1572848091960},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1572848091960},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1572848091960},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1572848091960},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1572848091960},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1572848091960},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1572848091961},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1572848091961},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1572848091962},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1572848091962},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1572848091963},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1572848091963},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1572848091963},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1572848091963},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1572848091965},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1572848091969},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1572848091975},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1572848091975},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1572848091976},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1572848091976},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1572848091976},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1572848091976},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1572848091977},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1572848091979},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1572848091979},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1572848091980},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1572848091980},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1572848091961},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1572848091961},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1572848091962},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1572848091962},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1572848091962},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1572848091962},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1572848091965},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1572848091966},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1572848091966},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1572848091966},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1572848091966},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1572848091966},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1572848091967},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1572848091967},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1572848091967},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1572848091968},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1572848091968},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1572848091968},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1572848091970},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1572848091973},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1572848091977},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1572848091977},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1572848091977},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1572848091978},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1572848091978},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1572848091978},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1572848091970},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1572848091973},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1572848091972},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1572848091975},{"_id":"public/2018/11/14/java-books/index.html","hash":"75d3bd2b08a6dc3fee623229256a46b9ec8f78f0","modified":1572848596203},{"_id":"public/2018/10/30/work-knife/index.html","hash":"8bce5f800bf1be88c497f2acb87af43810c20e8d","modified":1572848596203},{"_id":"public/archives/index.html","hash":"a07b079f100ab61bf84f2bcdfba624edcf07e0a5","modified":1572848596203},{"_id":"public/archives/2018/index.html","hash":"6d43a393e543a2e1d383dd47486ead9011b6fd06","modified":1572848596203},{"_id":"public/archives/2018/10/index.html","hash":"d2e91a23ef9753071411cd26e7b0b4cfb159ffe8","modified":1572848596203},{"_id":"public/archives/2018/11/index.html","hash":"c58db595d111fbf49785b1f0a7dfe616c5969eb7","modified":1572848596203},{"_id":"public/archives/2018/12/index.html","hash":"c79a8ef2cca2fbf18ca187eecc156960d38fac8a","modified":1572848596203},{"_id":"public/archives/2019/index.html","hash":"bc2f817453350557d96fdc9a42c4bc7bdd1ecc9b","modified":1572848596203},{"_id":"public/archives/2019/05/index.html","hash":"202656f0d11ada27610878aed8a081e1b56e98a6","modified":1572848596203},{"_id":"public/2019/05/04/javassist/Javasist 4 Introspection and customization/index.html","hash":"59a84f019fdfb0a40350c84196e417c97f221153","modified":1572848596203},{"_id":"public/2019/05/03/javassist/Javasist 3 Class loader/index.html","hash":"c53f0e824f50da5db47b18c7ca91ed45858bda17","modified":1572848596203},{"_id":"public/2019/05/02/javassist/Javasist 2 ClassPool/index.html","hash":"a37901301dcc217d715486ee6b41e8abf8e731bb","modified":1572848596203},{"_id":"public/2019/05/01/javassist/Javasist 1 Reading and writing bytecode/index.html","hash":"7679a21a73b349ac047f30de5b4eb39e6824b978","modified":1572848596203},{"_id":"public/2018/12/15/pegjs-document/index.html","hash":"9ddd41ff853ebd4d2bd16118a3945ace0496cc85","modified":1572848596203},{"_id":"public/2018/11/18/distributed-id/index.html","hash":"854da1c55139cc0ace696b4eee58c47172b0c412","modified":1572848596203},{"_id":"public/2018/11/05/agent-mock/index.html","hash":"0e08b9545b8141ed26787a2e504472ca71329c19","modified":1572848596203},{"_id":"public/index.html","hash":"4463eac6484bcbef288a4bbf52ec14b569bd0946","modified":1572848596203},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1572848596203},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1572848596203},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1572848596203},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1572848596203},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1572848596203},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1572848596203},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1572848596203},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1572848596203},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1572848596203},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1572848596203},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1572848596203},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1572848596203},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1572848596203},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1572848596203},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1572848596203},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1572848596203},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1572848596203},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1572848596203},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1572848596203},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1572848596203},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1572848596203},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1572848596203},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1572848596203}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"通过Java Agent的redefineClasses实现Mock功能","date":"2018-11-05T12:15:00.000Z","_content":"\n# A)\n最近组内项目有个模块进行了较大规模的重构, 需要跑一下压力测试, 看一下性能如何. 但是介于产品的模式, 在正常场景下需要向通道发送消息, 然而在压测中, 我们希望这段行为能被mock掉. \n当时想到的方案可以采用Spring AOP, JMockit或者自己通过Javasisit/ASM这种字节码框架来实现功能.\n\n由于项目中我自己很少使用Spring AOP来做一些功能, 便没让它当首选方案, 研究了一下JMockit实现, 发现是使用动态Agent实现的.ok, 那么便初步定了一下方案Agent+Javasisit来实现(ASM手写字节码实在太痛苦).\n\n# B)\n\n> 这一段貌似是废话, 你们也看不见代码发生的真实地转变, 我只是记录一下心路历程.\n\n利用了2个小时, 采用Agent+Javasisit实现了一个小的模块, 基本功能也都实现了, 但是使用起来实在是太麻烦了, 代码耦合性太高. 于是又换了个思路, 去掉了Javasisit框架, 也完美地实现了功能.\n\n\n# C)\n整个mock框架分为俩部分.\n* agent-core, mock的核心代码\n* agent-client, 在这个工程中, 我们只需要在pom中引入需要替换的工程的依赖, 然后再agent-client中把要替换的类重写一遍就好了\n\n<!--more-->\n\n## 核心部分\n\n```\n├── pom.xml\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── co\n    │   │       └── wangming\n    │   │           └── agent\n    │   │               ├── Agent.java\n    │   │               └── ClassesLoadUtil.java\n    │   └── resources\n    │       └── META-INF\n    │           └── MANIFEST.MF\n    └── test\n        └── java\n            └── Test.java\n```\n核心就是俩个Java文件和一个MF文件\n```java\npublic class Agent {\n\n\tstatic ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(1);\n\n\tstatic List<String> hashCached = new ArrayList<>();\n\n\tpublic static void premain(String agentArgs, Instrumentation instrumentation) {\n\n\t\tSystem.out.println(\"Agnet 进入!!! \" + agentArgs);\n\t\tscheduledExecutorService.scheduleAtFixedRate(() -> tryRedefine(instrumentation, agentArgs), 0, 10, TimeUnit.SECONDS);\n\t}\n\n\tprivate static void tryRedefine(Instrumentation instrumentation, String agentArgs) {\n\n\t\tClass[] allLoadedClasses = instrumentation.getAllLoadedClasses();\n//\t\tSystem.out.println(\"allLoadedClasses数量:\" + allLoadedClasses.length);\n\n\t\tMap<String, Class> finupAllLoadedClasses = new HashMap<>();\n\t\ttry {\n\t\t\tfor (Class loadedClass : allLoadedClasses) {\n\n\t\t\t\tif (loadedClass == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (loadedClass.getCanonicalName() == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!loadedClass.getCanonicalName().startsWith(\"com.finup\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (hashCached.contains(loadedClass.getCanonicalName())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfinupAllLoadedClasses.put(loadedClass.getCanonicalName(), loadedClass);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tMap<String, byte[]> rewriteClasses = ClassesLoadUtil.getRewriteClasses(agentArgs);\n\t\tfor (String className : hashCached) {\n\t\t\trewriteClasses.remove(className);\n\t\t}\n\n\t\tif (finupAllLoadedClasses.size() == 0 || rewriteClasses.size() == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tSystem.out.println(\"finupAllLoadedClasses数量:\" + finupAllLoadedClasses.size());\n\n\t\tfor (String className : rewriteClasses.keySet()) {\n\t\t\tbyte[] classBytes = rewriteClasses.get(className);\n\n\t\t\tif (classBytes == null || classBytes.length == 0) {\n\t\t\t\tSystem.out.println(\"从 rewriteClasses 找不到class: \" + className);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClass redefineClass = finupAllLoadedClasses.get(className);\n\t\t\tif (redefineClass == null) {\n\t\t\t\tSystem.out.println(\"从 finupAllLoadedClasses 找不到class: \" + className);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tSystem.out.println(\"开始redefineClasses: \" + className);\n\n\t\t\tClassDefinition classDefinition = new ClassDefinition(redefineClass, classBytes);\n\n\t\t\ttry {\n\t\t\t\tinstrumentation.redefineClasses(classDefinition);\n\t\t\t\thashCached.add(className);\n\n\t\t\t\tSystem.out.println(\"结束redefineClasses: \" + className);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (UnmodifiableClassException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n}\n```\n\n```java\npublic class ClassesLoadUtil {\n\n\tprivate static final Map<String, byte[]> path2Classes = new ConcurrentHashMap<>();\n\tprivate static final Map<String, byte[]> className2Classes = new ConcurrentHashMap<>();\n\n\tprivate static boolean havaLoaded = false;\n\n\tprivate static void loadFromZipFile(String jarPath) {\n\t\ttry {\n\t\t\tZipFile zipFile = new ZipFile(jarPath);\n\t\t\tEnumeration<? extends ZipEntry> entrys = zipFile.entries();\n\t\t\twhile (entrys.hasMoreElements()) {\n\t\t\t\tZipEntry zipEntry = entrys.nextElement();\n\t\t\t\tentryRead(jarPath, zipEntry);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tprivate static boolean entryRead(String jarPath, ZipEntry ze) throws IOException {\n\t\tif (ze.getSize() > 0) {\n\t\t\tString fileName = ze.getName();\n\t\t\tif (!fileName.endsWith(\".class\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!fileName.contains(\"finup\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\ttry (ZipFile zf = new ZipFile(jarPath); InputStream input = zf.getInputStream(ze);\n\t\t\t     ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {\n\t\t\t\tif (input == null) {\n//\t\t\t\t\t\t\t\tlogger.error(\"Code Reload cant find file : \" + fileName);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tint b = 0;\n\t\t\t\twhile ((b = input.read()) != -1) {\n\t\t\t\t\tbyteArrayOutputStream.write(b);\n\t\t\t\t}\n\t\t\t\tbyte[] bytes = byteArrayOutputStream.toByteArray();\n\n\t\t\t\tpath2Classes.put(fileName, bytes);\n\n\t\t\t\tString name1 = fileName.replaceAll(\"\\\\.class\", \"\");\n\t\t\t\tString name2 = name1.replaceAll(\"/\", \".\");\n\n\t\t\t\tclassName2Classes.put(name2, bytes);\n\n\t\t\t\tSystem.out.println(\"加载文件: fileName : \" + fileName + \".  className:\" + name2);\n\t\t\t}\n\t\t} else {\n//\t\t\tSystem.out.println(ze.getName() + \" size is 0\");\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic static Map<String, byte[]> getRewriteClasses(String agentArgs) {\n\t\tsynchronized (className2Classes) {\n\t\t\tif (!havaLoaded) {\n\t\t\t\tloadFromZipFile(agentArgs);\n\t\t\t\thavaLoaded = true;\n\t\t\t}\n\t\t}\n\n\t\treturn className2Classes;\n\t}\n}\n```\nMF\n```\nManifest-Version: 1.0\nPremain-Class: co.wangming.agent.Agent\nCan-Redefine-Classes: true\nCan-Retransform-Classes: true\n```\n\n基本上这三个文件就可以完成功能了.\n\n## agent-client\n\n```\n├── pom.xml\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── co\n    │   │       └── wangming\n    │   │           └── agent_client\n    │   │               └── service\n    │   │                   └── TestService\n    │   └── resources\n    │       └── META-INF\n    │           └── MANIFEST.MF\n    └── test\n        └── java\n```\n\n```\nManifest-Version: 1.0\nPremain-Class: co.wangming.agent.Agent\nCan-Redefine-Classes: true\nCan-Retransform-Classes: true\n```\n我们只需要把需要覆盖的`TestService`类在这里重写一下就好了, 但是注意, 不能删除/增加 方法/字段, 不能修改继承结构. 总而言之就是不能修改类的结构, 但是只是修改方法实现应该也能满足大多数需求了.\n\n> 以后有时间再想想怎么用Spring AOP来实现","source":"_posts/agent-mock.md","raw":"---\ntitle: 通过Java Agent的redefineClasses实现Mock功能\ndate: 2018-11-05 20:15:00\n---\n\n# A)\n最近组内项目有个模块进行了较大规模的重构, 需要跑一下压力测试, 看一下性能如何. 但是介于产品的模式, 在正常场景下需要向通道发送消息, 然而在压测中, 我们希望这段行为能被mock掉. \n当时想到的方案可以采用Spring AOP, JMockit或者自己通过Javasisit/ASM这种字节码框架来实现功能.\n\n由于项目中我自己很少使用Spring AOP来做一些功能, 便没让它当首选方案, 研究了一下JMockit实现, 发现是使用动态Agent实现的.ok, 那么便初步定了一下方案Agent+Javasisit来实现(ASM手写字节码实在太痛苦).\n\n# B)\n\n> 这一段貌似是废话, 你们也看不见代码发生的真实地转变, 我只是记录一下心路历程.\n\n利用了2个小时, 采用Agent+Javasisit实现了一个小的模块, 基本功能也都实现了, 但是使用起来实在是太麻烦了, 代码耦合性太高. 于是又换了个思路, 去掉了Javasisit框架, 也完美地实现了功能.\n\n\n# C)\n整个mock框架分为俩部分.\n* agent-core, mock的核心代码\n* agent-client, 在这个工程中, 我们只需要在pom中引入需要替换的工程的依赖, 然后再agent-client中把要替换的类重写一遍就好了\n\n<!--more-->\n\n## 核心部分\n\n```\n├── pom.xml\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── co\n    │   │       └── wangming\n    │   │           └── agent\n    │   │               ├── Agent.java\n    │   │               └── ClassesLoadUtil.java\n    │   └── resources\n    │       └── META-INF\n    │           └── MANIFEST.MF\n    └── test\n        └── java\n            └── Test.java\n```\n核心就是俩个Java文件和一个MF文件\n```java\npublic class Agent {\n\n\tstatic ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(1);\n\n\tstatic List<String> hashCached = new ArrayList<>();\n\n\tpublic static void premain(String agentArgs, Instrumentation instrumentation) {\n\n\t\tSystem.out.println(\"Agnet 进入!!! \" + agentArgs);\n\t\tscheduledExecutorService.scheduleAtFixedRate(() -> tryRedefine(instrumentation, agentArgs), 0, 10, TimeUnit.SECONDS);\n\t}\n\n\tprivate static void tryRedefine(Instrumentation instrumentation, String agentArgs) {\n\n\t\tClass[] allLoadedClasses = instrumentation.getAllLoadedClasses();\n//\t\tSystem.out.println(\"allLoadedClasses数量:\" + allLoadedClasses.length);\n\n\t\tMap<String, Class> finupAllLoadedClasses = new HashMap<>();\n\t\ttry {\n\t\t\tfor (Class loadedClass : allLoadedClasses) {\n\n\t\t\t\tif (loadedClass == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (loadedClass.getCanonicalName() == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!loadedClass.getCanonicalName().startsWith(\"com.finup\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (hashCached.contains(loadedClass.getCanonicalName())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfinupAllLoadedClasses.put(loadedClass.getCanonicalName(), loadedClass);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tMap<String, byte[]> rewriteClasses = ClassesLoadUtil.getRewriteClasses(agentArgs);\n\t\tfor (String className : hashCached) {\n\t\t\trewriteClasses.remove(className);\n\t\t}\n\n\t\tif (finupAllLoadedClasses.size() == 0 || rewriteClasses.size() == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tSystem.out.println(\"finupAllLoadedClasses数量:\" + finupAllLoadedClasses.size());\n\n\t\tfor (String className : rewriteClasses.keySet()) {\n\t\t\tbyte[] classBytes = rewriteClasses.get(className);\n\n\t\t\tif (classBytes == null || classBytes.length == 0) {\n\t\t\t\tSystem.out.println(\"从 rewriteClasses 找不到class: \" + className);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClass redefineClass = finupAllLoadedClasses.get(className);\n\t\t\tif (redefineClass == null) {\n\t\t\t\tSystem.out.println(\"从 finupAllLoadedClasses 找不到class: \" + className);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tSystem.out.println(\"开始redefineClasses: \" + className);\n\n\t\t\tClassDefinition classDefinition = new ClassDefinition(redefineClass, classBytes);\n\n\t\t\ttry {\n\t\t\t\tinstrumentation.redefineClasses(classDefinition);\n\t\t\t\thashCached.add(className);\n\n\t\t\t\tSystem.out.println(\"结束redefineClasses: \" + className);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (UnmodifiableClassException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n}\n```\n\n```java\npublic class ClassesLoadUtil {\n\n\tprivate static final Map<String, byte[]> path2Classes = new ConcurrentHashMap<>();\n\tprivate static final Map<String, byte[]> className2Classes = new ConcurrentHashMap<>();\n\n\tprivate static boolean havaLoaded = false;\n\n\tprivate static void loadFromZipFile(String jarPath) {\n\t\ttry {\n\t\t\tZipFile zipFile = new ZipFile(jarPath);\n\t\t\tEnumeration<? extends ZipEntry> entrys = zipFile.entries();\n\t\t\twhile (entrys.hasMoreElements()) {\n\t\t\t\tZipEntry zipEntry = entrys.nextElement();\n\t\t\t\tentryRead(jarPath, zipEntry);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tprivate static boolean entryRead(String jarPath, ZipEntry ze) throws IOException {\n\t\tif (ze.getSize() > 0) {\n\t\t\tString fileName = ze.getName();\n\t\t\tif (!fileName.endsWith(\".class\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!fileName.contains(\"finup\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\ttry (ZipFile zf = new ZipFile(jarPath); InputStream input = zf.getInputStream(ze);\n\t\t\t     ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {\n\t\t\t\tif (input == null) {\n//\t\t\t\t\t\t\t\tlogger.error(\"Code Reload cant find file : \" + fileName);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tint b = 0;\n\t\t\t\twhile ((b = input.read()) != -1) {\n\t\t\t\t\tbyteArrayOutputStream.write(b);\n\t\t\t\t}\n\t\t\t\tbyte[] bytes = byteArrayOutputStream.toByteArray();\n\n\t\t\t\tpath2Classes.put(fileName, bytes);\n\n\t\t\t\tString name1 = fileName.replaceAll(\"\\\\.class\", \"\");\n\t\t\t\tString name2 = name1.replaceAll(\"/\", \".\");\n\n\t\t\t\tclassName2Classes.put(name2, bytes);\n\n\t\t\t\tSystem.out.println(\"加载文件: fileName : \" + fileName + \".  className:\" + name2);\n\t\t\t}\n\t\t} else {\n//\t\t\tSystem.out.println(ze.getName() + \" size is 0\");\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic static Map<String, byte[]> getRewriteClasses(String agentArgs) {\n\t\tsynchronized (className2Classes) {\n\t\t\tif (!havaLoaded) {\n\t\t\t\tloadFromZipFile(agentArgs);\n\t\t\t\thavaLoaded = true;\n\t\t\t}\n\t\t}\n\n\t\treturn className2Classes;\n\t}\n}\n```\nMF\n```\nManifest-Version: 1.0\nPremain-Class: co.wangming.agent.Agent\nCan-Redefine-Classes: true\nCan-Retransform-Classes: true\n```\n\n基本上这三个文件就可以完成功能了.\n\n## agent-client\n\n```\n├── pom.xml\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── co\n    │   │       └── wangming\n    │   │           └── agent_client\n    │   │               └── service\n    │   │                   └── TestService\n    │   └── resources\n    │       └── META-INF\n    │           └── MANIFEST.MF\n    └── test\n        └── java\n```\n\n```\nManifest-Version: 1.0\nPremain-Class: co.wangming.agent.Agent\nCan-Redefine-Classes: true\nCan-Retransform-Classes: true\n```\n我们只需要把需要覆盖的`TestService`类在这里重写一下就好了, 但是注意, 不能删除/增加 方法/字段, 不能修改继承结构. 总而言之就是不能修改类的结构, 但是只是修改方法实现应该也能满足大多数需求了.\n\n> 以后有时间再想想怎么用Spring AOP来实现","slug":"agent-mock","published":1,"updated":"2019-11-04T05:49:02.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2k1g06k00005c37g0f91g5q","content":"<h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A)\"></a>A)</h1><p>最近组内项目有个模块进行了较大规模的重构, 需要跑一下压力测试, 看一下性能如何. 但是介于产品的模式, 在正常场景下需要向通道发送消息, 然而在压测中, 我们希望这段行为能被mock掉.<br>当时想到的方案可以采用Spring AOP, JMockit或者自己通过Javasisit/ASM这种字节码框架来实现功能.</p>\n<p>由于项目中我自己很少使用Spring AOP来做一些功能, 便没让它当首选方案, 研究了一下JMockit实现, 发现是使用动态Agent实现的.ok, 那么便初步定了一下方案Agent+Javasisit来实现(ASM手写字节码实在太痛苦).</p>\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B)\"></a>B)</h1><blockquote>\n<p>这一段貌似是废话, 你们也看不见代码发生的真实地转变, 我只是记录一下心路历程.</p>\n</blockquote>\n<p>利用了2个小时, 采用Agent+Javasisit实现了一个小的模块, 基本功能也都实现了, 但是使用起来实在是太麻烦了, 代码耦合性太高. 于是又换了个思路, 去掉了Javasisit框架, 也完美地实现了功能.</p>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C)\"></a>C)</h1><p>整个mock框架分为俩部分.</p>\n<ul>\n<li>agent-core, mock的核心代码</li>\n<li>agent-client, 在这个工程中, 我们只需要在pom中引入需要替换的工程的依赖, 然后再agent-client中把要替换的类重写一遍就好了</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"核心部分\"><a href=\"#核心部分\" class=\"headerlink\" title=\"核心部分\"></a>核心部分</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── main</span><br><span class=\"line\">    │   ├── java</span><br><span class=\"line\">    │   │   └── co</span><br><span class=\"line\">    │   │       └── wangming</span><br><span class=\"line\">    │   │           └── agent</span><br><span class=\"line\">    │   │               ├── Agent.java</span><br><span class=\"line\">    │   │               └── ClassesLoadUtil.java</span><br><span class=\"line\">    │   └── resources</span><br><span class=\"line\">    │       └── META-INF</span><br><span class=\"line\">    │           └── MANIFEST.MF</span><br><span class=\"line\">    └── test</span><br><span class=\"line\">        └── java</span><br><span class=\"line\">            └── Test.java</span><br></pre></td></tr></table></figure>\n<p>核心就是俩个Java文件和一个MF文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Agent</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> ScheduledExecutorService scheduledExecutorService = <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> List&lt;String&gt; hashCached = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">premain</span><span class=\"params\">(String agentArgs, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"Agnet 进入!!! \"</span> + agentArgs);</span><br><span class=\"line\">\t\tscheduledExecutorService.scheduleAtFixedRate(() -&gt; tryRedefine(instrumentation, agentArgs), <span class=\"number\">0</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tryRedefine</span><span class=\"params\">(Instrumentation instrumentation, String agentArgs)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tClass[] allLoadedClasses = instrumentation.getAllLoadedClasses();</span><br><span class=\"line\"><span class=\"comment\">//\t\tSystem.out.println(\"allLoadedClasses数量:\" + allLoadedClasses.length);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tMap&lt;String, Class&gt; finupAllLoadedClasses = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (Class loadedClass : allLoadedClasses) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (loadedClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (loadedClass.getCanonicalName() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!loadedClass.getCanonicalName().startsWith(<span class=\"string\">\"com.finup\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (hashCached.contains(loadedClass.getCanonicalName())) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tfinupAllLoadedClasses.put(loadedClass.getCanonicalName(), loadedClass);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tMap&lt;String, <span class=\"keyword\">byte</span>[]&gt; rewriteClasses = ClassesLoadUtil.getRewriteClasses(agentArgs);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (String className : hashCached) &#123;</span><br><span class=\"line\">\t\t\trewriteClasses.remove(className);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (finupAllLoadedClasses.size() == <span class=\"number\">0</span> || rewriteClasses.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"finupAllLoadedClasses数量:\"</span> + finupAllLoadedClasses.size());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (String className : rewriteClasses.keySet()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] classBytes = rewriteClasses.get(className);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (classBytes == <span class=\"keyword\">null</span> || classBytes.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"从 rewriteClasses 找不到class: \"</span> + className);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tClass redefineClass = finupAllLoadedClasses.get(className);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (redefineClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"从 finupAllLoadedClasses 找不到class: \"</span> + className);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"开始redefineClasses: \"</span> + className);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tClassDefinition classDefinition = <span class=\"keyword\">new</span> ClassDefinition(redefineClass, classBytes);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tinstrumentation.redefineClasses(classDefinition);</span><br><span class=\"line\">\t\t\t\thashCached.add(className);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"结束redefineClasses: \"</span> + className);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (UnmodifiableClassException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassesLoadUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, <span class=\"keyword\">byte</span>[]&gt; path2Classes = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, <span class=\"keyword\">byte</span>[]&gt; className2Classes = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> havaLoaded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loadFromZipFile</span><span class=\"params\">(String jarPath)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tZipFile zipFile = <span class=\"keyword\">new</span> ZipFile(jarPath);</span><br><span class=\"line\">\t\t\tEnumeration&lt;? extends ZipEntry&gt; entrys = zipFile.entries();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (entrys.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\t\tZipEntry zipEntry = entrys.nextElement();</span><br><span class=\"line\">\t\t\t\tentryRead(jarPath, zipEntry);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">entryRead</span><span class=\"params\">(String jarPath, ZipEntry ze)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ze.getSize() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tString fileName = ze.getName();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!fileName.endsWith(<span class=\"string\">\".class\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!fileName.contains(<span class=\"string\">\"finup\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> (ZipFile zf = <span class=\"keyword\">new</span> ZipFile(jarPath); InputStream input = zf.getInputStream(ze);</span><br><span class=\"line\">\t\t\t     ByteArrayOutputStream byteArrayOutputStream = <span class=\"keyword\">new</span> ByteArrayOutputStream()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (input == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\t\t\t\t\tlogger.error(\"Code Reload cant find file : \" + fileName);</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> ((b = input.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tbyteArrayOutputStream.write(b);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">byte</span>[] bytes = byteArrayOutputStream.toByteArray();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tpath2Classes.put(fileName, bytes);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tString name1 = fileName.replaceAll(<span class=\"string\">\"\\\\.class\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">\t\t\t\tString name2 = name1.replaceAll(<span class=\"string\">\"/\"</span>, <span class=\"string\">\".\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tclassName2Classes.put(name2, bytes);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"加载文件: fileName : \"</span> + fileName + <span class=\"string\">\".  className:\"</span> + name2);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//\t\t\tSystem.out.println(ze.getName() + \" size is 0\");</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, <span class=\"keyword\">byte</span>[]&gt; getRewriteClasses(String agentArgs) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (className2Classes) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!havaLoaded) &#123;</span><br><span class=\"line\">\t\t\t\tloadFromZipFile(agentArgs);</span><br><span class=\"line\">\t\t\t\thavaLoaded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> className2Classes;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MF</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Premain-Class: co.wangming.agent.Agent</span><br><span class=\"line\">Can-Redefine-Classes: true</span><br><span class=\"line\">Can-Retransform-Classes: true</span><br></pre></td></tr></table></figure>\n\n<p>基本上这三个文件就可以完成功能了.</p>\n<h2 id=\"agent-client\"><a href=\"#agent-client\" class=\"headerlink\" title=\"agent-client\"></a>agent-client</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── main</span><br><span class=\"line\">    │   ├── java</span><br><span class=\"line\">    │   │   └── co</span><br><span class=\"line\">    │   │       └── wangming</span><br><span class=\"line\">    │   │           └── agent_client</span><br><span class=\"line\">    │   │               └── service</span><br><span class=\"line\">    │   │                   └── TestService</span><br><span class=\"line\">    │   └── resources</span><br><span class=\"line\">    │       └── META-INF</span><br><span class=\"line\">    │           └── MANIFEST.MF</span><br><span class=\"line\">    └── test</span><br><span class=\"line\">        └── java</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Premain-Class: co.wangming.agent.Agent</span><br><span class=\"line\">Can-Redefine-Classes: true</span><br><span class=\"line\">Can-Retransform-Classes: true</span><br></pre></td></tr></table></figure>\n<p>我们只需要把需要覆盖的<code>TestService</code>类在这里重写一下就好了, 但是注意, 不能删除/增加 方法/字段, 不能修改继承结构. 总而言之就是不能修改类的结构, 但是只是修改方法实现应该也能满足大多数需求了.</p>\n<blockquote>\n<p>以后有时间再想想怎么用Spring AOP来实现</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A)\"></a>A)</h1><p>最近组内项目有个模块进行了较大规模的重构, 需要跑一下压力测试, 看一下性能如何. 但是介于产品的模式, 在正常场景下需要向通道发送消息, 然而在压测中, 我们希望这段行为能被mock掉.<br>当时想到的方案可以采用Spring AOP, JMockit或者自己通过Javasisit/ASM这种字节码框架来实现功能.</p>\n<p>由于项目中我自己很少使用Spring AOP来做一些功能, 便没让它当首选方案, 研究了一下JMockit实现, 发现是使用动态Agent实现的.ok, 那么便初步定了一下方案Agent+Javasisit来实现(ASM手写字节码实在太痛苦).</p>\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B)\"></a>B)</h1><blockquote>\n<p>这一段貌似是废话, 你们也看不见代码发生的真实地转变, 我只是记录一下心路历程.</p>\n</blockquote>\n<p>利用了2个小时, 采用Agent+Javasisit实现了一个小的模块, 基本功能也都实现了, 但是使用起来实在是太麻烦了, 代码耦合性太高. 于是又换了个思路, 去掉了Javasisit框架, 也完美地实现了功能.</p>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C)\"></a>C)</h1><p>整个mock框架分为俩部分.</p>\n<ul>\n<li>agent-core, mock的核心代码</li>\n<li>agent-client, 在这个工程中, 我们只需要在pom中引入需要替换的工程的依赖, 然后再agent-client中把要替换的类重写一遍就好了</li>\n</ul>","more":"<h2 id=\"核心部分\"><a href=\"#核心部分\" class=\"headerlink\" title=\"核心部分\"></a>核心部分</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── main</span><br><span class=\"line\">    │   ├── java</span><br><span class=\"line\">    │   │   └── co</span><br><span class=\"line\">    │   │       └── wangming</span><br><span class=\"line\">    │   │           └── agent</span><br><span class=\"line\">    │   │               ├── Agent.java</span><br><span class=\"line\">    │   │               └── ClassesLoadUtil.java</span><br><span class=\"line\">    │   └── resources</span><br><span class=\"line\">    │       └── META-INF</span><br><span class=\"line\">    │           └── MANIFEST.MF</span><br><span class=\"line\">    └── test</span><br><span class=\"line\">        └── java</span><br><span class=\"line\">            └── Test.java</span><br></pre></td></tr></table></figure>\n<p>核心就是俩个Java文件和一个MF文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Agent</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> ScheduledExecutorService scheduledExecutorService = <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> List&lt;String&gt; hashCached = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">premain</span><span class=\"params\">(String agentArgs, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"Agnet 进入!!! \"</span> + agentArgs);</span><br><span class=\"line\">\t\tscheduledExecutorService.scheduleAtFixedRate(() -&gt; tryRedefine(instrumentation, agentArgs), <span class=\"number\">0</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">tryRedefine</span><span class=\"params\">(Instrumentation instrumentation, String agentArgs)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tClass[] allLoadedClasses = instrumentation.getAllLoadedClasses();</span><br><span class=\"line\"><span class=\"comment\">//\t\tSystem.out.println(\"allLoadedClasses数量:\" + allLoadedClasses.length);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tMap&lt;String, Class&gt; finupAllLoadedClasses = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (Class loadedClass : allLoadedClasses) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (loadedClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (loadedClass.getCanonicalName() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!loadedClass.getCanonicalName().startsWith(<span class=\"string\">\"com.finup\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (hashCached.contains(loadedClass.getCanonicalName())) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tfinupAllLoadedClasses.put(loadedClass.getCanonicalName(), loadedClass);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tMap&lt;String, <span class=\"keyword\">byte</span>[]&gt; rewriteClasses = ClassesLoadUtil.getRewriteClasses(agentArgs);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (String className : hashCached) &#123;</span><br><span class=\"line\">\t\t\trewriteClasses.remove(className);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (finupAllLoadedClasses.size() == <span class=\"number\">0</span> || rewriteClasses.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"finupAllLoadedClasses数量:\"</span> + finupAllLoadedClasses.size());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (String className : rewriteClasses.keySet()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] classBytes = rewriteClasses.get(className);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (classBytes == <span class=\"keyword\">null</span> || classBytes.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"从 rewriteClasses 找不到class: \"</span> + className);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tClass redefineClass = finupAllLoadedClasses.get(className);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (redefineClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"从 finupAllLoadedClasses 找不到class: \"</span> + className);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"开始redefineClasses: \"</span> + className);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tClassDefinition classDefinition = <span class=\"keyword\">new</span> ClassDefinition(redefineClass, classBytes);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tinstrumentation.redefineClasses(classDefinition);</span><br><span class=\"line\">\t\t\t\thashCached.add(className);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"结束redefineClasses: \"</span> + className);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (UnmodifiableClassException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassesLoadUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, <span class=\"keyword\">byte</span>[]&gt; path2Classes = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, <span class=\"keyword\">byte</span>[]&gt; className2Classes = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> havaLoaded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loadFromZipFile</span><span class=\"params\">(String jarPath)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tZipFile zipFile = <span class=\"keyword\">new</span> ZipFile(jarPath);</span><br><span class=\"line\">\t\t\tEnumeration&lt;? extends ZipEntry&gt; entrys = zipFile.entries();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (entrys.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\t\tZipEntry zipEntry = entrys.nextElement();</span><br><span class=\"line\">\t\t\t\tentryRead(jarPath, zipEntry);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">entryRead</span><span class=\"params\">(String jarPath, ZipEntry ze)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ze.getSize() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tString fileName = ze.getName();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!fileName.endsWith(<span class=\"string\">\".class\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!fileName.contains(<span class=\"string\">\"finup\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> (ZipFile zf = <span class=\"keyword\">new</span> ZipFile(jarPath); InputStream input = zf.getInputStream(ze);</span><br><span class=\"line\">\t\t\t     ByteArrayOutputStream byteArrayOutputStream = <span class=\"keyword\">new</span> ByteArrayOutputStream()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (input == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\t\t\t\t\tlogger.error(\"Code Reload cant find file : \" + fileName);</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> ((b = input.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tbyteArrayOutputStream.write(b);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">byte</span>[] bytes = byteArrayOutputStream.toByteArray();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tpath2Classes.put(fileName, bytes);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tString name1 = fileName.replaceAll(<span class=\"string\">\"\\\\.class\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">\t\t\t\tString name2 = name1.replaceAll(<span class=\"string\">\"/\"</span>, <span class=\"string\">\".\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tclassName2Classes.put(name2, bytes);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"加载文件: fileName : \"</span> + fileName + <span class=\"string\">\".  className:\"</span> + name2);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//\t\t\tSystem.out.println(ze.getName() + \" size is 0\");</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, <span class=\"keyword\">byte</span>[]&gt; getRewriteClasses(String agentArgs) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (className2Classes) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!havaLoaded) &#123;</span><br><span class=\"line\">\t\t\t\tloadFromZipFile(agentArgs);</span><br><span class=\"line\">\t\t\t\thavaLoaded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> className2Classes;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MF</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Premain-Class: co.wangming.agent.Agent</span><br><span class=\"line\">Can-Redefine-Classes: true</span><br><span class=\"line\">Can-Retransform-Classes: true</span><br></pre></td></tr></table></figure>\n\n<p>基本上这三个文件就可以完成功能了.</p>\n<h2 id=\"agent-client\"><a href=\"#agent-client\" class=\"headerlink\" title=\"agent-client\"></a>agent-client</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── main</span><br><span class=\"line\">    │   ├── java</span><br><span class=\"line\">    │   │   └── co</span><br><span class=\"line\">    │   │       └── wangming</span><br><span class=\"line\">    │   │           └── agent_client</span><br><span class=\"line\">    │   │               └── service</span><br><span class=\"line\">    │   │                   └── TestService</span><br><span class=\"line\">    │   └── resources</span><br><span class=\"line\">    │       └── META-INF</span><br><span class=\"line\">    │           └── MANIFEST.MF</span><br><span class=\"line\">    └── test</span><br><span class=\"line\">        └── java</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Manifest-Version: 1.0</span><br><span class=\"line\">Premain-Class: co.wangming.agent.Agent</span><br><span class=\"line\">Can-Redefine-Classes: true</span><br><span class=\"line\">Can-Retransform-Classes: true</span><br></pre></td></tr></table></figure>\n<p>我们只需要把需要覆盖的<code>TestService</code>类在这里重写一下就好了, 但是注意, 不能删除/增加 方法/字段, 不能修改继承结构. 总而言之就是不能修改类的结构, 但是只是修改方法实现应该也能满足大多数需求了.</p>\n<blockquote>\n<p>以后有时间再想想怎么用Spring AOP来实现</p>\n</blockquote>"},{"title":"Java入门及书单","date":"2018-11-14T06:13:00.000Z","_content":"\n## 入门\n今天周六, 在家闲来无事, 多写俩篇博客(本想说成写文章, 但想了想该文实在承担不起文章二字, 便罢) 把最近看到的和想到的记录一下(恰好也把俩三年前写博客的热情又拾了起来).\n\n经常在知乎上看到, 有人发问, 新人如何入门Java, 新人应该读哪些Java相关的书籍, 今天来谈谈这个问题.\n\nJava入门的话, 分析一下哪些行文算是入门\n* 搭建Java开发环境\n* 掌握Java基础语法(原生类型/包装类型, 变量声明, 循环控制, 方法声明/调用, 类定义, 实例化对象...)\n\n私认为掌握上面这俩点就算Java入门了, 也不需要买什么书籍, 在网上找个教程, 或者去慕课网/B站/油管 上面找个教学教程, 利用3-5天的时间学一学就好了, 会用能记住就ok了, 不必深究语法.\n> 上面第二点只是把当下想到的说了一下, 更多的还请参考([Java 教程](http://www.runoob.com/java/java-tutorial.html)).\n\n入门之后干什么呢? 找一个自己喜欢的方向, 做个小项目练练手. 例如写一个web项目, 再学习一下下面的几个技术\n* SpringBoot: 用于后台web服务器\n* Mybatis: 替代原生的JDBC, 与mysql打交道的\n* vue/element-ui: 写前台页面的\n\n基本上用上面这三个技术就能写一个后台管理系统出来, 当然我也只是把我熟悉的技术写了一下, 如果你身边有其他技术栈的同学指导, 也可以采用其他的技术栈.\n> 如果前台从0写起来比较费劲, 可以参考一个开源的前端工程[vue-element-admin](https://github.com/PanJiaChen/vue-element-admin)\n\n随着功能的不断完善, 你对技术的理解也会不断的加深, 开发的兴趣也会不断加大. 只有对一件事情有兴趣了, 我们才想把它做好, 不是吗? \n\n<!--more-->\n\n## 书单\n我基本上没有买过/看过Java基础书, 类似于Java从入门到精通这一类的, 所以我给出的一些书单都具有一些方向性.\n\n##### 网络相关\n* Java网络编程: 将Java中网络相关的包都讲解了一下, 写的不错\n* Netty权威指南: 由于我是做游戏出身的, 工作上基本上netty就是标配了, netty对我在代码架构上有比较大的影响(各种继承, 抽象, 笑哭.jpg)\n* Tomcat架构解析: 对Tomcat剖析的非常深入的一本书, Java程序员必读\n* 图解TCP/IP: 同样的是一本好书, 在轻松氛围下对tcp/ip协议栈有一个比较清晰的认识, 算是tcp/ip协议栈的入门书籍吧.\n* zeroc ice权威指南: 这本书其实没啥好说的, 如果公司在用ice而自己又不熟悉ice的话, 直接买来读就是了, 如果没有用, 暂时也不必入这个坑\n\n##### 并发相关\n并发编程, 按照下面的顺序去读这三本书就好了.\n* Java7 编发编程实战手册, 这本书新手读起来就不错了, 详细介绍了Java中各种并发API的使用.\n* Java并发编程实战, 刚开始编程时不推荐这本书, 新人学习起来难度大一些, 概念颇多.\n* 多处理器编程的艺术, 如果想要深入各种锁的实现, 并发原理的话, 这本书着实该读.\n\n#### JVM相关\n提到Java永远也绕不过去jvm\n* Java虚拟机规范\n* 深入理解Java虚拟机\n* 实战Java虚拟机\n* 垃圾回收的算法与实现\n\n#### 其他\n* 算法(第四版)\n* 大话数据结构\n* Effective Java\n\n目前能想到的书就这么多, 可以根据自己的兴趣和方向选择来读哈.\n\n","source":"_posts/java-books.md","raw":"---\ntitle: Java入门及书单\ndate: 2018-11-14 14:13:00\n---\n\n## 入门\n今天周六, 在家闲来无事, 多写俩篇博客(本想说成写文章, 但想了想该文实在承担不起文章二字, 便罢) 把最近看到的和想到的记录一下(恰好也把俩三年前写博客的热情又拾了起来).\n\n经常在知乎上看到, 有人发问, 新人如何入门Java, 新人应该读哪些Java相关的书籍, 今天来谈谈这个问题.\n\nJava入门的话, 分析一下哪些行文算是入门\n* 搭建Java开发环境\n* 掌握Java基础语法(原生类型/包装类型, 变量声明, 循环控制, 方法声明/调用, 类定义, 实例化对象...)\n\n私认为掌握上面这俩点就算Java入门了, 也不需要买什么书籍, 在网上找个教程, 或者去慕课网/B站/油管 上面找个教学教程, 利用3-5天的时间学一学就好了, 会用能记住就ok了, 不必深究语法.\n> 上面第二点只是把当下想到的说了一下, 更多的还请参考([Java 教程](http://www.runoob.com/java/java-tutorial.html)).\n\n入门之后干什么呢? 找一个自己喜欢的方向, 做个小项目练练手. 例如写一个web项目, 再学习一下下面的几个技术\n* SpringBoot: 用于后台web服务器\n* Mybatis: 替代原生的JDBC, 与mysql打交道的\n* vue/element-ui: 写前台页面的\n\n基本上用上面这三个技术就能写一个后台管理系统出来, 当然我也只是把我熟悉的技术写了一下, 如果你身边有其他技术栈的同学指导, 也可以采用其他的技术栈.\n> 如果前台从0写起来比较费劲, 可以参考一个开源的前端工程[vue-element-admin](https://github.com/PanJiaChen/vue-element-admin)\n\n随着功能的不断完善, 你对技术的理解也会不断的加深, 开发的兴趣也会不断加大. 只有对一件事情有兴趣了, 我们才想把它做好, 不是吗? \n\n<!--more-->\n\n## 书单\n我基本上没有买过/看过Java基础书, 类似于Java从入门到精通这一类的, 所以我给出的一些书单都具有一些方向性.\n\n##### 网络相关\n* Java网络编程: 将Java中网络相关的包都讲解了一下, 写的不错\n* Netty权威指南: 由于我是做游戏出身的, 工作上基本上netty就是标配了, netty对我在代码架构上有比较大的影响(各种继承, 抽象, 笑哭.jpg)\n* Tomcat架构解析: 对Tomcat剖析的非常深入的一本书, Java程序员必读\n* 图解TCP/IP: 同样的是一本好书, 在轻松氛围下对tcp/ip协议栈有一个比较清晰的认识, 算是tcp/ip协议栈的入门书籍吧.\n* zeroc ice权威指南: 这本书其实没啥好说的, 如果公司在用ice而自己又不熟悉ice的话, 直接买来读就是了, 如果没有用, 暂时也不必入这个坑\n\n##### 并发相关\n并发编程, 按照下面的顺序去读这三本书就好了.\n* Java7 编发编程实战手册, 这本书新手读起来就不错了, 详细介绍了Java中各种并发API的使用.\n* Java并发编程实战, 刚开始编程时不推荐这本书, 新人学习起来难度大一些, 概念颇多.\n* 多处理器编程的艺术, 如果想要深入各种锁的实现, 并发原理的话, 这本书着实该读.\n\n#### JVM相关\n提到Java永远也绕不过去jvm\n* Java虚拟机规范\n* 深入理解Java虚拟机\n* 实战Java虚拟机\n* 垃圾回收的算法与实现\n\n#### 其他\n* 算法(第四版)\n* 大话数据结构\n* Effective Java\n\n目前能想到的书就这么多, 可以根据自己的兴趣和方向选择来读哈.\n\n","slug":"java-books","published":1,"updated":"2019-11-04T05:49:02.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2k1g06p00015c37hewu1842","content":"<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>今天周六, 在家闲来无事, 多写俩篇博客(本想说成写文章, 但想了想该文实在承担不起文章二字, 便罢) 把最近看到的和想到的记录一下(恰好也把俩三年前写博客的热情又拾了起来).</p>\n<p>经常在知乎上看到, 有人发问, 新人如何入门Java, 新人应该读哪些Java相关的书籍, 今天来谈谈这个问题.</p>\n<p>Java入门的话, 分析一下哪些行文算是入门</p>\n<ul>\n<li>搭建Java开发环境</li>\n<li>掌握Java基础语法(原生类型/包装类型, 变量声明, 循环控制, 方法声明/调用, 类定义, 实例化对象…)</li>\n</ul>\n<p>私认为掌握上面这俩点就算Java入门了, 也不需要买什么书籍, 在网上找个教程, 或者去慕课网/B站/油管 上面找个教学教程, 利用3-5天的时间学一学就好了, 会用能记住就ok了, 不必深究语法.</p>\n<blockquote>\n<p>上面第二点只是把当下想到的说了一下, 更多的还请参考(<a href=\"http://www.runoob.com/java/java-tutorial.html\" target=\"_blank\" rel=\"noopener\">Java 教程</a>).</p>\n</blockquote>\n<p>入门之后干什么呢? 找一个自己喜欢的方向, 做个小项目练练手. 例如写一个web项目, 再学习一下下面的几个技术</p>\n<ul>\n<li>SpringBoot: 用于后台web服务器</li>\n<li>Mybatis: 替代原生的JDBC, 与mysql打交道的</li>\n<li>vue/element-ui: 写前台页面的</li>\n</ul>\n<p>基本上用上面这三个技术就能写一个后台管理系统出来, 当然我也只是把我熟悉的技术写了一下, 如果你身边有其他技术栈的同学指导, 也可以采用其他的技术栈.</p>\n<blockquote>\n<p>如果前台从0写起来比较费劲, 可以参考一个开源的前端工程<a href=\"https://github.com/PanJiaChen/vue-element-admin\" target=\"_blank\" rel=\"noopener\">vue-element-admin</a></p>\n</blockquote>\n<p>随着功能的不断完善, 你对技术的理解也会不断的加深, 开发的兴趣也会不断加大. 只有对一件事情有兴趣了, 我们才想把它做好, 不是吗? </p>\n<a id=\"more\"></a>\n\n<h2 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h2><p>我基本上没有买过/看过Java基础书, 类似于Java从入门到精通这一类的, 所以我给出的一些书单都具有一些方向性.</p>\n<h5 id=\"网络相关\"><a href=\"#网络相关\" class=\"headerlink\" title=\"网络相关\"></a>网络相关</h5><ul>\n<li>Java网络编程: 将Java中网络相关的包都讲解了一下, 写的不错</li>\n<li>Netty权威指南: 由于我是做游戏出身的, 工作上基本上netty就是标配了, netty对我在代码架构上有比较大的影响(各种继承, 抽象, 笑哭.jpg)</li>\n<li>Tomcat架构解析: 对Tomcat剖析的非常深入的一本书, Java程序员必读</li>\n<li>图解TCP/IP: 同样的是一本好书, 在轻松氛围下对tcp/ip协议栈有一个比较清晰的认识, 算是tcp/ip协议栈的入门书籍吧.</li>\n<li>zeroc ice权威指南: 这本书其实没啥好说的, 如果公司在用ice而自己又不熟悉ice的话, 直接买来读就是了, 如果没有用, 暂时也不必入这个坑</li>\n</ul>\n<h5 id=\"并发相关\"><a href=\"#并发相关\" class=\"headerlink\" title=\"并发相关\"></a>并发相关</h5><p>并发编程, 按照下面的顺序去读这三本书就好了.</p>\n<ul>\n<li>Java7 编发编程实战手册, 这本书新手读起来就不错了, 详细介绍了Java中各种并发API的使用.</li>\n<li>Java并发编程实战, 刚开始编程时不推荐这本书, 新人学习起来难度大一些, 概念颇多.</li>\n<li>多处理器编程的艺术, 如果想要深入各种锁的实现, 并发原理的话, 这本书着实该读.</li>\n</ul>\n<h4 id=\"JVM相关\"><a href=\"#JVM相关\" class=\"headerlink\" title=\"JVM相关\"></a>JVM相关</h4><p>提到Java永远也绕不过去jvm</p>\n<ul>\n<li>Java虚拟机规范</li>\n<li>深入理解Java虚拟机</li>\n<li>实战Java虚拟机</li>\n<li>垃圾回收的算法与实现</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li>算法(第四版)</li>\n<li>大话数据结构</li>\n<li>Effective Java</li>\n</ul>\n<p>目前能想到的书就这么多, 可以根据自己的兴趣和方向选择来读哈.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>今天周六, 在家闲来无事, 多写俩篇博客(本想说成写文章, 但想了想该文实在承担不起文章二字, 便罢) 把最近看到的和想到的记录一下(恰好也把俩三年前写博客的热情又拾了起来).</p>\n<p>经常在知乎上看到, 有人发问, 新人如何入门Java, 新人应该读哪些Java相关的书籍, 今天来谈谈这个问题.</p>\n<p>Java入门的话, 分析一下哪些行文算是入门</p>\n<ul>\n<li>搭建Java开发环境</li>\n<li>掌握Java基础语法(原生类型/包装类型, 变量声明, 循环控制, 方法声明/调用, 类定义, 实例化对象…)</li>\n</ul>\n<p>私认为掌握上面这俩点就算Java入门了, 也不需要买什么书籍, 在网上找个教程, 或者去慕课网/B站/油管 上面找个教学教程, 利用3-5天的时间学一学就好了, 会用能记住就ok了, 不必深究语法.</p>\n<blockquote>\n<p>上面第二点只是把当下想到的说了一下, 更多的还请参考(<a href=\"http://www.runoob.com/java/java-tutorial.html\" target=\"_blank\" rel=\"noopener\">Java 教程</a>).</p>\n</blockquote>\n<p>入门之后干什么呢? 找一个自己喜欢的方向, 做个小项目练练手. 例如写一个web项目, 再学习一下下面的几个技术</p>\n<ul>\n<li>SpringBoot: 用于后台web服务器</li>\n<li>Mybatis: 替代原生的JDBC, 与mysql打交道的</li>\n<li>vue/element-ui: 写前台页面的</li>\n</ul>\n<p>基本上用上面这三个技术就能写一个后台管理系统出来, 当然我也只是把我熟悉的技术写了一下, 如果你身边有其他技术栈的同学指导, 也可以采用其他的技术栈.</p>\n<blockquote>\n<p>如果前台从0写起来比较费劲, 可以参考一个开源的前端工程<a href=\"https://github.com/PanJiaChen/vue-element-admin\" target=\"_blank\" rel=\"noopener\">vue-element-admin</a></p>\n</blockquote>\n<p>随着功能的不断完善, 你对技术的理解也会不断的加深, 开发的兴趣也会不断加大. 只有对一件事情有兴趣了, 我们才想把它做好, 不是吗? </p>","more":"<h2 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h2><p>我基本上没有买过/看过Java基础书, 类似于Java从入门到精通这一类的, 所以我给出的一些书单都具有一些方向性.</p>\n<h5 id=\"网络相关\"><a href=\"#网络相关\" class=\"headerlink\" title=\"网络相关\"></a>网络相关</h5><ul>\n<li>Java网络编程: 将Java中网络相关的包都讲解了一下, 写的不错</li>\n<li>Netty权威指南: 由于我是做游戏出身的, 工作上基本上netty就是标配了, netty对我在代码架构上有比较大的影响(各种继承, 抽象, 笑哭.jpg)</li>\n<li>Tomcat架构解析: 对Tomcat剖析的非常深入的一本书, Java程序员必读</li>\n<li>图解TCP/IP: 同样的是一本好书, 在轻松氛围下对tcp/ip协议栈有一个比较清晰的认识, 算是tcp/ip协议栈的入门书籍吧.</li>\n<li>zeroc ice权威指南: 这本书其实没啥好说的, 如果公司在用ice而自己又不熟悉ice的话, 直接买来读就是了, 如果没有用, 暂时也不必入这个坑</li>\n</ul>\n<h5 id=\"并发相关\"><a href=\"#并发相关\" class=\"headerlink\" title=\"并发相关\"></a>并发相关</h5><p>并发编程, 按照下面的顺序去读这三本书就好了.</p>\n<ul>\n<li>Java7 编发编程实战手册, 这本书新手读起来就不错了, 详细介绍了Java中各种并发API的使用.</li>\n<li>Java并发编程实战, 刚开始编程时不推荐这本书, 新人学习起来难度大一些, 概念颇多.</li>\n<li>多处理器编程的艺术, 如果想要深入各种锁的实现, 并发原理的话, 这本书着实该读.</li>\n</ul>\n<h4 id=\"JVM相关\"><a href=\"#JVM相关\" class=\"headerlink\" title=\"JVM相关\"></a>JVM相关</h4><p>提到Java永远也绕不过去jvm</p>\n<ul>\n<li>Java虚拟机规范</li>\n<li>深入理解Java虚拟机</li>\n<li>实战Java虚拟机</li>\n<li>垃圾回收的算法与实现</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li>算法(第四版)</li>\n<li>大话数据结构</li>\n<li>Effective Java</li>\n</ul>\n<p>目前能想到的书就这么多, 可以根据自己的兴趣和方向选择来读哈.</p>"},{"title":"高并发无锁无IO等待分布式ID生成方案","date":"2018-11-18T03:40:00.000Z","_content":"\n# A)\n网络上现在有很多的分布式ID生成算法, 各大厂商也开源了自己的分布式id生成算法. 前段时间项目里有个生成唯一id的需求, 思考了一下, 将flick的id生成方案和Twitter的id生成算法结合到一起, 写了个小算法, 也算是站在巨人的肩膀上做了点小东西, lol\n\n# B)\n原理大致是这样的, 利用mysql insert来计算出集群中某个节点处于集群中的位置, 算出serverId, 然后利用雪花算法在该id上生成分布式id.\n\n目前的实现是采用long来进行存储的, 因此只能在生成时间维度, 节点数量, 和每毫秒内生成的数量上进行调节, 如果你们可以存储字符串的话, 那么可以拓展一下该算法, 加大时间和空间的容量.\n\n<!--more-->\n\n# C)\n算法实现\n```java\n/**\n * ID 生成器\n * <p>\n * 整个ID算法很简单,\n * 1. 参考Flickr ID生成算法, 使用MYSQL获得一个自增ID, 然后对ID取模, 算出一个服务器ID\n * 2. 参考Twitter的雪花算法, 算出一个long型ID\n * <p>\n * 该算法保证在30年内, 6万台机器, 单机每秒可以产出128, 000个不重复ID\n * <p>\n * <p>\n * CREATE TABLE `account_server_id` (\n * `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n * `stub` char(1) DEFAULT NULL,\n * PRIMARY KEY (`id`),\n * UNIQUE KEY `stub` (`stub`)\n * ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n * <p>\n * <p>\n * |1, 000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0 |000, 0000, 0000, 0000, 0 |000, 0000           |\n * | |                   时间戳(40位)                                |   服务器ID(16位)         | 单个时间戳内的Id(7位) |\n */\n@Service\npublic class IDGeneratorService implements CommandLineRunner {\n\n    private static final Logger LOG = LoggerFactory.getLogger(IDGeneratorService.class);\n\n    // 时间戳从哪一年开始计时\n    private static final int START_YEAR = 2018;\n\n    // 时间取40位, 保证ID34年内不会重复\n    private static final int timeBitsSize = 40;\n    private static final int serverIdBitsSize = 16;\n    private static final int countBitsSize = 7;\n\n    private long maxIdPerMill;\n\n    // 时间开始时间戳, 相当于System.currentTimeMillis()的1970年\n    private long startDateTime;\n    // 服务器ID表示位, 在集群中表示一个节点\n    private long serverIdBits;\n    // 单机中, 某个时刻生长得id\n    private long currentID;\n\n    private long maxTime;\n\n    private long lastGenerateTime = System.currentTimeMillis();\n    private Object lock = new Object();\n\n    @Resource\n    private AccountServerIdMapper accountServerIdMapper;\n\n    public void init() {\n        // 1. 计算出开始生成ID的起始时间戳\n        LocalDateTime start = LocalDateTime.of(START_YEAR, 1, 1, 0, 0);\n        startDateTime = start.toInstant(ZoneOffset.of(\"+8\")).toEpochMilli();\n\n        // 2. 算出支持最大年限的时间\n        maxTime = ((Double) Math.pow(2, timeBitsSize)).longValue();\n\n        // 3. 算出每毫秒能产出多少ID\n        maxIdPerMill = ((Double) Math.pow(2, countBitsSize)).longValue();\n\n        /**\n         * 4. 根据Mysql自增ID取模, 算出每个服务器ID, 在生产环境中, 应该保证服务器数量是该值的一半, 如此一来就可以避免, 服务器集群整体\n         * 重启时, 不会拿到与重启之前的服务器相同的Id\n         * 这个值的计算是为了适应这种场景, 在服务器灰度上线的时候, 有可能是原来的服务器还没有关闭, 但是新的服务器已经起来了, 此时会有俩套\n         * 服务器同时在处理业务逻辑, 那么它们就有可能拿到一样的服务器ID, 从而导致产生一样的ID号\n         */\n        long serverSize = ((Double) Math.pow(2, serverIdBitsSize)).longValue();\n\n        AccountServerId accountServerId = new AccountServerId();\n        accountServerIdMapper.nextId(accountServerId);\n        long serverId = (int) (accountServerId.getId() % serverSize);\n\n        /**\n         * 5. 算出每个服务器ID在long类型中的数据位置, 然后缓存起来\n         */\n        serverIdBits = (serverId << (countBitsSize));\n\n        LOG.info(\"[ID生成器] 开始时间:{}, 时间戳:{} \", new Date(startDateTime), startDateTime);\n        LOG.info(\"[ID生成器] 结束时间:{}, 时间戳:{} \", new Date(startDateTime + maxTime), maxTime);\n        LOG.info(\"[ID生成器] 每毫秒生成最大ID数:{} \", maxIdPerMill);\n        LOG.info(\"[ID生成器] 当前serverId: {}, serverIdSize:{}\", serverId, serverSize);\n        LOG.info(\"[ID生成器] serverIdBits: {}\", Long.toBinaryString(serverIdBits));\n    }\n\n    /**\n     * 生成一个64位的GUID\n     * <p>\n     * 在next()方法中, 没有使用任何的对象, 如此一来就可以减轻GC的压力.\n     *\n     * @return\n     */\n    public long next() {\n\n        synchronized (lock) {\n            long curTime = System.currentTimeMillis() - startDateTime;\n            if (curTime >= maxTime) {\n\t            LOG.error(\"[ID生成器] 超过负载, {}, {}！返回 -1\", curTime, maxTime);\n                return -1;\n            }\n\n            if (lastGenerateTime != curTime) {\n                currentID = 0;\n            } else {\n\n                if (currentID >= maxIdPerMill) {\n\t                LOG.error(\"[ID生成器] 同一毫秒[\" + curTime + \"]内生成\" + currentID + \"个ID！返回 -1\");\n                    return -1;\n                }\n\n                ++currentID;\n            }\n\n            lastGenerateTime = curTime;\n            long gid = (curTime << countBitsSize + serverIdBitsSize) | serverIdBits;\n            gid |= currentID;\n\n            return gid;\n        }\n    }\n\n    public String nextStrId() {\n        return String.valueOf(next());\n    }\n\n    public long tryNextId() {\n        for (int i = 0; i < 1000; i++) {\n\n            long start = System.currentTimeMillis();\n            long id = next();\n            long diff = System.currentTimeMillis() - start;\n            if (diff > 3) {\n                String tid = Thread.currentThread().getName();\n                LOG.warn(\"[ID生成器] 线程{} 生成ID: {} 大于3毫秒: {}\", tid, id, diff);\n            }\n\n            if (id == -1) {\n                try {\n//\t\t\t\t\tLOG.error(\"[ID生成器] 生成ID为-1, 可能超过每毫秒内生成最大数量, 等待1毫秒\");\n                    TimeUnit.MILLISECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                continue;\n            }\n            return id;\n        }\n        return -1;\n    }\n\n    public String tryNextStrId() {\n        return String.valueOf(tryNextId());\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        init();\n    }\n}\n```\nmybatis\n```java\n@Mapper\npublic interface AccountServerIdMapper {\n\n    @Insert(\"REPLACE INTO server_id (stub) VALUES ('a');\")\n    @SelectKey(statement = \"SELECT LAST_INSERT_ID()\", keyProperty = \"id\", before = false, resultType = Long.class)\n    Long nextId(AccountServerId accountServerId);\n\n}\n```\nSQL\n```sql\nCREATE TABLE `server_id` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `stub` char(1) DEFAULT NULL,\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `stub` (`stub`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n```\n测试\n```java\n@RunWith(JMockit.class)\npublic class IDGeneratorUtilTest {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(IDGeneratorUtilTest.class);\n\n\tprivate static final int MAX_TIMES = 2000000;\n\tprivate static final int PRINT_TIMES = 100;\n\n\t@Tested\n\tprivate IDGeneratorService idGeneratorUtil;\n\n\t@Injectable\n\tprivate AccountServerIdMapper accountServerIdMapper;\n\n\t/**\n\t * 21026 [main] DEBUG c.f.l.service.IDGeneratorUtilTest - 20506 毫秒内生成 2000000 个ID\n\t * <p>\n\t * 单线程的情况下, 在MacBook Pro上是每毫秒钟生成 97 个id\n\t */\n\t@Test\n\tpublic void testOneServerIdGenerate() {\n\t\tnew Expectations() {\n\t\t\t{\n\t\t\t\taccountServerIdMapper.nextId((AccountServerId) any);\n\t\t\t\tresult = 2;\n\t\t\t}\n\t\t};\n\t\tidGeneratorUtil.init();\n\n\t\tSet<Long> ids = new HashSet<>();\n\n\t\tlong start = System.currentTimeMillis();\n\n\t\tfor (int i = 0; i < MAX_TIMES; i++) {\n\t\t\tlong id = idGeneratorUtil.tryNextId();\n\t\t\tif (ids.contains(id)) {\n\t\t\t\tSystem.out.println(id);\n\t\t\t}\n\t\t\tids.add(id);\n\t\t}\n\t\tlogger.debug((System.currentTimeMillis() - start) + \" 毫秒内生成 \" + ids.size() + \" 个ID\");\n\t\tAssert.assertEquals(ids.size(), MAX_TIMES);\n\n\t\tObject[] idArray = ids.toArray();\n\t\tfor (int i = 0; i < PRINT_TIMES; i++) {\n\t\t\tlogger.debug(idArray[i] + \" : \" + Long.toBinaryString((Long) idArray[i]));\n\t\t}\n\t}\n\n\t/**\n\t * 207703 [Thread-7] DEBUG c.f.l.service.IDGeneratorUtilTest - 207136 毫秒内生成 2000000 个ID\n\t * 208031 [Thread-3] DEBUG c.f.l.service.IDGeneratorUtilTest - 207465 毫秒内生成 2000000 个ID\n\t * 208626 [Thread-10] DEBUG c.f.l.service.IDGeneratorUtilTest - 208059 毫秒内生成 2000000 个ID\n\t * 208630 [Thread-9] DEBUG c.f.l.service.IDGeneratorUtilTest - 208063 毫秒内生成 2000000 个ID\n\t * 209153 [Thread-6] DEBUG c.f.l.service.IDGeneratorUtilTest - 208586 毫秒内生成 2000000 个ID\n\t * 209170 [Thread-5] DEBUG c.f.l.service.IDGeneratorUtilTest - 208603 毫秒内生成 2000000 个ID\n\t * 209373 [Thread-2] DEBUG c.f.l.service.IDGeneratorUtilTest - 208807 毫秒内生成 2000000 个ID\n\t * 209412 [Thread-1] DEBUG c.f.l.service.IDGeneratorUtilTest - 208846 毫秒内生成 2000000 个ID\n\t * 209508 [Thread-4] DEBUG c.f.l.service.IDGeneratorUtilTest - 208941 毫秒内生成 2000000 个ID\n\t * 209536 [Thread-8] DEBUG c.f.l.service.IDGeneratorUtilTest - 208969 毫秒内生成 2000000 个ID\n\t * <p>\n\t * 多线程的情况下, 在MacBook Pro上是每毫秒钟生成 9 个id, 可见由于锁的竞争, 产生的影响还是非常大的\n\t */\n\t@Test\n\tpublic void testMutilServerIdGenerate() {\n\t\tnew Expectations() {\n\t\t\t{\n\t\t\t\taccountServerIdMapper.nextId((AccountServerId) any);\n\t\t\t\tresult = 2;\n\t\t\t}\n\t\t};\n\t\tidGeneratorUtil.init();\n\n\t\tRunnable runnable = () -> {\n\t\t\tSet<Long> ids = new HashSet<>();\n\n\t\t\tlong start = System.currentTimeMillis();\n\n\t\t\tfor (int i = 0; i < MAX_TIMES; i++) {\n\t\t\t\tlong id = idGeneratorUtil.tryNextId();\n\t\t\t\tids.add(id);\n\t\t\t}\n\t\t\tlogger.debug((System.currentTimeMillis() - start) + \" 毫秒内生成 \" + ids.size() + \" 个ID\");\n\t\t\tAssert.assertEquals(ids.size(), MAX_TIMES);\n\t\t};\n\n\t\tList<Thread> list = new ArrayList<>();\n\t\tint cpus = Runtime.getRuntime().availableProcessors() + 2;\n\t\tlogger.debug(\"CPU : \" + cpus);\n\n\t\tfor (int i = 0; i < cpus; i++) {\n\t\t\tThread thread = new Thread(runnable);\n\t\t\tlist.add(thread);\n\t\t\tthread.start();\n\t\t}\n\n\t\tfor (Thread thread : list) {\n\t\t\ttry {\n\t\t\t\tthread.join();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n}\n```","source":"_posts/distributed-id.md","raw":"---\ntitle: 高并发无锁无IO等待分布式ID生成方案\ndate: 2018-11-18 11:40:00\n---\n\n# A)\n网络上现在有很多的分布式ID生成算法, 各大厂商也开源了自己的分布式id生成算法. 前段时间项目里有个生成唯一id的需求, 思考了一下, 将flick的id生成方案和Twitter的id生成算法结合到一起, 写了个小算法, 也算是站在巨人的肩膀上做了点小东西, lol\n\n# B)\n原理大致是这样的, 利用mysql insert来计算出集群中某个节点处于集群中的位置, 算出serverId, 然后利用雪花算法在该id上生成分布式id.\n\n目前的实现是采用long来进行存储的, 因此只能在生成时间维度, 节点数量, 和每毫秒内生成的数量上进行调节, 如果你们可以存储字符串的话, 那么可以拓展一下该算法, 加大时间和空间的容量.\n\n<!--more-->\n\n# C)\n算法实现\n```java\n/**\n * ID 生成器\n * <p>\n * 整个ID算法很简单,\n * 1. 参考Flickr ID生成算法, 使用MYSQL获得一个自增ID, 然后对ID取模, 算出一个服务器ID\n * 2. 参考Twitter的雪花算法, 算出一个long型ID\n * <p>\n * 该算法保证在30年内, 6万台机器, 单机每秒可以产出128, 000个不重复ID\n * <p>\n * <p>\n * CREATE TABLE `account_server_id` (\n * `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n * `stub` char(1) DEFAULT NULL,\n * PRIMARY KEY (`id`),\n * UNIQUE KEY `stub` (`stub`)\n * ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n * <p>\n * <p>\n * |1, 000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0 |000, 0000, 0000, 0000, 0 |000, 0000           |\n * | |                   时间戳(40位)                                |   服务器ID(16位)         | 单个时间戳内的Id(7位) |\n */\n@Service\npublic class IDGeneratorService implements CommandLineRunner {\n\n    private static final Logger LOG = LoggerFactory.getLogger(IDGeneratorService.class);\n\n    // 时间戳从哪一年开始计时\n    private static final int START_YEAR = 2018;\n\n    // 时间取40位, 保证ID34年内不会重复\n    private static final int timeBitsSize = 40;\n    private static final int serverIdBitsSize = 16;\n    private static final int countBitsSize = 7;\n\n    private long maxIdPerMill;\n\n    // 时间开始时间戳, 相当于System.currentTimeMillis()的1970年\n    private long startDateTime;\n    // 服务器ID表示位, 在集群中表示一个节点\n    private long serverIdBits;\n    // 单机中, 某个时刻生长得id\n    private long currentID;\n\n    private long maxTime;\n\n    private long lastGenerateTime = System.currentTimeMillis();\n    private Object lock = new Object();\n\n    @Resource\n    private AccountServerIdMapper accountServerIdMapper;\n\n    public void init() {\n        // 1. 计算出开始生成ID的起始时间戳\n        LocalDateTime start = LocalDateTime.of(START_YEAR, 1, 1, 0, 0);\n        startDateTime = start.toInstant(ZoneOffset.of(\"+8\")).toEpochMilli();\n\n        // 2. 算出支持最大年限的时间\n        maxTime = ((Double) Math.pow(2, timeBitsSize)).longValue();\n\n        // 3. 算出每毫秒能产出多少ID\n        maxIdPerMill = ((Double) Math.pow(2, countBitsSize)).longValue();\n\n        /**\n         * 4. 根据Mysql自增ID取模, 算出每个服务器ID, 在生产环境中, 应该保证服务器数量是该值的一半, 如此一来就可以避免, 服务器集群整体\n         * 重启时, 不会拿到与重启之前的服务器相同的Id\n         * 这个值的计算是为了适应这种场景, 在服务器灰度上线的时候, 有可能是原来的服务器还没有关闭, 但是新的服务器已经起来了, 此时会有俩套\n         * 服务器同时在处理业务逻辑, 那么它们就有可能拿到一样的服务器ID, 从而导致产生一样的ID号\n         */\n        long serverSize = ((Double) Math.pow(2, serverIdBitsSize)).longValue();\n\n        AccountServerId accountServerId = new AccountServerId();\n        accountServerIdMapper.nextId(accountServerId);\n        long serverId = (int) (accountServerId.getId() % serverSize);\n\n        /**\n         * 5. 算出每个服务器ID在long类型中的数据位置, 然后缓存起来\n         */\n        serverIdBits = (serverId << (countBitsSize));\n\n        LOG.info(\"[ID生成器] 开始时间:{}, 时间戳:{} \", new Date(startDateTime), startDateTime);\n        LOG.info(\"[ID生成器] 结束时间:{}, 时间戳:{} \", new Date(startDateTime + maxTime), maxTime);\n        LOG.info(\"[ID生成器] 每毫秒生成最大ID数:{} \", maxIdPerMill);\n        LOG.info(\"[ID生成器] 当前serverId: {}, serverIdSize:{}\", serverId, serverSize);\n        LOG.info(\"[ID生成器] serverIdBits: {}\", Long.toBinaryString(serverIdBits));\n    }\n\n    /**\n     * 生成一个64位的GUID\n     * <p>\n     * 在next()方法中, 没有使用任何的对象, 如此一来就可以减轻GC的压力.\n     *\n     * @return\n     */\n    public long next() {\n\n        synchronized (lock) {\n            long curTime = System.currentTimeMillis() - startDateTime;\n            if (curTime >= maxTime) {\n\t            LOG.error(\"[ID生成器] 超过负载, {}, {}！返回 -1\", curTime, maxTime);\n                return -1;\n            }\n\n            if (lastGenerateTime != curTime) {\n                currentID = 0;\n            } else {\n\n                if (currentID >= maxIdPerMill) {\n\t                LOG.error(\"[ID生成器] 同一毫秒[\" + curTime + \"]内生成\" + currentID + \"个ID！返回 -1\");\n                    return -1;\n                }\n\n                ++currentID;\n            }\n\n            lastGenerateTime = curTime;\n            long gid = (curTime << countBitsSize + serverIdBitsSize) | serverIdBits;\n            gid |= currentID;\n\n            return gid;\n        }\n    }\n\n    public String nextStrId() {\n        return String.valueOf(next());\n    }\n\n    public long tryNextId() {\n        for (int i = 0; i < 1000; i++) {\n\n            long start = System.currentTimeMillis();\n            long id = next();\n            long diff = System.currentTimeMillis() - start;\n            if (diff > 3) {\n                String tid = Thread.currentThread().getName();\n                LOG.warn(\"[ID生成器] 线程{} 生成ID: {} 大于3毫秒: {}\", tid, id, diff);\n            }\n\n            if (id == -1) {\n                try {\n//\t\t\t\t\tLOG.error(\"[ID生成器] 生成ID为-1, 可能超过每毫秒内生成最大数量, 等待1毫秒\");\n                    TimeUnit.MILLISECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                continue;\n            }\n            return id;\n        }\n        return -1;\n    }\n\n    public String tryNextStrId() {\n        return String.valueOf(tryNextId());\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        init();\n    }\n}\n```\nmybatis\n```java\n@Mapper\npublic interface AccountServerIdMapper {\n\n    @Insert(\"REPLACE INTO server_id (stub) VALUES ('a');\")\n    @SelectKey(statement = \"SELECT LAST_INSERT_ID()\", keyProperty = \"id\", before = false, resultType = Long.class)\n    Long nextId(AccountServerId accountServerId);\n\n}\n```\nSQL\n```sql\nCREATE TABLE `server_id` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `stub` char(1) DEFAULT NULL,\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `stub` (`stub`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n```\n测试\n```java\n@RunWith(JMockit.class)\npublic class IDGeneratorUtilTest {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(IDGeneratorUtilTest.class);\n\n\tprivate static final int MAX_TIMES = 2000000;\n\tprivate static final int PRINT_TIMES = 100;\n\n\t@Tested\n\tprivate IDGeneratorService idGeneratorUtil;\n\n\t@Injectable\n\tprivate AccountServerIdMapper accountServerIdMapper;\n\n\t/**\n\t * 21026 [main] DEBUG c.f.l.service.IDGeneratorUtilTest - 20506 毫秒内生成 2000000 个ID\n\t * <p>\n\t * 单线程的情况下, 在MacBook Pro上是每毫秒钟生成 97 个id\n\t */\n\t@Test\n\tpublic void testOneServerIdGenerate() {\n\t\tnew Expectations() {\n\t\t\t{\n\t\t\t\taccountServerIdMapper.nextId((AccountServerId) any);\n\t\t\t\tresult = 2;\n\t\t\t}\n\t\t};\n\t\tidGeneratorUtil.init();\n\n\t\tSet<Long> ids = new HashSet<>();\n\n\t\tlong start = System.currentTimeMillis();\n\n\t\tfor (int i = 0; i < MAX_TIMES; i++) {\n\t\t\tlong id = idGeneratorUtil.tryNextId();\n\t\t\tif (ids.contains(id)) {\n\t\t\t\tSystem.out.println(id);\n\t\t\t}\n\t\t\tids.add(id);\n\t\t}\n\t\tlogger.debug((System.currentTimeMillis() - start) + \" 毫秒内生成 \" + ids.size() + \" 个ID\");\n\t\tAssert.assertEquals(ids.size(), MAX_TIMES);\n\n\t\tObject[] idArray = ids.toArray();\n\t\tfor (int i = 0; i < PRINT_TIMES; i++) {\n\t\t\tlogger.debug(idArray[i] + \" : \" + Long.toBinaryString((Long) idArray[i]));\n\t\t}\n\t}\n\n\t/**\n\t * 207703 [Thread-7] DEBUG c.f.l.service.IDGeneratorUtilTest - 207136 毫秒内生成 2000000 个ID\n\t * 208031 [Thread-3] DEBUG c.f.l.service.IDGeneratorUtilTest - 207465 毫秒内生成 2000000 个ID\n\t * 208626 [Thread-10] DEBUG c.f.l.service.IDGeneratorUtilTest - 208059 毫秒内生成 2000000 个ID\n\t * 208630 [Thread-9] DEBUG c.f.l.service.IDGeneratorUtilTest - 208063 毫秒内生成 2000000 个ID\n\t * 209153 [Thread-6] DEBUG c.f.l.service.IDGeneratorUtilTest - 208586 毫秒内生成 2000000 个ID\n\t * 209170 [Thread-5] DEBUG c.f.l.service.IDGeneratorUtilTest - 208603 毫秒内生成 2000000 个ID\n\t * 209373 [Thread-2] DEBUG c.f.l.service.IDGeneratorUtilTest - 208807 毫秒内生成 2000000 个ID\n\t * 209412 [Thread-1] DEBUG c.f.l.service.IDGeneratorUtilTest - 208846 毫秒内生成 2000000 个ID\n\t * 209508 [Thread-4] DEBUG c.f.l.service.IDGeneratorUtilTest - 208941 毫秒内生成 2000000 个ID\n\t * 209536 [Thread-8] DEBUG c.f.l.service.IDGeneratorUtilTest - 208969 毫秒内生成 2000000 个ID\n\t * <p>\n\t * 多线程的情况下, 在MacBook Pro上是每毫秒钟生成 9 个id, 可见由于锁的竞争, 产生的影响还是非常大的\n\t */\n\t@Test\n\tpublic void testMutilServerIdGenerate() {\n\t\tnew Expectations() {\n\t\t\t{\n\t\t\t\taccountServerIdMapper.nextId((AccountServerId) any);\n\t\t\t\tresult = 2;\n\t\t\t}\n\t\t};\n\t\tidGeneratorUtil.init();\n\n\t\tRunnable runnable = () -> {\n\t\t\tSet<Long> ids = new HashSet<>();\n\n\t\t\tlong start = System.currentTimeMillis();\n\n\t\t\tfor (int i = 0; i < MAX_TIMES; i++) {\n\t\t\t\tlong id = idGeneratorUtil.tryNextId();\n\t\t\t\tids.add(id);\n\t\t\t}\n\t\t\tlogger.debug((System.currentTimeMillis() - start) + \" 毫秒内生成 \" + ids.size() + \" 个ID\");\n\t\t\tAssert.assertEquals(ids.size(), MAX_TIMES);\n\t\t};\n\n\t\tList<Thread> list = new ArrayList<>();\n\t\tint cpus = Runtime.getRuntime().availableProcessors() + 2;\n\t\tlogger.debug(\"CPU : \" + cpus);\n\n\t\tfor (int i = 0; i < cpus; i++) {\n\t\t\tThread thread = new Thread(runnable);\n\t\t\tlist.add(thread);\n\t\t\tthread.start();\n\t\t}\n\n\t\tfor (Thread thread : list) {\n\t\t\ttry {\n\t\t\t\tthread.join();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n}\n```","slug":"distributed-id","published":1,"updated":"2019-11-04T05:49:02.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2k1g06r00025c37fwi1973j","content":"<h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A)\"></a>A)</h1><p>网络上现在有很多的分布式ID生成算法, 各大厂商也开源了自己的分布式id生成算法. 前段时间项目里有个生成唯一id的需求, 思考了一下, 将flick的id生成方案和Twitter的id生成算法结合到一起, 写了个小算法, 也算是站在巨人的肩膀上做了点小东西, lol</p>\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B)\"></a>B)</h1><p>原理大致是这样的, 利用mysql insert来计算出集群中某个节点处于集群中的位置, 算出serverId, 然后利用雪花算法在该id上生成分布式id.</p>\n<p>目前的实现是采用long来进行存储的, 因此只能在生成时间维度, 节点数量, 和每毫秒内生成的数量上进行调节, 如果你们可以存储字符串的话, 那么可以拓展一下该算法, 加大时间和空间的容量.</p>\n<a id=\"more\"></a>\n\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C)\"></a>C)</h1><p>算法实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ID 生成器</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 整个ID算法很简单,</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 参考Flickr ID生成算法, 使用MYSQL获得一个自增ID, 然后对ID取模, 算出一个服务器ID</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 参考Twitter的雪花算法, 算出一个long型ID</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 该算法保证在30年内, 6万台机器, 单机每秒可以产出128, 000个不重复ID</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * CREATE TABLE `account_server_id` (</span></span><br><span class=\"line\"><span class=\"comment\"> * `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class=\"line\"><span class=\"comment\"> * `stub` char(1) DEFAULT NULL,</span></span><br><span class=\"line\"><span class=\"comment\"> * PRIMARY KEY (`id`),</span></span><br><span class=\"line\"><span class=\"comment\"> * UNIQUE KEY `stub` (`stub`)</span></span><br><span class=\"line\"><span class=\"comment\"> * ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * |1, 000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0 |000, 0000, 0000, 0000, 0 |000, 0000           |</span></span><br><span class=\"line\"><span class=\"comment\"> * | |                   时间戳(40位)                                |   服务器ID(16位)         | 单个时间戳内的Id(7位) |</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IDGeneratorService</span> <span class=\"keyword\">implements</span> <span class=\"title\">CommandLineRunner</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOG = LoggerFactory.getLogger(IDGeneratorService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时间戳从哪一年开始计时</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> START_YEAR = <span class=\"number\">2018</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时间取40位, 保证ID34年内不会重复</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> timeBitsSize = <span class=\"number\">40</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> serverIdBitsSize = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> countBitsSize = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> maxIdPerMill;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时间开始时间戳, 相当于System.currentTimeMillis()的1970年</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> startDateTime;</span><br><span class=\"line\">    <span class=\"comment\">// 服务器ID表示位, 在集群中表示一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> serverIdBits;</span><br><span class=\"line\">    <span class=\"comment\">// 单机中, 某个时刻生长得id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> currentID;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> maxTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastGenerateTime = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AccountServerIdMapper accountServerIdMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 计算出开始生成ID的起始时间戳</span></span><br><span class=\"line\">        LocalDateTime start = LocalDateTime.of(START_YEAR, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        startDateTime = start.toInstant(ZoneOffset.of(<span class=\"string\">\"+8\"</span>)).toEpochMilli();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. 算出支持最大年限的时间</span></span><br><span class=\"line\">        maxTime = ((Double) Math.pow(<span class=\"number\">2</span>, timeBitsSize)).longValue();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 算出每毫秒能产出多少ID</span></span><br><span class=\"line\">        maxIdPerMill = ((Double) Math.pow(<span class=\"number\">2</span>, countBitsSize)).longValue();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4. 根据Mysql自增ID取模, 算出每个服务器ID, 在生产环境中, 应该保证服务器数量是该值的一半, 如此一来就可以避免, 服务器集群整体</span></span><br><span class=\"line\"><span class=\"comment\">         * 重启时, 不会拿到与重启之前的服务器相同的Id</span></span><br><span class=\"line\"><span class=\"comment\">         * 这个值的计算是为了适应这种场景, 在服务器灰度上线的时候, 有可能是原来的服务器还没有关闭, 但是新的服务器已经起来了, 此时会有俩套</span></span><br><span class=\"line\"><span class=\"comment\">         * 服务器同时在处理业务逻辑, 那么它们就有可能拿到一样的服务器ID, 从而导致产生一样的ID号</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> serverSize = ((Double) Math.pow(<span class=\"number\">2</span>, serverIdBitsSize)).longValue();</span><br><span class=\"line\"></span><br><span class=\"line\">        AccountServerId accountServerId = <span class=\"keyword\">new</span> AccountServerId();</span><br><span class=\"line\">        accountServerIdMapper.nextId(accountServerId);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> serverId = (<span class=\"keyword\">int</span>) (accountServerId.getId() % serverSize);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 5. 算出每个服务器ID在long类型中的数据位置, 然后缓存起来</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        serverIdBits = (serverId &lt;&lt; (countBitsSize));</span><br><span class=\"line\"></span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"[ID生成器] 开始时间:&#123;&#125;, 时间戳:&#123;&#125; \"</span>, <span class=\"keyword\">new</span> Date(startDateTime), startDateTime);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"[ID生成器] 结束时间:&#123;&#125;, 时间戳:&#123;&#125; \"</span>, <span class=\"keyword\">new</span> Date(startDateTime + maxTime), maxTime);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"[ID生成器] 每毫秒生成最大ID数:&#123;&#125; \"</span>, maxIdPerMill);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"[ID生成器] 当前serverId: &#123;&#125;, serverIdSize:&#123;&#125;\"</span>, serverId, serverSize);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"[ID生成器] serverIdBits: &#123;&#125;\"</span>, Long.toBinaryString(serverIdBits));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成一个64位的GUID</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 在next()方法中, 没有使用任何的对象, 如此一来就可以减轻GC的压力.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> curTime = System.currentTimeMillis() - startDateTime;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curTime &gt;= maxTime) &#123;</span><br><span class=\"line\">\t            LOG.error(<span class=\"string\">\"[ID生成器] 超过负载, &#123;&#125;, &#123;&#125;！返回 -1\"</span>, curTime, maxTime);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lastGenerateTime != curTime) &#123;</span><br><span class=\"line\">                currentID = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (currentID &gt;= maxIdPerMill) &#123;</span><br><span class=\"line\">\t                LOG.error(<span class=\"string\">\"[ID生成器] 同一毫秒[\"</span> + curTime + <span class=\"string\">\"]内生成\"</span> + currentID + <span class=\"string\">\"个ID！返回 -1\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                ++currentID;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            lastGenerateTime = curTime;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> gid = (curTime &lt;&lt; countBitsSize + serverIdBitsSize) | serverIdBits;</span><br><span class=\"line\">            gid |= currentID;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> gid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">nextStrId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.valueOf(next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">tryNextId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">long</span> id = next();</span><br><span class=\"line\">            <span class=\"keyword\">long</span> diff = System.currentTimeMillis() - start;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff &gt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                String tid = Thread.currentThread().getName();</span><br><span class=\"line\">                LOG.warn(<span class=\"string\">\"[ID生成器] 线程&#123;&#125; 生成ID: &#123;&#125; 大于3毫秒: &#123;&#125;\"</span>, tid, id, diff);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (id == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\t\tLOG.error(\"[ID生成器] 生成ID为-1, 可能超过每毫秒内生成最大数量, 等待1毫秒\");</span></span><br><span class=\"line\">                    TimeUnit.MILLISECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">tryNextStrId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.valueOf(tryNextId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>mybatis</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AccountServerIdMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span>(<span class=\"string\">\"REPLACE INTO server_id (stub) VALUES ('a');\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@SelectKey</span>(statement = <span class=\"string\">\"SELECT LAST_INSERT_ID()\"</span>, keyProperty = <span class=\"string\">\"id\"</span>, before = <span class=\"keyword\">false</span>, resultType = Long<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">Long</span> <span class=\"title\">nextId</span>(<span class=\"title\">AccountServerId</span> <span class=\"title\">accountServerId</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>SQL</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`server_id`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">unsigned</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`stub`</span> <span class=\"built_in\">char</span>(<span class=\"number\">1</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`create_time`</span> datetime <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'创建时间'</span>,</span><br><span class=\"line\">  <span class=\"string\">`update_time`</span> datetime <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">ON</span> <span class=\"keyword\">UPDATE</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'更新时间'</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> <span class=\"string\">`stub`</span> (<span class=\"string\">`stub`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">1</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(JMockit<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">public</span> <span class=\"title\">class</span> <span class=\"title\">IDGeneratorUtilTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(IDGeneratorUtilTest<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_TIMES = <span class=\"number\">2000000</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PRINT_TIMES = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Tested</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> IDGeneratorService idGeneratorUtil;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Injectable</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> AccountServerIdMapper accountServerIdMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 21026 [main] DEBUG c.f.l.service.IDGeneratorUtilTest - 20506 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t * 单线程的情况下, 在MacBook Pro上是每毫秒钟生成 97 个id</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOneServerIdGenerate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Expectations() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\taccountServerIdMapper.nextId((AccountServerId) any);</span><br><span class=\"line\">\t\t\t\tresult = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tidGeneratorUtil.init();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSet&lt;Long&gt; ids = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX_TIMES; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">long</span> id = idGeneratorUtil.tryNextId();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ids.contains(id)) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(id);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tids.add(id);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlogger.debug((System.currentTimeMillis() - start) + <span class=\"string\">\" 毫秒内生成 \"</span> + ids.size() + <span class=\"string\">\" 个ID\"</span>);</span><br><span class=\"line\">\t\tAssert.assertEquals(ids.size(), MAX_TIMES);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObject[] idArray = ids.toArray();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; PRINT_TIMES; i++) &#123;</span><br><span class=\"line\">\t\t\tlogger.debug(idArray[i] + <span class=\"string\">\" : \"</span> + Long.toBinaryString((Long) idArray[i]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 207703 [Thread-7] DEBUG c.f.l.service.IDGeneratorUtilTest - 207136 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 208031 [Thread-3] DEBUG c.f.l.service.IDGeneratorUtilTest - 207465 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 208626 [Thread-10] DEBUG c.f.l.service.IDGeneratorUtilTest - 208059 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 208630 [Thread-9] DEBUG c.f.l.service.IDGeneratorUtilTest - 208063 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209153 [Thread-6] DEBUG c.f.l.service.IDGeneratorUtilTest - 208586 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209170 [Thread-5] DEBUG c.f.l.service.IDGeneratorUtilTest - 208603 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209373 [Thread-2] DEBUG c.f.l.service.IDGeneratorUtilTest - 208807 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209412 [Thread-1] DEBUG c.f.l.service.IDGeneratorUtilTest - 208846 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209508 [Thread-4] DEBUG c.f.l.service.IDGeneratorUtilTest - 208941 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209536 [Thread-8] DEBUG c.f.l.service.IDGeneratorUtilTest - 208969 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t * 多线程的情况下, 在MacBook Pro上是每毫秒钟生成 9 个id, 可见由于锁的竞争, 产生的影响还是非常大的</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testMutilServerIdGenerate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Expectations() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\taccountServerIdMapper.nextId((AccountServerId) any);</span><br><span class=\"line\">\t\t\t\tresult = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tidGeneratorUtil.init();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tRunnable runnable = () -&gt; &#123;</span><br><span class=\"line\">\t\t\tSet&lt;Long&gt; ids = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX_TIMES; i++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">long</span> id = idGeneratorUtil.tryNextId();</span><br><span class=\"line\">\t\t\t\tids.add(id);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tlogger.debug((System.currentTimeMillis() - start) + <span class=\"string\">\" 毫秒内生成 \"</span> + ids.size() + <span class=\"string\">\" 个ID\"</span>);</span><br><span class=\"line\">\t\t\tAssert.assertEquals(ids.size(), MAX_TIMES);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tList&lt;Thread&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> cpus = Runtime.getRuntime().availableProcessors() + <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tlogger.debug(<span class=\"string\">\"CPU : \"</span> + cpus);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cpus; i++) &#123;</span><br><span class=\"line\">\t\t\tThread thread = <span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">\t\t\tlist.add(thread);</span><br><span class=\"line\">\t\t\tthread.start();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Thread thread : list) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tthread.join();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A)\"></a>A)</h1><p>网络上现在有很多的分布式ID生成算法, 各大厂商也开源了自己的分布式id生成算法. 前段时间项目里有个生成唯一id的需求, 思考了一下, 将flick的id生成方案和Twitter的id生成算法结合到一起, 写了个小算法, 也算是站在巨人的肩膀上做了点小东西, lol</p>\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B)\"></a>B)</h1><p>原理大致是这样的, 利用mysql insert来计算出集群中某个节点处于集群中的位置, 算出serverId, 然后利用雪花算法在该id上生成分布式id.</p>\n<p>目前的实现是采用long来进行存储的, 因此只能在生成时间维度, 节点数量, 和每毫秒内生成的数量上进行调节, 如果你们可以存储字符串的话, 那么可以拓展一下该算法, 加大时间和空间的容量.</p>","more":"<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C)\"></a>C)</h1><p>算法实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ID 生成器</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 整个ID算法很简单,</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 参考Flickr ID生成算法, 使用MYSQL获得一个自增ID, 然后对ID取模, 算出一个服务器ID</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 参考Twitter的雪花算法, 算出一个long型ID</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 该算法保证在30年内, 6万台机器, 单机每秒可以产出128, 000个不重复ID</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * CREATE TABLE `account_server_id` (</span></span><br><span class=\"line\"><span class=\"comment\"> * `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class=\"line\"><span class=\"comment\"> * `stub` char(1) DEFAULT NULL,</span></span><br><span class=\"line\"><span class=\"comment\"> * PRIMARY KEY (`id`),</span></span><br><span class=\"line\"><span class=\"comment\"> * UNIQUE KEY `stub` (`stub`)</span></span><br><span class=\"line\"><span class=\"comment\"> * ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * |1, 000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0 |000, 0000, 0000, 0000, 0 |000, 0000           |</span></span><br><span class=\"line\"><span class=\"comment\"> * | |                   时间戳(40位)                                |   服务器ID(16位)         | 单个时间戳内的Id(7位) |</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IDGeneratorService</span> <span class=\"keyword\">implements</span> <span class=\"title\">CommandLineRunner</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOG = LoggerFactory.getLogger(IDGeneratorService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时间戳从哪一年开始计时</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> START_YEAR = <span class=\"number\">2018</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时间取40位, 保证ID34年内不会重复</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> timeBitsSize = <span class=\"number\">40</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> serverIdBitsSize = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> countBitsSize = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> maxIdPerMill;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时间开始时间戳, 相当于System.currentTimeMillis()的1970年</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> startDateTime;</span><br><span class=\"line\">    <span class=\"comment\">// 服务器ID表示位, 在集群中表示一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> serverIdBits;</span><br><span class=\"line\">    <span class=\"comment\">// 单机中, 某个时刻生长得id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> currentID;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> maxTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastGenerateTime = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AccountServerIdMapper accountServerIdMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 计算出开始生成ID的起始时间戳</span></span><br><span class=\"line\">        LocalDateTime start = LocalDateTime.of(START_YEAR, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        startDateTime = start.toInstant(ZoneOffset.of(<span class=\"string\">\"+8\"</span>)).toEpochMilli();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. 算出支持最大年限的时间</span></span><br><span class=\"line\">        maxTime = ((Double) Math.pow(<span class=\"number\">2</span>, timeBitsSize)).longValue();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 算出每毫秒能产出多少ID</span></span><br><span class=\"line\">        maxIdPerMill = ((Double) Math.pow(<span class=\"number\">2</span>, countBitsSize)).longValue();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4. 根据Mysql自增ID取模, 算出每个服务器ID, 在生产环境中, 应该保证服务器数量是该值的一半, 如此一来就可以避免, 服务器集群整体</span></span><br><span class=\"line\"><span class=\"comment\">         * 重启时, 不会拿到与重启之前的服务器相同的Id</span></span><br><span class=\"line\"><span class=\"comment\">         * 这个值的计算是为了适应这种场景, 在服务器灰度上线的时候, 有可能是原来的服务器还没有关闭, 但是新的服务器已经起来了, 此时会有俩套</span></span><br><span class=\"line\"><span class=\"comment\">         * 服务器同时在处理业务逻辑, 那么它们就有可能拿到一样的服务器ID, 从而导致产生一样的ID号</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> serverSize = ((Double) Math.pow(<span class=\"number\">2</span>, serverIdBitsSize)).longValue();</span><br><span class=\"line\"></span><br><span class=\"line\">        AccountServerId accountServerId = <span class=\"keyword\">new</span> AccountServerId();</span><br><span class=\"line\">        accountServerIdMapper.nextId(accountServerId);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> serverId = (<span class=\"keyword\">int</span>) (accountServerId.getId() % serverSize);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 5. 算出每个服务器ID在long类型中的数据位置, 然后缓存起来</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        serverIdBits = (serverId &lt;&lt; (countBitsSize));</span><br><span class=\"line\"></span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"[ID生成器] 开始时间:&#123;&#125;, 时间戳:&#123;&#125; \"</span>, <span class=\"keyword\">new</span> Date(startDateTime), startDateTime);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"[ID生成器] 结束时间:&#123;&#125;, 时间戳:&#123;&#125; \"</span>, <span class=\"keyword\">new</span> Date(startDateTime + maxTime), maxTime);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"[ID生成器] 每毫秒生成最大ID数:&#123;&#125; \"</span>, maxIdPerMill);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"[ID生成器] 当前serverId: &#123;&#125;, serverIdSize:&#123;&#125;\"</span>, serverId, serverSize);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"[ID生成器] serverIdBits: &#123;&#125;\"</span>, Long.toBinaryString(serverIdBits));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成一个64位的GUID</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 在next()方法中, 没有使用任何的对象, 如此一来就可以减轻GC的压力.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> curTime = System.currentTimeMillis() - startDateTime;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curTime &gt;= maxTime) &#123;</span><br><span class=\"line\">\t            LOG.error(<span class=\"string\">\"[ID生成器] 超过负载, &#123;&#125;, &#123;&#125;！返回 -1\"</span>, curTime, maxTime);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lastGenerateTime != curTime) &#123;</span><br><span class=\"line\">                currentID = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (currentID &gt;= maxIdPerMill) &#123;</span><br><span class=\"line\">\t                LOG.error(<span class=\"string\">\"[ID生成器] 同一毫秒[\"</span> + curTime + <span class=\"string\">\"]内生成\"</span> + currentID + <span class=\"string\">\"个ID！返回 -1\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                ++currentID;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            lastGenerateTime = curTime;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> gid = (curTime &lt;&lt; countBitsSize + serverIdBitsSize) | serverIdBits;</span><br><span class=\"line\">            gid |= currentID;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> gid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">nextStrId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.valueOf(next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">tryNextId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">long</span> id = next();</span><br><span class=\"line\">            <span class=\"keyword\">long</span> diff = System.currentTimeMillis() - start;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff &gt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                String tid = Thread.currentThread().getName();</span><br><span class=\"line\">                LOG.warn(<span class=\"string\">\"[ID生成器] 线程&#123;&#125; 生成ID: &#123;&#125; 大于3毫秒: &#123;&#125;\"</span>, tid, id, diff);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (id == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\t\tLOG.error(\"[ID生成器] 生成ID为-1, 可能超过每毫秒内生成最大数量, 等待1毫秒\");</span></span><br><span class=\"line\">                    TimeUnit.MILLISECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">tryNextStrId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.valueOf(tryNextId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>mybatis</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AccountServerIdMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span>(<span class=\"string\">\"REPLACE INTO server_id (stub) VALUES ('a');\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@SelectKey</span>(statement = <span class=\"string\">\"SELECT LAST_INSERT_ID()\"</span>, keyProperty = <span class=\"string\">\"id\"</span>, before = <span class=\"keyword\">false</span>, resultType = Long<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">Long</span> <span class=\"title\">nextId</span>(<span class=\"title\">AccountServerId</span> <span class=\"title\">accountServerId</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>SQL</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`server_id`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">unsigned</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`stub`</span> <span class=\"built_in\">char</span>(<span class=\"number\">1</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`create_time`</span> datetime <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'创建时间'</span>,</span><br><span class=\"line\">  <span class=\"string\">`update_time`</span> datetime <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">ON</span> <span class=\"keyword\">UPDATE</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'更新时间'</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> <span class=\"string\">`stub`</span> (<span class=\"string\">`stub`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">1</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(JMockit<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">public</span> <span class=\"title\">class</span> <span class=\"title\">IDGeneratorUtilTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(IDGeneratorUtilTest<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_TIMES = <span class=\"number\">2000000</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PRINT_TIMES = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Tested</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> IDGeneratorService idGeneratorUtil;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Injectable</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> AccountServerIdMapper accountServerIdMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 21026 [main] DEBUG c.f.l.service.IDGeneratorUtilTest - 20506 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t * 单线程的情况下, 在MacBook Pro上是每毫秒钟生成 97 个id</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOneServerIdGenerate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Expectations() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\taccountServerIdMapper.nextId((AccountServerId) any);</span><br><span class=\"line\">\t\t\t\tresult = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tidGeneratorUtil.init();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSet&lt;Long&gt; ids = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX_TIMES; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">long</span> id = idGeneratorUtil.tryNextId();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ids.contains(id)) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(id);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tids.add(id);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlogger.debug((System.currentTimeMillis() - start) + <span class=\"string\">\" 毫秒内生成 \"</span> + ids.size() + <span class=\"string\">\" 个ID\"</span>);</span><br><span class=\"line\">\t\tAssert.assertEquals(ids.size(), MAX_TIMES);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObject[] idArray = ids.toArray();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; PRINT_TIMES; i++) &#123;</span><br><span class=\"line\">\t\t\tlogger.debug(idArray[i] + <span class=\"string\">\" : \"</span> + Long.toBinaryString((Long) idArray[i]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 207703 [Thread-7] DEBUG c.f.l.service.IDGeneratorUtilTest - 207136 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 208031 [Thread-3] DEBUG c.f.l.service.IDGeneratorUtilTest - 207465 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 208626 [Thread-10] DEBUG c.f.l.service.IDGeneratorUtilTest - 208059 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 208630 [Thread-9] DEBUG c.f.l.service.IDGeneratorUtilTest - 208063 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209153 [Thread-6] DEBUG c.f.l.service.IDGeneratorUtilTest - 208586 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209170 [Thread-5] DEBUG c.f.l.service.IDGeneratorUtilTest - 208603 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209373 [Thread-2] DEBUG c.f.l.service.IDGeneratorUtilTest - 208807 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209412 [Thread-1] DEBUG c.f.l.service.IDGeneratorUtilTest - 208846 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209508 [Thread-4] DEBUG c.f.l.service.IDGeneratorUtilTest - 208941 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * 209536 [Thread-8] DEBUG c.f.l.service.IDGeneratorUtilTest - 208969 毫秒内生成 2000000 个ID</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t * 多线程的情况下, 在MacBook Pro上是每毫秒钟生成 9 个id, 可见由于锁的竞争, 产生的影响还是非常大的</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testMutilServerIdGenerate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Expectations() &#123;</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\taccountServerIdMapper.nextId((AccountServerId) any);</span><br><span class=\"line\">\t\t\t\tresult = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tidGeneratorUtil.init();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tRunnable runnable = () -&gt; &#123;</span><br><span class=\"line\">\t\t\tSet&lt;Long&gt; ids = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX_TIMES; i++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">long</span> id = idGeneratorUtil.tryNextId();</span><br><span class=\"line\">\t\t\t\tids.add(id);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tlogger.debug((System.currentTimeMillis() - start) + <span class=\"string\">\" 毫秒内生成 \"</span> + ids.size() + <span class=\"string\">\" 个ID\"</span>);</span><br><span class=\"line\">\t\t\tAssert.assertEquals(ids.size(), MAX_TIMES);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tList&lt;Thread&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> cpus = Runtime.getRuntime().availableProcessors() + <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tlogger.debug(<span class=\"string\">\"CPU : \"</span> + cpus);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cpus; i++) &#123;</span><br><span class=\"line\">\t\t\tThread thread = <span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">\t\t\tlist.add(thread);</span><br><span class=\"line\">\t\t\tthread.start();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Thread thread : list) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tthread.join();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"PEG.js 文档 [译]","date":"2018-12-15T02:21:00.000Z","_content":"[PEG.js](https://pegjs.org/documentation) 是JavaScript里一个简单的parser生成器, 它能够非常快的生成parser, 而且如果在生成过程中遇到了问题, 也会给出非常明确的错误报告. 你可以很轻松地用它处理复杂的数据结构或者计算机语言, 也可以构建出transformers, interpreters, compilers 等其他工具.\n\n## 特性\nPEG.js具有如下特性\n* 简单而富有表现力的语法\n* 集成了词法和语法分析.\n* 生成的解析器具有出色的错误报告功能\n* 基于parsing expression grammar, 生成的parser 比传统的 LL(k) 和 LR(k) parser更加强大.\n* 适用于浏览器, 命令行或者JavaScript API 等多种环境.\n\n## 安装\n\n### Node.js\n在命令行中使用`pegjs`命令编译, 需要使用全局模式安装`PEG.js`:\n```\n$ npm install -g pegjs\n```\n如果要使用pegjs提供的 JavaScript API, 则需要在当前工作目录安装 `PEG.js`:\n```\n$ npm install pegjs\n```\n如果既要使用`pegjs`命令又要使用JavaScript API, 那么你需要将上面俩种方式都安装一遍.\n\n### Browser\n在浏览器中使用, 可以直接下载库文件[PEG.js](https://pegjs.org/#download)或者通过`Bower`安装`PEG.js`:\n```\n$ bower install pegjs\n```\n\n## 生成 Parser\n`PEG.js`将解析表达式文法解析后, 生成parser. 解析表达式文法描述描述了 将何种输入进行解析然后输出何种输出.(通过执行输入字符的匹配部分的语义操作). 通过一个简单api就可以可以生成一个parser JS对象.\n\n### 命令行生成\n想要将grammar文件生成parser, 直接使用`pegjs`进行编译即可:\n```\n$ pegjs arithmetics.pegjs\n```\n上面的命令会将生成的parser的源码输出到与grammar文件同名的js结尾的文件中. 当然也可以输出到指定文件中:\n\n```\n$ pegjs -o arithmetics-parser.js arithmetics.pegjs\n```\n\n但是如果你将输入输出文件都忽略了, 那么系统将会采用标准输入输出.\n在默认设置下, 生成的parser代码是以Node.js module format 进行组织代码的, 但也可以通过指定`--format`选项选择其他方式.\n\n> 下面的选项介绍中也有对该选项的介绍, 详情请参考[[译]神马是AMD, CommonJS, UMD?](https://75team.com/post/%E8%AF%91%E7%A5%9E%E9%A9%AC%E6%98%AFamd-commonjs-umd.html)\n\n你可以通过如下几个命令来修改生成的parser的默认行为.\n\n* `--allowed-start-rules`: 指定parser开始从哪个rule开始解析. (默认是文法中的第一个rule)\n* `--cache`: 开启parser的缓存功能. parser会将parse出来的结果缓存起来, 避免极端情况下解析时间成指数级增加, 但坏处是parser可能会变慢.\n* `--dependency`: 让parser依赖一个指定的依赖.(该参数可以多次使用)\n* `--export-var`: \n* `--extra-options`: 传递给`peg.generate`的额外参数(JSON 形式).\n* `--extra-options-file`: 传递给`peg.generate`的额外参数文件(JSON 形式).\n* `--format`: 生成的parser格式, 可选值有`amd`, `commonjs`, `globals`, `umd`(默认是`commonjs`)\n* `--optimize`: 为生成的parser在parsing时的优化方式, 可以选择解析速度(`speed`)或者parse结果代码大小(`size`). (默认是`speed`)\n* `--plugin`: 为PEG.js配置插件(可以配置多个, 即多次配置)\n* `--trace`: 开启parser的trace功能.\n\n### API生成\n在node.js中, 直接`require(\"pegjs\")` 就可以使用peg.js的parser生成器了.\n```javascript\nvar peg = require(\"pegjs\");\n```\n在浏览器中, 需要在`<script>`标签引入`PEG.js`库. 如果 PEG.js 检测到一个 AMD loader, 它会把自己定义成一个 module, 否则我们只能通过`peg`这个全局对象使用pegjs的api了.\n生成一个parser非常简单, 把解析器文法参数传递进`peg.generate`方法就可以了:\n```javascript\nvar parser = peg.generate(\"start = ('a' / 'b')+\");\n```\n\n根据参数的不同, 这个方法可能会返回一个新生成的parser对象或者是一个包含parser源码的字符串. 如果文法参数不合法, 则会抛出一个异常(异常中会包含这个错误的详细信息). \n\n可以通过向`peg.generate`方法传递第二个参数(该参数是一个对象)改变生成的parser的默认行为. 支持的参数如下:\n* `allowedStartRules`: 指定parser开始的rule. (默认是文法中第一个rule.)\n* `cache`: 如果设置为`true`, parser会将parse的结果缓存起来, 可以避免在极端情况下过长的解析时间, 但同时它带来的副作用是会使得parser变慢(默认false).\n* `dependencies`: 设置parser的依赖, 其值是一个对象, 其key为访问依赖的变量, 而value为需要加载的依赖module id.只有当`format`参数被设置为`\"amd\"`, `\"commonjs\"`, `\"umd\"` 该参数才生效. (默认为`{}`)\n* `exportVar`: Name of a global variable into which the parser object is assigned to when no module loader is detected; valid only when format is set to \"globals\" or \"umd\" (default: null).\n* `format`: 生成的parser格式, 可选值为(`\"amd\"`, `\"bare\"`, `\"commonjs\"`, `\"globals\"`, or `\"umd\"`). 只有`output`设置为`source`, 该参数才生效\n* `optimize`: 为生成的parser选择一个优化方案, 可选值为`\"speed\"`或者`\"size\"`. (默认`\"speed\"`)\n* `output`: 设置`generate()`方法返回格式. 如果值为`\"parser\"`, 则返回生成的parser对象. 如果设置为`\"source\"`, 则返回parser source字符串\n* `plugins`: 要使用的插件\n* `trace`: 追踪parser的执行过程(默认是false).\n\n## 使用 Parser\n使用生成的parser也非常简单, 只需要调用parser对象的`parse`方法, 然后将一个字符串参数传递进该方法就可以了. 然后该方法会返回一个parse结果(已经在定义parser的文法中描述了返回何种类型的值), 或者如果字符串不合法的话抛出一个异常. 异常会输出详细的错误信息.\n\n```javascript\nparser.parse(\"abba\"); // returns [\"a\", \"b\", \"b\", \"a\"]\n\nparser.parse(\"abcd\"); // throws an exception \n```\n\n同样的, `parse`方法也支持选项参数. 支持的参数如下:\n* startRule: Name of the rule to start parsing from. 开始从哪个rule执行.\n* tracer: Tracer to use. 开启tracer.\n\nParsers 也可以自定义参数, 以支持定制化的需求.\n\n## 语法和语义\npeg.js的语法和JavaScript非常像, 但是有俩点不同, pegjs不是line-oriented, 而且peg.js会忽略tokens之间的空白符. 同样地可以在peg.js中使用`//...`和`/* ... */`进行注释.\n下面是个peg.js文法示例, 该示例生成的parser会识别出算数表达式 `2*(3+4)`, 然后将该值计算出来.\n\n```javascript\nstart\n  = additive\n\nadditive\n  = left:multiplicative \"+\" right:additive { return left + right; }\n  / multiplicative\n\nmultiplicative\n  = left:primary \"*\" right:multiplicative { return left * right; }\n  / primary\n\nprimary\n  = integer\n  / \"(\" additive:additive \")\" { return additive; }\n\ninteger \"integer\"\n  = digits:[0-9]+ { return parseInt(digits.join(\"\"), 10); }\n```\n总体来说, 文法是由rule组成的(例如上面的例子中有5个rule). 每个rule都有一个名字(例如上例中`integer`) 和 一个解析表达式(例如上例中:`digits:[0-9]+ { return parseInt(digits.join(\"\"), 10); }`). 表达式部分首先是一个匹配输入字符串的匹配规则, 然后可能后面还会有一个匹配成功之后要执行的JavaScript代码. rule也可以设置一个更加易于理解的别名, 例如上例中的integer就有一个别名, 该别名主要用于发生解析异常时, 输出日志便于解决问题. 解析动作从第一个rule开始, 我们通常以`start`命名这个rule.\n\nrule名称必须符合JavaScript的标识符规则. rule名称后跟一个`=`符号, 然后`=`后面是一个解析表达式. 如果rule名称要跟一个别名的话, 该别名必须在rule名称与`=`之间. rule之间需要由空白行进行分割, rule后也可以跟一个分号`;`\n\n第一个规则之前可以设置一个初始化器, 初始化器由花括号(\"{\"和\"}\")和花括号内的JavaScript代码组成. 初始化器会在parser开始解析之前被执行. 初始器里定义的变量和方法可以被后续的rule访问到. 初始器可以通过访问`options`参数访问到传递给parser的参数. 初始化器必须由大括号括起来, 缺一不可. 下面我们看一个简单的使用了初始化代码的示例:\n\n```javascript\n{\n  function makeInteger(o) {\n    return parseInt(o.join(\"\"), 10);\n  }\n}\n\nstart\n  = additive\n\nadditive\n  = left:multiplicative \"+\" right:additive { return left + right; }\n  / multiplicative\n\nmultiplicative\n  = left:primary \"*\" right:multiplicative { return left * right; }\n  / primary\n\nprimary\n  = integer\n  / \"(\" additive:additive \")\" { return additive; }\n\ninteger \"integer\"\n  = digits:[0-9]+ { return makeInteger(digits); }\n```\npeg.js会将输入的字符串与rule中定义的解析表文法进行匹配. 但是存在着很多不同类型的表达式, 例如匹配字符或者字符类型, 或者匹配可选部分, 或者匹配重复情况等等. 表达式可能还包含其他rule的引用.\n\n当parser将输入字符串与表达式成功的时候, parser会生成一个JavaScript对象的匹配结果. 例如\n* 表达式匹配到了一个字符串字面量的话, 它会返回一个包含该字符串的JavaScript字符串对象.\n* 当表达式匹配到重复的子表达式的时候, 会将所有匹配结果放到一个JavaScript数组对象里返回.\n\n如果rule A在表达式B被引用了, 那么这个rule A的匹配结果也会传递表达式B, 接着会层层传递, 一直传递到start rule里. 当parser全部解析完成成功之后, 会直接将start rule的匹配结果返回出去.\n\n解析表达式中比较特殊的是parser action,一段包含在大括号内的JavaScript代码，这段代码可以处理表达式中引用的其他rule的匹配结果，然后自己再返回一个JavaScript对象作为当前表达式的处理结果。这个对象就是当前表达式的匹配结果，换句话说，parser action就是一个匹配结果转换器。\n\n在我们的运算示例中，有许许多多的parser action. 看一下表达式中的这个action `digits:[0-9]+ { return parseInt(digits.join(\"\"), 10); }`. 它拿到了`[0-9]+`的匹配结果`digits`(`digits` 是一个包含数字的字符串数组)。它将这些数字字符转换成一个数字，然后转换成一个js数字对象。\n\n### 解析表达式类型\n解析表达式可以分为很多种类, 而且有一些还包含子表达式, 包含子表达式的就形成了一种递归结构.\n\n##### `\"literal\"` `'literal'`\n严格匹配字面量字符串, 然后直接返回该字符串字面量. 在pegjs里字符串语法和JavaScript里相同. 在常量最后加一个`i`表示不区分大小写.\n\n> 输入的字符串必须与该字符串一模一样(可以加`i`忽略大小写)\n\n##### `.`\n严格匹配任意单个字符, 然后将它作为一个字符串返回.\n\n##### `[characters]`\n单个字符匹配, 将匹配成功的单个字符作为字符串返回. The characters in the list can be escaped in exactly the same way as in JavaScript string. 匹配模式中的字符列表也可以指定一个范围(例如`[a-z]`表示要匹配全部小写字符). 如果匹配规则中有`^`表示匹配规则相反. (例如`[^a-z]` 表示匹配除了小写字符之外的全部字符). 如果匹配规则后面跟有`i`的话, 表示忽略大小写.\n\n> `[characters]` 通常会和`*`, `+` 组合到一起使用, 匹配字符串. 与`'literal'` 不同的是, 只要单个字符符合`[characters]` 中任意一个字符即可.\n\n##### `rule`\n在表达式中引用其他rule, 然后与引用的rule进行匹配, 然后返回引用rule的匹配结果.\n\n##### `( expression )`\n匹配一个子表达式, 并返回它的匹配结果.\n\n> 匹配不成功则会抛出异常\n\n##### `expression *`\n将表达式匹配0次或多次, 然后将匹配结果通过一个数组返回. 这种匹配形式会尽可能多地尝试匹配. 与正则表达式不同的是, 它们不会进行回溯.\n\n> 匹配不成功则会抛出异常\n\n##### `expression +`\n将表达式匹配1次或多次, 然后将匹配结果通过一个数组返回. 这种匹配形式会尽可能多地尝试匹配. 与正则表达式不同的是, 它们不会进行回溯.\n\n> 匹配不成功则会抛出异常\n\n##### `expression ?`\n尝试去匹配表达式. 如果匹配成功, 则返回匹配结果, 否则返回null. 与正则表达式不同的是, 它们不会进行回溯.\n\n> 匹配不成功则会抛出异常\n\n##### `& expression`\n尝试去匹配表达式. 如果匹配成功, 则返回`undefined`而且不会消耗输入字符串, 否则认为匹配失败.\n\n> 匹配不成功则会抛出异常\n\n##### `! expression`\n尝试去匹配表达式. 如果匹配不成功, 则返回`undefined`而且不会消耗输入字符串, 否则认为匹配失败.\n\n> 匹配不成功则会抛出异常\n\n##### `& { predicate }`\nThe predicate is a piece of JavaScript code that is executed as if it was inside a function. It gets the match results of labeled expressions in preceding expression as its arguments. It should return some JavaScript value using the return statement. If the returned value evaluates to true in boolean context, just return undefined and do not consume any input; otherwise consider the match failed.\n\nThe code inside the predicate can access all variables and functions defined in the initializer at the beginning of the grammar.\n\nThe code inside the predicate can also access location information using the location function. It returns an object like this:\n```javascript\n{\n  start: { offset: 23, line: 5, column: 6 },\n  end:   { offset: 23, line: 5, column: 6 }\n}\n```\nThe start and end properties both refer to the current parse position. The offset property contains an offset as a zero-based index and line and column properties contain a line and a column as one-based indices.\n\nThe code inside the predicate can also access options passed to the parser using the options variable.\n\nNote that curly braces in the predicate code must be balanced.\n\n##### `! { predicate }`\nThe predicate is a piece of JavaScript code that is executed as if it was inside a function. It gets the match results of labeled expressions in preceding expression as its arguments. It should return some JavaScript value using the return statement. If the returned value evaluates to false in boolean context, just return undefined and do not consume any input; otherwise consider the match failed.\n\nThe code inside the predicate can access all variables and functions defined in the initializer at the beginning of the grammar.\n\nThe code inside the predicate can also access location information using the location function. It returns an object like this:\n\n```javascript\n{\n  start: { offset: 23, line: 5, column: 6 },\n  end:   { offset: 23, line: 5, column: 6 }\n}\n```\n\nThe start and end properties both refer to the current parse position. The offset property contains an offset as a zero-based index and line and column properties contain a line and a column as one-based indices.\n\nThe code inside the predicate can also access options passed to the parser using the options variable.\n\nNote that curly braces in the predicate code must be balanced.\n\n##### `$ expression`\n尝试匹配该表达式. 如果匹配成功, 不会返回匹配结果, 而是返回匹配成功的字符串.\n\n> 匹配不成功则会抛出异常\n\n##### `label : expression`\n匹配表达式, 然后将匹配结果存储在`label`里. `label`必须是一个JavaScript标识符. \n\n##### `expression1 expression2 ... expressionn`\n匹配一个表达式列表, 将全部的匹配结果放到一个数组中返回.\n\n##### `expression { action }`\n如果匹配表达式成功, 则运行action, 否则认为匹配失败.\n\n> 匹配失败返回异常.\n\n`action`是一段JavaScript代码, 可以把它当做一个方法来运行. labeled表达式的匹配结果会被当做action的参数, 传递给action. action应该通过`return`返回一个JavaScript结果, 该结果会被当做前面表达式的匹配结果.\n\n在action代码块中, 遇到非预期情况, 想要中断parse可以调用`expected`方法, 该方法会抛出一个异常. `expected`方法接受俩个参数, 第一个参数是`description`, 表明当前位置期望输入以及可选的`location`信息(默认值是what location would return). `description`会被当做exception中的message的一部分.\n\n在action代码中也可以调用`error`方法, 该方法也会抛出一个异常. `error`方法接受俩个参数, 第一个参数是error message, 第二个参数是可选的location信息(默认值是 what location would return). message会在抛出异常中使用. \naction中的代码块可以访问初始器中定义的方法和变量. action代码块的左右大括号必须都在.\naction 代码块中可以通过`text`方法访问匹配成功的字符.\naction代码块中还可以通过访问`location`方法得到location信息, 该方法会返回下面这种对象.\n\n```javascript\n{\n  start: { offset: 23, line: 5, column: 6 },\n  end:   { offset: 25, line: 5, column: 8 }\n}\n```\n`start`属性指向了表达式开始位置, `end`属性指向表达式的结束位置. `offset`是一个基于0 的offset索引位置, `line`和 `column` 属性是基于1的索引位置.\n\naction 代码块中可以通过`options`变量访问传递给parser的options.\n\n##### `expression1 / expression2 / ... / expressionn`\n按照顺序从左往右一次匹配, 返回第一个匹配成功的结果. 如果都匹配不成功, 则认为匹配失败.\n> 匹配失败返回异常.\n\n## Compatibility\narser generator 和 generated parsers 在以下环境都可以正常运行.\n* Node.js 0.10.0+\n* Internet Explorer 8+\n* Edge\n* Firefox\n* Chrome\n* Safari\n* Opera","source":"_posts/pegjs-document.md","raw":"---\ntitle: PEG.js 文档 [译]\ndate: 2018-12-15 10:21:00\n---\n[PEG.js](https://pegjs.org/documentation) 是JavaScript里一个简单的parser生成器, 它能够非常快的生成parser, 而且如果在生成过程中遇到了问题, 也会给出非常明确的错误报告. 你可以很轻松地用它处理复杂的数据结构或者计算机语言, 也可以构建出transformers, interpreters, compilers 等其他工具.\n\n## 特性\nPEG.js具有如下特性\n* 简单而富有表现力的语法\n* 集成了词法和语法分析.\n* 生成的解析器具有出色的错误报告功能\n* 基于parsing expression grammar, 生成的parser 比传统的 LL(k) 和 LR(k) parser更加强大.\n* 适用于浏览器, 命令行或者JavaScript API 等多种环境.\n\n## 安装\n\n### Node.js\n在命令行中使用`pegjs`命令编译, 需要使用全局模式安装`PEG.js`:\n```\n$ npm install -g pegjs\n```\n如果要使用pegjs提供的 JavaScript API, 则需要在当前工作目录安装 `PEG.js`:\n```\n$ npm install pegjs\n```\n如果既要使用`pegjs`命令又要使用JavaScript API, 那么你需要将上面俩种方式都安装一遍.\n\n### Browser\n在浏览器中使用, 可以直接下载库文件[PEG.js](https://pegjs.org/#download)或者通过`Bower`安装`PEG.js`:\n```\n$ bower install pegjs\n```\n\n## 生成 Parser\n`PEG.js`将解析表达式文法解析后, 生成parser. 解析表达式文法描述描述了 将何种输入进行解析然后输出何种输出.(通过执行输入字符的匹配部分的语义操作). 通过一个简单api就可以可以生成一个parser JS对象.\n\n### 命令行生成\n想要将grammar文件生成parser, 直接使用`pegjs`进行编译即可:\n```\n$ pegjs arithmetics.pegjs\n```\n上面的命令会将生成的parser的源码输出到与grammar文件同名的js结尾的文件中. 当然也可以输出到指定文件中:\n\n```\n$ pegjs -o arithmetics-parser.js arithmetics.pegjs\n```\n\n但是如果你将输入输出文件都忽略了, 那么系统将会采用标准输入输出.\n在默认设置下, 生成的parser代码是以Node.js module format 进行组织代码的, 但也可以通过指定`--format`选项选择其他方式.\n\n> 下面的选项介绍中也有对该选项的介绍, 详情请参考[[译]神马是AMD, CommonJS, UMD?](https://75team.com/post/%E8%AF%91%E7%A5%9E%E9%A9%AC%E6%98%AFamd-commonjs-umd.html)\n\n你可以通过如下几个命令来修改生成的parser的默认行为.\n\n* `--allowed-start-rules`: 指定parser开始从哪个rule开始解析. (默认是文法中的第一个rule)\n* `--cache`: 开启parser的缓存功能. parser会将parse出来的结果缓存起来, 避免极端情况下解析时间成指数级增加, 但坏处是parser可能会变慢.\n* `--dependency`: 让parser依赖一个指定的依赖.(该参数可以多次使用)\n* `--export-var`: \n* `--extra-options`: 传递给`peg.generate`的额外参数(JSON 形式).\n* `--extra-options-file`: 传递给`peg.generate`的额外参数文件(JSON 形式).\n* `--format`: 生成的parser格式, 可选值有`amd`, `commonjs`, `globals`, `umd`(默认是`commonjs`)\n* `--optimize`: 为生成的parser在parsing时的优化方式, 可以选择解析速度(`speed`)或者parse结果代码大小(`size`). (默认是`speed`)\n* `--plugin`: 为PEG.js配置插件(可以配置多个, 即多次配置)\n* `--trace`: 开启parser的trace功能.\n\n### API生成\n在node.js中, 直接`require(\"pegjs\")` 就可以使用peg.js的parser生成器了.\n```javascript\nvar peg = require(\"pegjs\");\n```\n在浏览器中, 需要在`<script>`标签引入`PEG.js`库. 如果 PEG.js 检测到一个 AMD loader, 它会把自己定义成一个 module, 否则我们只能通过`peg`这个全局对象使用pegjs的api了.\n生成一个parser非常简单, 把解析器文法参数传递进`peg.generate`方法就可以了:\n```javascript\nvar parser = peg.generate(\"start = ('a' / 'b')+\");\n```\n\n根据参数的不同, 这个方法可能会返回一个新生成的parser对象或者是一个包含parser源码的字符串. 如果文法参数不合法, 则会抛出一个异常(异常中会包含这个错误的详细信息). \n\n可以通过向`peg.generate`方法传递第二个参数(该参数是一个对象)改变生成的parser的默认行为. 支持的参数如下:\n* `allowedStartRules`: 指定parser开始的rule. (默认是文法中第一个rule.)\n* `cache`: 如果设置为`true`, parser会将parse的结果缓存起来, 可以避免在极端情况下过长的解析时间, 但同时它带来的副作用是会使得parser变慢(默认false).\n* `dependencies`: 设置parser的依赖, 其值是一个对象, 其key为访问依赖的变量, 而value为需要加载的依赖module id.只有当`format`参数被设置为`\"amd\"`, `\"commonjs\"`, `\"umd\"` 该参数才生效. (默认为`{}`)\n* `exportVar`: Name of a global variable into which the parser object is assigned to when no module loader is detected; valid only when format is set to \"globals\" or \"umd\" (default: null).\n* `format`: 生成的parser格式, 可选值为(`\"amd\"`, `\"bare\"`, `\"commonjs\"`, `\"globals\"`, or `\"umd\"`). 只有`output`设置为`source`, 该参数才生效\n* `optimize`: 为生成的parser选择一个优化方案, 可选值为`\"speed\"`或者`\"size\"`. (默认`\"speed\"`)\n* `output`: 设置`generate()`方法返回格式. 如果值为`\"parser\"`, 则返回生成的parser对象. 如果设置为`\"source\"`, 则返回parser source字符串\n* `plugins`: 要使用的插件\n* `trace`: 追踪parser的执行过程(默认是false).\n\n## 使用 Parser\n使用生成的parser也非常简单, 只需要调用parser对象的`parse`方法, 然后将一个字符串参数传递进该方法就可以了. 然后该方法会返回一个parse结果(已经在定义parser的文法中描述了返回何种类型的值), 或者如果字符串不合法的话抛出一个异常. 异常会输出详细的错误信息.\n\n```javascript\nparser.parse(\"abba\"); // returns [\"a\", \"b\", \"b\", \"a\"]\n\nparser.parse(\"abcd\"); // throws an exception \n```\n\n同样的, `parse`方法也支持选项参数. 支持的参数如下:\n* startRule: Name of the rule to start parsing from. 开始从哪个rule执行.\n* tracer: Tracer to use. 开启tracer.\n\nParsers 也可以自定义参数, 以支持定制化的需求.\n\n## 语法和语义\npeg.js的语法和JavaScript非常像, 但是有俩点不同, pegjs不是line-oriented, 而且peg.js会忽略tokens之间的空白符. 同样地可以在peg.js中使用`//...`和`/* ... */`进行注释.\n下面是个peg.js文法示例, 该示例生成的parser会识别出算数表达式 `2*(3+4)`, 然后将该值计算出来.\n\n```javascript\nstart\n  = additive\n\nadditive\n  = left:multiplicative \"+\" right:additive { return left + right; }\n  / multiplicative\n\nmultiplicative\n  = left:primary \"*\" right:multiplicative { return left * right; }\n  / primary\n\nprimary\n  = integer\n  / \"(\" additive:additive \")\" { return additive; }\n\ninteger \"integer\"\n  = digits:[0-9]+ { return parseInt(digits.join(\"\"), 10); }\n```\n总体来说, 文法是由rule组成的(例如上面的例子中有5个rule). 每个rule都有一个名字(例如上例中`integer`) 和 一个解析表达式(例如上例中:`digits:[0-9]+ { return parseInt(digits.join(\"\"), 10); }`). 表达式部分首先是一个匹配输入字符串的匹配规则, 然后可能后面还会有一个匹配成功之后要执行的JavaScript代码. rule也可以设置一个更加易于理解的别名, 例如上例中的integer就有一个别名, 该别名主要用于发生解析异常时, 输出日志便于解决问题. 解析动作从第一个rule开始, 我们通常以`start`命名这个rule.\n\nrule名称必须符合JavaScript的标识符规则. rule名称后跟一个`=`符号, 然后`=`后面是一个解析表达式. 如果rule名称要跟一个别名的话, 该别名必须在rule名称与`=`之间. rule之间需要由空白行进行分割, rule后也可以跟一个分号`;`\n\n第一个规则之前可以设置一个初始化器, 初始化器由花括号(\"{\"和\"}\")和花括号内的JavaScript代码组成. 初始化器会在parser开始解析之前被执行. 初始器里定义的变量和方法可以被后续的rule访问到. 初始器可以通过访问`options`参数访问到传递给parser的参数. 初始化器必须由大括号括起来, 缺一不可. 下面我们看一个简单的使用了初始化代码的示例:\n\n```javascript\n{\n  function makeInteger(o) {\n    return parseInt(o.join(\"\"), 10);\n  }\n}\n\nstart\n  = additive\n\nadditive\n  = left:multiplicative \"+\" right:additive { return left + right; }\n  / multiplicative\n\nmultiplicative\n  = left:primary \"*\" right:multiplicative { return left * right; }\n  / primary\n\nprimary\n  = integer\n  / \"(\" additive:additive \")\" { return additive; }\n\ninteger \"integer\"\n  = digits:[0-9]+ { return makeInteger(digits); }\n```\npeg.js会将输入的字符串与rule中定义的解析表文法进行匹配. 但是存在着很多不同类型的表达式, 例如匹配字符或者字符类型, 或者匹配可选部分, 或者匹配重复情况等等. 表达式可能还包含其他rule的引用.\n\n当parser将输入字符串与表达式成功的时候, parser会生成一个JavaScript对象的匹配结果. 例如\n* 表达式匹配到了一个字符串字面量的话, 它会返回一个包含该字符串的JavaScript字符串对象.\n* 当表达式匹配到重复的子表达式的时候, 会将所有匹配结果放到一个JavaScript数组对象里返回.\n\n如果rule A在表达式B被引用了, 那么这个rule A的匹配结果也会传递表达式B, 接着会层层传递, 一直传递到start rule里. 当parser全部解析完成成功之后, 会直接将start rule的匹配结果返回出去.\n\n解析表达式中比较特殊的是parser action,一段包含在大括号内的JavaScript代码，这段代码可以处理表达式中引用的其他rule的匹配结果，然后自己再返回一个JavaScript对象作为当前表达式的处理结果。这个对象就是当前表达式的匹配结果，换句话说，parser action就是一个匹配结果转换器。\n\n在我们的运算示例中，有许许多多的parser action. 看一下表达式中的这个action `digits:[0-9]+ { return parseInt(digits.join(\"\"), 10); }`. 它拿到了`[0-9]+`的匹配结果`digits`(`digits` 是一个包含数字的字符串数组)。它将这些数字字符转换成一个数字，然后转换成一个js数字对象。\n\n### 解析表达式类型\n解析表达式可以分为很多种类, 而且有一些还包含子表达式, 包含子表达式的就形成了一种递归结构.\n\n##### `\"literal\"` `'literal'`\n严格匹配字面量字符串, 然后直接返回该字符串字面量. 在pegjs里字符串语法和JavaScript里相同. 在常量最后加一个`i`表示不区分大小写.\n\n> 输入的字符串必须与该字符串一模一样(可以加`i`忽略大小写)\n\n##### `.`\n严格匹配任意单个字符, 然后将它作为一个字符串返回.\n\n##### `[characters]`\n单个字符匹配, 将匹配成功的单个字符作为字符串返回. The characters in the list can be escaped in exactly the same way as in JavaScript string. 匹配模式中的字符列表也可以指定一个范围(例如`[a-z]`表示要匹配全部小写字符). 如果匹配规则中有`^`表示匹配规则相反. (例如`[^a-z]` 表示匹配除了小写字符之外的全部字符). 如果匹配规则后面跟有`i`的话, 表示忽略大小写.\n\n> `[characters]` 通常会和`*`, `+` 组合到一起使用, 匹配字符串. 与`'literal'` 不同的是, 只要单个字符符合`[characters]` 中任意一个字符即可.\n\n##### `rule`\n在表达式中引用其他rule, 然后与引用的rule进行匹配, 然后返回引用rule的匹配结果.\n\n##### `( expression )`\n匹配一个子表达式, 并返回它的匹配结果.\n\n> 匹配不成功则会抛出异常\n\n##### `expression *`\n将表达式匹配0次或多次, 然后将匹配结果通过一个数组返回. 这种匹配形式会尽可能多地尝试匹配. 与正则表达式不同的是, 它们不会进行回溯.\n\n> 匹配不成功则会抛出异常\n\n##### `expression +`\n将表达式匹配1次或多次, 然后将匹配结果通过一个数组返回. 这种匹配形式会尽可能多地尝试匹配. 与正则表达式不同的是, 它们不会进行回溯.\n\n> 匹配不成功则会抛出异常\n\n##### `expression ?`\n尝试去匹配表达式. 如果匹配成功, 则返回匹配结果, 否则返回null. 与正则表达式不同的是, 它们不会进行回溯.\n\n> 匹配不成功则会抛出异常\n\n##### `& expression`\n尝试去匹配表达式. 如果匹配成功, 则返回`undefined`而且不会消耗输入字符串, 否则认为匹配失败.\n\n> 匹配不成功则会抛出异常\n\n##### `! expression`\n尝试去匹配表达式. 如果匹配不成功, 则返回`undefined`而且不会消耗输入字符串, 否则认为匹配失败.\n\n> 匹配不成功则会抛出异常\n\n##### `& { predicate }`\nThe predicate is a piece of JavaScript code that is executed as if it was inside a function. It gets the match results of labeled expressions in preceding expression as its arguments. It should return some JavaScript value using the return statement. If the returned value evaluates to true in boolean context, just return undefined and do not consume any input; otherwise consider the match failed.\n\nThe code inside the predicate can access all variables and functions defined in the initializer at the beginning of the grammar.\n\nThe code inside the predicate can also access location information using the location function. It returns an object like this:\n```javascript\n{\n  start: { offset: 23, line: 5, column: 6 },\n  end:   { offset: 23, line: 5, column: 6 }\n}\n```\nThe start and end properties both refer to the current parse position. The offset property contains an offset as a zero-based index and line and column properties contain a line and a column as one-based indices.\n\nThe code inside the predicate can also access options passed to the parser using the options variable.\n\nNote that curly braces in the predicate code must be balanced.\n\n##### `! { predicate }`\nThe predicate is a piece of JavaScript code that is executed as if it was inside a function. It gets the match results of labeled expressions in preceding expression as its arguments. It should return some JavaScript value using the return statement. If the returned value evaluates to false in boolean context, just return undefined and do not consume any input; otherwise consider the match failed.\n\nThe code inside the predicate can access all variables and functions defined in the initializer at the beginning of the grammar.\n\nThe code inside the predicate can also access location information using the location function. It returns an object like this:\n\n```javascript\n{\n  start: { offset: 23, line: 5, column: 6 },\n  end:   { offset: 23, line: 5, column: 6 }\n}\n```\n\nThe start and end properties both refer to the current parse position. The offset property contains an offset as a zero-based index and line and column properties contain a line and a column as one-based indices.\n\nThe code inside the predicate can also access options passed to the parser using the options variable.\n\nNote that curly braces in the predicate code must be balanced.\n\n##### `$ expression`\n尝试匹配该表达式. 如果匹配成功, 不会返回匹配结果, 而是返回匹配成功的字符串.\n\n> 匹配不成功则会抛出异常\n\n##### `label : expression`\n匹配表达式, 然后将匹配结果存储在`label`里. `label`必须是一个JavaScript标识符. \n\n##### `expression1 expression2 ... expressionn`\n匹配一个表达式列表, 将全部的匹配结果放到一个数组中返回.\n\n##### `expression { action }`\n如果匹配表达式成功, 则运行action, 否则认为匹配失败.\n\n> 匹配失败返回异常.\n\n`action`是一段JavaScript代码, 可以把它当做一个方法来运行. labeled表达式的匹配结果会被当做action的参数, 传递给action. action应该通过`return`返回一个JavaScript结果, 该结果会被当做前面表达式的匹配结果.\n\n在action代码块中, 遇到非预期情况, 想要中断parse可以调用`expected`方法, 该方法会抛出一个异常. `expected`方法接受俩个参数, 第一个参数是`description`, 表明当前位置期望输入以及可选的`location`信息(默认值是what location would return). `description`会被当做exception中的message的一部分.\n\n在action代码中也可以调用`error`方法, 该方法也会抛出一个异常. `error`方法接受俩个参数, 第一个参数是error message, 第二个参数是可选的location信息(默认值是 what location would return). message会在抛出异常中使用. \naction中的代码块可以访问初始器中定义的方法和变量. action代码块的左右大括号必须都在.\naction 代码块中可以通过`text`方法访问匹配成功的字符.\naction代码块中还可以通过访问`location`方法得到location信息, 该方法会返回下面这种对象.\n\n```javascript\n{\n  start: { offset: 23, line: 5, column: 6 },\n  end:   { offset: 25, line: 5, column: 8 }\n}\n```\n`start`属性指向了表达式开始位置, `end`属性指向表达式的结束位置. `offset`是一个基于0 的offset索引位置, `line`和 `column` 属性是基于1的索引位置.\n\naction 代码块中可以通过`options`变量访问传递给parser的options.\n\n##### `expression1 / expression2 / ... / expressionn`\n按照顺序从左往右一次匹配, 返回第一个匹配成功的结果. 如果都匹配不成功, 则认为匹配失败.\n> 匹配失败返回异常.\n\n## Compatibility\narser generator 和 generated parsers 在以下环境都可以正常运行.\n* Node.js 0.10.0+\n* Internet Explorer 8+\n* Edge\n* Firefox\n* Chrome\n* Safari\n* Opera","slug":"pegjs-document","published":1,"updated":"2019-11-04T05:49:02.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2k1g06s00035c37h0283ntc","content":"<p><a href=\"https://pegjs.org/documentation\" target=\"_blank\" rel=\"noopener\">PEG.js</a> 是JavaScript里一个简单的parser生成器, 它能够非常快的生成parser, 而且如果在生成过程中遇到了问题, 也会给出非常明确的错误报告. 你可以很轻松地用它处理复杂的数据结构或者计算机语言, 也可以构建出transformers, interpreters, compilers 等其他工具.</p>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><p>PEG.js具有如下特性</p>\n<ul>\n<li>简单而富有表现力的语法</li>\n<li>集成了词法和语法分析.</li>\n<li>生成的解析器具有出色的错误报告功能</li>\n<li>基于parsing expression grammar, 生成的parser 比传统的 LL(k) 和 LR(k) parser更加强大.</li>\n<li>适用于浏览器, 命令行或者JavaScript API 等多种环境.</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h3><p>在命令行中使用<code>pegjs</code>命令编译, 需要使用全局模式安装<code>PEG.js</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g pegjs</span><br></pre></td></tr></table></figure>\n<p>如果要使用pegjs提供的 JavaScript API, 则需要在当前工作目录安装 <code>PEG.js</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install pegjs</span><br></pre></td></tr></table></figure>\n<p>如果既要使用<code>pegjs</code>命令又要使用JavaScript API, 那么你需要将上面俩种方式都安装一遍.</p>\n<h3 id=\"Browser\"><a href=\"#Browser\" class=\"headerlink\" title=\"Browser\"></a>Browser</h3><p>在浏览器中使用, 可以直接下载库文件<a href=\"https://pegjs.org/#download\" target=\"_blank\" rel=\"noopener\">PEG.js</a>或者通过<code>Bower</code>安装<code>PEG.js</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ bower install pegjs</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成-Parser\"><a href=\"#生成-Parser\" class=\"headerlink\" title=\"生成 Parser\"></a>生成 Parser</h2><p><code>PEG.js</code>将解析表达式文法解析后, 生成parser. 解析表达式文法描述描述了 将何种输入进行解析然后输出何种输出.(通过执行输入字符的匹配部分的语义操作). 通过一个简单api就可以可以生成一个parser JS对象.</p>\n<h3 id=\"命令行生成\"><a href=\"#命令行生成\" class=\"headerlink\" title=\"命令行生成\"></a>命令行生成</h3><p>想要将grammar文件生成parser, 直接使用<code>pegjs</code>进行编译即可:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pegjs arithmetics.pegjs</span><br></pre></td></tr></table></figure>\n<p>上面的命令会将生成的parser的源码输出到与grammar文件同名的js结尾的文件中. 当然也可以输出到指定文件中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pegjs -o arithmetics-parser.js arithmetics.pegjs</span><br></pre></td></tr></table></figure>\n\n<p>但是如果你将输入输出文件都忽略了, 那么系统将会采用标准输入输出.<br>在默认设置下, 生成的parser代码是以Node.js module format 进行组织代码的, 但也可以通过指定<code>--format</code>选项选择其他方式.</p>\n<blockquote>\n<p>下面的选项介绍中也有对该选项的介绍, 详情请参考<a href=\"https://75team.com/post/%E8%AF%91%E7%A5%9E%E9%A9%AC%E6%98%AFamd-commonjs-umd.html\" target=\"_blank\" rel=\"noopener\">[译]神马是AMD, CommonJS, UMD?</a></p>\n</blockquote>\n<p>你可以通过如下几个命令来修改生成的parser的默认行为.</p>\n<ul>\n<li><code>--allowed-start-rules</code>: 指定parser开始从哪个rule开始解析. (默认是文法中的第一个rule)</li>\n<li><code>--cache</code>: 开启parser的缓存功能. parser会将parse出来的结果缓存起来, 避免极端情况下解析时间成指数级增加, 但坏处是parser可能会变慢.</li>\n<li><code>--dependency</code>: 让parser依赖一个指定的依赖.(该参数可以多次使用)</li>\n<li><code>--export-var</code>: </li>\n<li><code>--extra-options</code>: 传递给<code>peg.generate</code>的额外参数(JSON 形式).</li>\n<li><code>--extra-options-file</code>: 传递给<code>peg.generate</code>的额外参数文件(JSON 形式).</li>\n<li><code>--format</code>: 生成的parser格式, 可选值有<code>amd</code>, <code>commonjs</code>, <code>globals</code>, <code>umd</code>(默认是<code>commonjs</code>)</li>\n<li><code>--optimize</code>: 为生成的parser在parsing时的优化方式, 可以选择解析速度(<code>speed</code>)或者parse结果代码大小(<code>size</code>). (默认是<code>speed</code>)</li>\n<li><code>--plugin</code>: 为PEG.js配置插件(可以配置多个, 即多次配置)</li>\n<li><code>--trace</code>: 开启parser的trace功能.</li>\n</ul>\n<h3 id=\"API生成\"><a href=\"#API生成\" class=\"headerlink\" title=\"API生成\"></a>API生成</h3><p>在node.js中, 直接<code>require(&quot;pegjs&quot;)</code> 就可以使用peg.js的parser生成器了.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> peg = <span class=\"built_in\">require</span>(<span class=\"string\">\"pegjs\"</span>);</span><br></pre></td></tr></table></figure>\n<p>在浏览器中, 需要在<code>&lt;script&gt;</code>标签引入<code>PEG.js</code>库. 如果 PEG.js 检测到一个 AMD loader, 它会把自己定义成一个 module, 否则我们只能通过<code>peg</code>这个全局对象使用pegjs的api了.<br>生成一个parser非常简单, 把解析器文法参数传递进<code>peg.generate</code>方法就可以了:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parser = peg.generate(<span class=\"string\">\"start = ('a' / 'b')+\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>根据参数的不同, 这个方法可能会返回一个新生成的parser对象或者是一个包含parser源码的字符串. 如果文法参数不合法, 则会抛出一个异常(异常中会包含这个错误的详细信息). </p>\n<p>可以通过向<code>peg.generate</code>方法传递第二个参数(该参数是一个对象)改变生成的parser的默认行为. 支持的参数如下:</p>\n<ul>\n<li><code>allowedStartRules</code>: 指定parser开始的rule. (默认是文法中第一个rule.)</li>\n<li><code>cache</code>: 如果设置为<code>true</code>, parser会将parse的结果缓存起来, 可以避免在极端情况下过长的解析时间, 但同时它带来的副作用是会使得parser变慢(默认false).</li>\n<li><code>dependencies</code>: 设置parser的依赖, 其值是一个对象, 其key为访问依赖的变量, 而value为需要加载的依赖module id.只有当<code>format</code>参数被设置为<code>&quot;amd&quot;</code>, <code>&quot;commonjs&quot;</code>, <code>&quot;umd&quot;</code> 该参数才生效. (默认为<code>{}</code>)</li>\n<li><code>exportVar</code>: Name of a global variable into which the parser object is assigned to when no module loader is detected; valid only when format is set to “globals” or “umd” (default: null).</li>\n<li><code>format</code>: 生成的parser格式, 可选值为(<code>&quot;amd&quot;</code>, <code>&quot;bare&quot;</code>, <code>&quot;commonjs&quot;</code>, <code>&quot;globals&quot;</code>, or <code>&quot;umd&quot;</code>). 只有<code>output</code>设置为<code>source</code>, 该参数才生效</li>\n<li><code>optimize</code>: 为生成的parser选择一个优化方案, 可选值为<code>&quot;speed&quot;</code>或者<code>&quot;size&quot;</code>. (默认<code>&quot;speed&quot;</code>)</li>\n<li><code>output</code>: 设置<code>generate()</code>方法返回格式. 如果值为<code>&quot;parser&quot;</code>, 则返回生成的parser对象. 如果设置为<code>&quot;source&quot;</code>, 则返回parser source字符串</li>\n<li><code>plugins</code>: 要使用的插件</li>\n<li><code>trace</code>: 追踪parser的执行过程(默认是false).</li>\n</ul>\n<h2 id=\"使用-Parser\"><a href=\"#使用-Parser\" class=\"headerlink\" title=\"使用 Parser\"></a>使用 Parser</h2><p>使用生成的parser也非常简单, 只需要调用parser对象的<code>parse</code>方法, 然后将一个字符串参数传递进该方法就可以了. 然后该方法会返回一个parse结果(已经在定义parser的文法中描述了返回何种类型的值), 或者如果字符串不合法的话抛出一个异常. 异常会输出详细的错误信息.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parser.parse(<span class=\"string\">\"abba\"</span>); <span class=\"comment\">// returns [\"a\", \"b\", \"b\", \"a\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\">parser.parse(<span class=\"string\">\"abcd\"</span>); <span class=\"comment\">// throws an exception</span></span><br></pre></td></tr></table></figure>\n\n<p>同样的, <code>parse</code>方法也支持选项参数. 支持的参数如下:</p>\n<ul>\n<li>startRule: Name of the rule to start parsing from. 开始从哪个rule执行.</li>\n<li>tracer: Tracer to use. 开启tracer.</li>\n</ul>\n<p>Parsers 也可以自定义参数, 以支持定制化的需求.</p>\n<h2 id=\"语法和语义\"><a href=\"#语法和语义\" class=\"headerlink\" title=\"语法和语义\"></a>语法和语义</h2><p>peg.js的语法和JavaScript非常像, 但是有俩点不同, pegjs不是line-oriented, 而且peg.js会忽略tokens之间的空白符. 同样地可以在peg.js中使用<code>//...</code>和<code>/* ... */</code>进行注释.<br>下面是个peg.js文法示例, 该示例生成的parser会识别出算数表达式 <code>2*(3+4)</code>, 然后将该值计算出来.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start</span><br><span class=\"line\">  = additive</span><br><span class=\"line\"></span><br><span class=\"line\">additive</span><br><span class=\"line\">  = left:multiplicative <span class=\"string\">\"+\"</span> right:additive &#123; <span class=\"keyword\">return</span> left + right; &#125;</span><br><span class=\"line\">  / multiplicative</span><br><span class=\"line\"></span><br><span class=\"line\">multiplicative</span><br><span class=\"line\">  = left:primary <span class=\"string\">\"*\"</span> right:multiplicative &#123; <span class=\"keyword\">return</span> left * right; &#125;</span><br><span class=\"line\">  / primary</span><br><span class=\"line\"></span><br><span class=\"line\">primary</span><br><span class=\"line\">  = integer</span><br><span class=\"line\">  / <span class=\"string\">\"(\"</span> additive:additive <span class=\"string\">\")\"</span> &#123; <span class=\"keyword\">return</span> additive; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">integer <span class=\"string\">\"integer\"</span></span><br><span class=\"line\">  = digits:[<span class=\"number\">0</span><span class=\"number\">-9</span>]+ &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(digits.join(<span class=\"string\">\"\"</span>), <span class=\"number\">10</span>); &#125;</span><br></pre></td></tr></table></figure>\n<p>总体来说, 文法是由rule组成的(例如上面的例子中有5个rule). 每个rule都有一个名字(例如上例中<code>integer</code>) 和 一个解析表达式(例如上例中:<code>digits:[0-9]+ { return parseInt(digits.join(&quot;&quot;), 10); }</code>). 表达式部分首先是一个匹配输入字符串的匹配规则, 然后可能后面还会有一个匹配成功之后要执行的JavaScript代码. rule也可以设置一个更加易于理解的别名, 例如上例中的integer就有一个别名, 该别名主要用于发生解析异常时, 输出日志便于解决问题. 解析动作从第一个rule开始, 我们通常以<code>start</code>命名这个rule.</p>\n<p>rule名称必须符合JavaScript的标识符规则. rule名称后跟一个<code>=</code>符号, 然后<code>=</code>后面是一个解析表达式. 如果rule名称要跟一个别名的话, 该别名必须在rule名称与<code>=</code>之间. rule之间需要由空白行进行分割, rule后也可以跟一个分号<code>;</code></p>\n<p>第一个规则之前可以设置一个初始化器, 初始化器由花括号(“{“和”}”)和花括号内的JavaScript代码组成. 初始化器会在parser开始解析之前被执行. 初始器里定义的变量和方法可以被后续的rule访问到. 初始器可以通过访问<code>options</code>参数访问到传递给parser的参数. 初始化器必须由大括号括起来, 缺一不可. 下面我们看一个简单的使用了初始化代码的示例:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeInteger</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(o.join(<span class=\"string\">\"\"</span>), <span class=\"number\">10</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">start</span><br><span class=\"line\">  = additive</span><br><span class=\"line\"></span><br><span class=\"line\">additive</span><br><span class=\"line\">  = left:multiplicative <span class=\"string\">\"+\"</span> right:additive &#123; <span class=\"keyword\">return</span> left + right; &#125;</span><br><span class=\"line\">  / multiplicative</span><br><span class=\"line\"></span><br><span class=\"line\">multiplicative</span><br><span class=\"line\">  = left:primary <span class=\"string\">\"*\"</span> right:multiplicative &#123; <span class=\"keyword\">return</span> left * right; &#125;</span><br><span class=\"line\">  / primary</span><br><span class=\"line\"></span><br><span class=\"line\">primary</span><br><span class=\"line\">  = integer</span><br><span class=\"line\">  / <span class=\"string\">\"(\"</span> additive:additive <span class=\"string\">\")\"</span> &#123; <span class=\"keyword\">return</span> additive; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">integer <span class=\"string\">\"integer\"</span></span><br><span class=\"line\">  = digits:[<span class=\"number\">0</span><span class=\"number\">-9</span>]+ &#123; <span class=\"keyword\">return</span> makeInteger(digits); &#125;</span><br></pre></td></tr></table></figure>\n<p>peg.js会将输入的字符串与rule中定义的解析表文法进行匹配. 但是存在着很多不同类型的表达式, 例如匹配字符或者字符类型, 或者匹配可选部分, 或者匹配重复情况等等. 表达式可能还包含其他rule的引用.</p>\n<p>当parser将输入字符串与表达式成功的时候, parser会生成一个JavaScript对象的匹配结果. 例如</p>\n<ul>\n<li>表达式匹配到了一个字符串字面量的话, 它会返回一个包含该字符串的JavaScript字符串对象.</li>\n<li>当表达式匹配到重复的子表达式的时候, 会将所有匹配结果放到一个JavaScript数组对象里返回.</li>\n</ul>\n<p>如果rule A在表达式B被引用了, 那么这个rule A的匹配结果也会传递表达式B, 接着会层层传递, 一直传递到start rule里. 当parser全部解析完成成功之后, 会直接将start rule的匹配结果返回出去.</p>\n<p>解析表达式中比较特殊的是parser action,一段包含在大括号内的JavaScript代码，这段代码可以处理表达式中引用的其他rule的匹配结果，然后自己再返回一个JavaScript对象作为当前表达式的处理结果。这个对象就是当前表达式的匹配结果，换句话说，parser action就是一个匹配结果转换器。</p>\n<p>在我们的运算示例中，有许许多多的parser action. 看一下表达式中的这个action <code>digits:[0-9]+ { return parseInt(digits.join(&quot;&quot;), 10); }</code>. 它拿到了<code>[0-9]+</code>的匹配结果<code>digits</code>(<code>digits</code> 是一个包含数字的字符串数组)。它将这些数字字符转换成一个数字，然后转换成一个js数字对象。</p>\n<h3 id=\"解析表达式类型\"><a href=\"#解析表达式类型\" class=\"headerlink\" title=\"解析表达式类型\"></a>解析表达式类型</h3><p>解析表达式可以分为很多种类, 而且有一些还包含子表达式, 包含子表达式的就形成了一种递归结构.</p>\n<h5 id=\"quot-literal-quot-39-literal-39\"><a href=\"#quot-literal-quot-39-literal-39\" class=\"headerlink\" title=\"&quot;literal&quot; &#39;literal&#39;\"></a><code>&quot;literal&quot;</code> <code>&#39;literal&#39;</code></h5><p>严格匹配字面量字符串, 然后直接返回该字符串字面量. 在pegjs里字符串语法和JavaScript里相同. 在常量最后加一个<code>i</code>表示不区分大小写.</p>\n<blockquote>\n<p>输入的字符串必须与该字符串一模一样(可以加<code>i</code>忽略大小写)</p>\n</blockquote>\n<h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\".\"></a><code>.</code></h5><p>严格匹配任意单个字符, 然后将它作为一个字符串返回.</p>\n<h5 id=\"characters\"><a href=\"#characters\" class=\"headerlink\" title=\"[characters]\"></a><code>[characters]</code></h5><p>单个字符匹配, 将匹配成功的单个字符作为字符串返回. The characters in the list can be escaped in exactly the same way as in JavaScript string. 匹配模式中的字符列表也可以指定一个范围(例如<code>[a-z]</code>表示要匹配全部小写字符). 如果匹配规则中有<code>^</code>表示匹配规则相反. (例如<code>[^a-z]</code> 表示匹配除了小写字符之外的全部字符). 如果匹配规则后面跟有<code>i</code>的话, 表示忽略大小写.</p>\n<blockquote>\n<p><code>[characters]</code> 通常会和<code>*</code>, <code>+</code> 组合到一起使用, 匹配字符串. 与<code>&#39;literal&#39;</code> 不同的是, 只要单个字符符合<code>[characters]</code> 中任意一个字符即可.</p>\n</blockquote>\n<h5 id=\"rule\"><a href=\"#rule\" class=\"headerlink\" title=\"rule\"></a><code>rule</code></h5><p>在表达式中引用其他rule, 然后与引用的rule进行匹配, 然后返回引用rule的匹配结果.</p>\n<h5 id=\"expression\"><a href=\"#expression\" class=\"headerlink\" title=\"( expression )\"></a><code>( expression )</code></h5><p>匹配一个子表达式, 并返回它的匹配结果.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"expression-1\"><a href=\"#expression-1\" class=\"headerlink\" title=\"expression *\"></a><code>expression *</code></h5><p>将表达式匹配0次或多次, 然后将匹配结果通过一个数组返回. 这种匹配形式会尽可能多地尝试匹配. 与正则表达式不同的是, 它们不会进行回溯.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"expression-2\"><a href=\"#expression-2\" class=\"headerlink\" title=\"expression +\"></a><code>expression +</code></h5><p>将表达式匹配1次或多次, 然后将匹配结果通过一个数组返回. 这种匹配形式会尽可能多地尝试匹配. 与正则表达式不同的是, 它们不会进行回溯.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"expression-3\"><a href=\"#expression-3\" class=\"headerlink\" title=\"expression ?\"></a><code>expression ?</code></h5><p>尝试去匹配表达式. 如果匹配成功, 则返回匹配结果, 否则返回null. 与正则表达式不同的是, 它们不会进行回溯.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"amp-expression\"><a href=\"#amp-expression\" class=\"headerlink\" title=\"&amp; expression\"></a><code>&amp; expression</code></h5><p>尝试去匹配表达式. 如果匹配成功, 则返回<code>undefined</code>而且不会消耗输入字符串, 否则认为匹配失败.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"expression-4\"><a href=\"#expression-4\" class=\"headerlink\" title=\"! expression\"></a><code>! expression</code></h5><p>尝试去匹配表达式. 如果匹配不成功, 则返回<code>undefined</code>而且不会消耗输入字符串, 否则认为匹配失败.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"amp-predicate\"><a href=\"#amp-predicate\" class=\"headerlink\" title=\"&amp; { predicate }\"></a><code>&amp; { predicate }</code></h5><p>The predicate is a piece of JavaScript code that is executed as if it was inside a function. It gets the match results of labeled expressions in preceding expression as its arguments. It should return some JavaScript value using the return statement. If the returned value evaluates to true in boolean context, just return undefined and do not consume any input; otherwise consider the match failed.</p>\n<p>The code inside the predicate can access all variables and functions defined in the initializer at the beginning of the grammar.</p>\n<p>The code inside the predicate can also access location information using the location function. It returns an object like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  start: &#123; <span class=\"attr\">offset</span>: <span class=\"number\">23</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">6</span> &#125;,</span><br><span class=\"line\">  end:   &#123; <span class=\"attr\">offset</span>: <span class=\"number\">23</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">6</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The start and end properties both refer to the current parse position. The offset property contains an offset as a zero-based index and line and column properties contain a line and a column as one-based indices.</p>\n<p>The code inside the predicate can also access options passed to the parser using the options variable.</p>\n<p>Note that curly braces in the predicate code must be balanced.</p>\n<h5 id=\"predicate\"><a href=\"#predicate\" class=\"headerlink\" title=\"! { predicate }\"></a><code>! { predicate }</code></h5><p>The predicate is a piece of JavaScript code that is executed as if it was inside a function. It gets the match results of labeled expressions in preceding expression as its arguments. It should return some JavaScript value using the return statement. If the returned value evaluates to false in boolean context, just return undefined and do not consume any input; otherwise consider the match failed.</p>\n<p>The code inside the predicate can access all variables and functions defined in the initializer at the beginning of the grammar.</p>\n<p>The code inside the predicate can also access location information using the location function. It returns an object like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  start: &#123; <span class=\"attr\">offset</span>: <span class=\"number\">23</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">6</span> &#125;,</span><br><span class=\"line\">  end:   &#123; <span class=\"attr\">offset</span>: <span class=\"number\">23</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">6</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The start and end properties both refer to the current parse position. The offset property contains an offset as a zero-based index and line and column properties contain a line and a column as one-based indices.</p>\n<p>The code inside the predicate can also access options passed to the parser using the options variable.</p>\n<p>Note that curly braces in the predicate code must be balanced.</p>\n<h5 id=\"expression-5\"><a href=\"#expression-5\" class=\"headerlink\" title=\"$ expression\"></a><code>$ expression</code></h5><p>尝试匹配该表达式. 如果匹配成功, 不会返回匹配结果, 而是返回匹配成功的字符串.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"label-expression\"><a href=\"#label-expression\" class=\"headerlink\" title=\"label : expression\"></a><code>label : expression</code></h5><p>匹配表达式, 然后将匹配结果存储在<code>label</code>里. <code>label</code>必须是一个JavaScript标识符. </p>\n<h5 id=\"expression1-expression2-expressionn\"><a href=\"#expression1-expression2-expressionn\" class=\"headerlink\" title=\"expression1 expression2 ... expressionn\"></a><code>expression1 expression2 ... expressionn</code></h5><p>匹配一个表达式列表, 将全部的匹配结果放到一个数组中返回.</p>\n<h5 id=\"expression-action\"><a href=\"#expression-action\" class=\"headerlink\" title=\"expression { action }\"></a><code>expression { action }</code></h5><p>如果匹配表达式成功, 则运行action, 否则认为匹配失败.</p>\n<blockquote>\n<p>匹配失败返回异常.</p>\n</blockquote>\n<p><code>action</code>是一段JavaScript代码, 可以把它当做一个方法来运行. labeled表达式的匹配结果会被当做action的参数, 传递给action. action应该通过<code>return</code>返回一个JavaScript结果, 该结果会被当做前面表达式的匹配结果.</p>\n<p>在action代码块中, 遇到非预期情况, 想要中断parse可以调用<code>expected</code>方法, 该方法会抛出一个异常. <code>expected</code>方法接受俩个参数, 第一个参数是<code>description</code>, 表明当前位置期望输入以及可选的<code>location</code>信息(默认值是what location would return). <code>description</code>会被当做exception中的message的一部分.</p>\n<p>在action代码中也可以调用<code>error</code>方法, 该方法也会抛出一个异常. <code>error</code>方法接受俩个参数, 第一个参数是error message, 第二个参数是可选的location信息(默认值是 what location would return). message会在抛出异常中使用.<br>action中的代码块可以访问初始器中定义的方法和变量. action代码块的左右大括号必须都在.<br>action 代码块中可以通过<code>text</code>方法访问匹配成功的字符.<br>action代码块中还可以通过访问<code>location</code>方法得到location信息, 该方法会返回下面这种对象.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  start: &#123; <span class=\"attr\">offset</span>: <span class=\"number\">23</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">6</span> &#125;,</span><br><span class=\"line\">  end:   &#123; <span class=\"attr\">offset</span>: <span class=\"number\">25</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">8</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>start</code>属性指向了表达式开始位置, <code>end</code>属性指向表达式的结束位置. <code>offset</code>是一个基于0 的offset索引位置, <code>line</code>和 <code>column</code> 属性是基于1的索引位置.</p>\n<p>action 代码块中可以通过<code>options</code>变量访问传递给parser的options.</p>\n<h5 id=\"expression1-expression2-expressionn-1\"><a href=\"#expression1-expression2-expressionn-1\" class=\"headerlink\" title=\"expression1 / expression2 / ... / expressionn\"></a><code>expression1 / expression2 / ... / expressionn</code></h5><p>按照顺序从左往右一次匹配, 返回第一个匹配成功的结果. 如果都匹配不成功, 则认为匹配失败.</p>\n<blockquote>\n<p>匹配失败返回异常.</p>\n</blockquote>\n<h2 id=\"Compatibility\"><a href=\"#Compatibility\" class=\"headerlink\" title=\"Compatibility\"></a>Compatibility</h2><p>arser generator 和 generated parsers 在以下环境都可以正常运行.</p>\n<ul>\n<li>Node.js 0.10.0+</li>\n<li>Internet Explorer 8+</li>\n<li>Edge</li>\n<li>Firefox</li>\n<li>Chrome</li>\n<li>Safari</li>\n<li>Opera</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://pegjs.org/documentation\" target=\"_blank\" rel=\"noopener\">PEG.js</a> 是JavaScript里一个简单的parser生成器, 它能够非常快的生成parser, 而且如果在生成过程中遇到了问题, 也会给出非常明确的错误报告. 你可以很轻松地用它处理复杂的数据结构或者计算机语言, 也可以构建出transformers, interpreters, compilers 等其他工具.</p>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><p>PEG.js具有如下特性</p>\n<ul>\n<li>简单而富有表现力的语法</li>\n<li>集成了词法和语法分析.</li>\n<li>生成的解析器具有出色的错误报告功能</li>\n<li>基于parsing expression grammar, 生成的parser 比传统的 LL(k) 和 LR(k) parser更加强大.</li>\n<li>适用于浏览器, 命令行或者JavaScript API 等多种环境.</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h3><p>在命令行中使用<code>pegjs</code>命令编译, 需要使用全局模式安装<code>PEG.js</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g pegjs</span><br></pre></td></tr></table></figure>\n<p>如果要使用pegjs提供的 JavaScript API, 则需要在当前工作目录安装 <code>PEG.js</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install pegjs</span><br></pre></td></tr></table></figure>\n<p>如果既要使用<code>pegjs</code>命令又要使用JavaScript API, 那么你需要将上面俩种方式都安装一遍.</p>\n<h3 id=\"Browser\"><a href=\"#Browser\" class=\"headerlink\" title=\"Browser\"></a>Browser</h3><p>在浏览器中使用, 可以直接下载库文件<a href=\"https://pegjs.org/#download\" target=\"_blank\" rel=\"noopener\">PEG.js</a>或者通过<code>Bower</code>安装<code>PEG.js</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ bower install pegjs</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成-Parser\"><a href=\"#生成-Parser\" class=\"headerlink\" title=\"生成 Parser\"></a>生成 Parser</h2><p><code>PEG.js</code>将解析表达式文法解析后, 生成parser. 解析表达式文法描述描述了 将何种输入进行解析然后输出何种输出.(通过执行输入字符的匹配部分的语义操作). 通过一个简单api就可以可以生成一个parser JS对象.</p>\n<h3 id=\"命令行生成\"><a href=\"#命令行生成\" class=\"headerlink\" title=\"命令行生成\"></a>命令行生成</h3><p>想要将grammar文件生成parser, 直接使用<code>pegjs</code>进行编译即可:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pegjs arithmetics.pegjs</span><br></pre></td></tr></table></figure>\n<p>上面的命令会将生成的parser的源码输出到与grammar文件同名的js结尾的文件中. 当然也可以输出到指定文件中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pegjs -o arithmetics-parser.js arithmetics.pegjs</span><br></pre></td></tr></table></figure>\n\n<p>但是如果你将输入输出文件都忽略了, 那么系统将会采用标准输入输出.<br>在默认设置下, 生成的parser代码是以Node.js module format 进行组织代码的, 但也可以通过指定<code>--format</code>选项选择其他方式.</p>\n<blockquote>\n<p>下面的选项介绍中也有对该选项的介绍, 详情请参考<a href=\"https://75team.com/post/%E8%AF%91%E7%A5%9E%E9%A9%AC%E6%98%AFamd-commonjs-umd.html\" target=\"_blank\" rel=\"noopener\">[译]神马是AMD, CommonJS, UMD?</a></p>\n</blockquote>\n<p>你可以通过如下几个命令来修改生成的parser的默认行为.</p>\n<ul>\n<li><code>--allowed-start-rules</code>: 指定parser开始从哪个rule开始解析. (默认是文法中的第一个rule)</li>\n<li><code>--cache</code>: 开启parser的缓存功能. parser会将parse出来的结果缓存起来, 避免极端情况下解析时间成指数级增加, 但坏处是parser可能会变慢.</li>\n<li><code>--dependency</code>: 让parser依赖一个指定的依赖.(该参数可以多次使用)</li>\n<li><code>--export-var</code>: </li>\n<li><code>--extra-options</code>: 传递给<code>peg.generate</code>的额外参数(JSON 形式).</li>\n<li><code>--extra-options-file</code>: 传递给<code>peg.generate</code>的额外参数文件(JSON 形式).</li>\n<li><code>--format</code>: 生成的parser格式, 可选值有<code>amd</code>, <code>commonjs</code>, <code>globals</code>, <code>umd</code>(默认是<code>commonjs</code>)</li>\n<li><code>--optimize</code>: 为生成的parser在parsing时的优化方式, 可以选择解析速度(<code>speed</code>)或者parse结果代码大小(<code>size</code>). (默认是<code>speed</code>)</li>\n<li><code>--plugin</code>: 为PEG.js配置插件(可以配置多个, 即多次配置)</li>\n<li><code>--trace</code>: 开启parser的trace功能.</li>\n</ul>\n<h3 id=\"API生成\"><a href=\"#API生成\" class=\"headerlink\" title=\"API生成\"></a>API生成</h3><p>在node.js中, 直接<code>require(&quot;pegjs&quot;)</code> 就可以使用peg.js的parser生成器了.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> peg = <span class=\"built_in\">require</span>(<span class=\"string\">\"pegjs\"</span>);</span><br></pre></td></tr></table></figure>\n<p>在浏览器中, 需要在<code>&lt;script&gt;</code>标签引入<code>PEG.js</code>库. 如果 PEG.js 检测到一个 AMD loader, 它会把自己定义成一个 module, 否则我们只能通过<code>peg</code>这个全局对象使用pegjs的api了.<br>生成一个parser非常简单, 把解析器文法参数传递进<code>peg.generate</code>方法就可以了:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parser = peg.generate(<span class=\"string\">\"start = ('a' / 'b')+\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>根据参数的不同, 这个方法可能会返回一个新生成的parser对象或者是一个包含parser源码的字符串. 如果文法参数不合法, 则会抛出一个异常(异常中会包含这个错误的详细信息). </p>\n<p>可以通过向<code>peg.generate</code>方法传递第二个参数(该参数是一个对象)改变生成的parser的默认行为. 支持的参数如下:</p>\n<ul>\n<li><code>allowedStartRules</code>: 指定parser开始的rule. (默认是文法中第一个rule.)</li>\n<li><code>cache</code>: 如果设置为<code>true</code>, parser会将parse的结果缓存起来, 可以避免在极端情况下过长的解析时间, 但同时它带来的副作用是会使得parser变慢(默认false).</li>\n<li><code>dependencies</code>: 设置parser的依赖, 其值是一个对象, 其key为访问依赖的变量, 而value为需要加载的依赖module id.只有当<code>format</code>参数被设置为<code>&quot;amd&quot;</code>, <code>&quot;commonjs&quot;</code>, <code>&quot;umd&quot;</code> 该参数才生效. (默认为<code>{}</code>)</li>\n<li><code>exportVar</code>: Name of a global variable into which the parser object is assigned to when no module loader is detected; valid only when format is set to “globals” or “umd” (default: null).</li>\n<li><code>format</code>: 生成的parser格式, 可选值为(<code>&quot;amd&quot;</code>, <code>&quot;bare&quot;</code>, <code>&quot;commonjs&quot;</code>, <code>&quot;globals&quot;</code>, or <code>&quot;umd&quot;</code>). 只有<code>output</code>设置为<code>source</code>, 该参数才生效</li>\n<li><code>optimize</code>: 为生成的parser选择一个优化方案, 可选值为<code>&quot;speed&quot;</code>或者<code>&quot;size&quot;</code>. (默认<code>&quot;speed&quot;</code>)</li>\n<li><code>output</code>: 设置<code>generate()</code>方法返回格式. 如果值为<code>&quot;parser&quot;</code>, 则返回生成的parser对象. 如果设置为<code>&quot;source&quot;</code>, 则返回parser source字符串</li>\n<li><code>plugins</code>: 要使用的插件</li>\n<li><code>trace</code>: 追踪parser的执行过程(默认是false).</li>\n</ul>\n<h2 id=\"使用-Parser\"><a href=\"#使用-Parser\" class=\"headerlink\" title=\"使用 Parser\"></a>使用 Parser</h2><p>使用生成的parser也非常简单, 只需要调用parser对象的<code>parse</code>方法, 然后将一个字符串参数传递进该方法就可以了. 然后该方法会返回一个parse结果(已经在定义parser的文法中描述了返回何种类型的值), 或者如果字符串不合法的话抛出一个异常. 异常会输出详细的错误信息.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parser.parse(<span class=\"string\">\"abba\"</span>); <span class=\"comment\">// returns [\"a\", \"b\", \"b\", \"a\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\">parser.parse(<span class=\"string\">\"abcd\"</span>); <span class=\"comment\">// throws an exception</span></span><br></pre></td></tr></table></figure>\n\n<p>同样的, <code>parse</code>方法也支持选项参数. 支持的参数如下:</p>\n<ul>\n<li>startRule: Name of the rule to start parsing from. 开始从哪个rule执行.</li>\n<li>tracer: Tracer to use. 开启tracer.</li>\n</ul>\n<p>Parsers 也可以自定义参数, 以支持定制化的需求.</p>\n<h2 id=\"语法和语义\"><a href=\"#语法和语义\" class=\"headerlink\" title=\"语法和语义\"></a>语法和语义</h2><p>peg.js的语法和JavaScript非常像, 但是有俩点不同, pegjs不是line-oriented, 而且peg.js会忽略tokens之间的空白符. 同样地可以在peg.js中使用<code>//...</code>和<code>/* ... */</code>进行注释.<br>下面是个peg.js文法示例, 该示例生成的parser会识别出算数表达式 <code>2*(3+4)</code>, 然后将该值计算出来.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start</span><br><span class=\"line\">  = additive</span><br><span class=\"line\"></span><br><span class=\"line\">additive</span><br><span class=\"line\">  = left:multiplicative <span class=\"string\">\"+\"</span> right:additive &#123; <span class=\"keyword\">return</span> left + right; &#125;</span><br><span class=\"line\">  / multiplicative</span><br><span class=\"line\"></span><br><span class=\"line\">multiplicative</span><br><span class=\"line\">  = left:primary <span class=\"string\">\"*\"</span> right:multiplicative &#123; <span class=\"keyword\">return</span> left * right; &#125;</span><br><span class=\"line\">  / primary</span><br><span class=\"line\"></span><br><span class=\"line\">primary</span><br><span class=\"line\">  = integer</span><br><span class=\"line\">  / <span class=\"string\">\"(\"</span> additive:additive <span class=\"string\">\")\"</span> &#123; <span class=\"keyword\">return</span> additive; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">integer <span class=\"string\">\"integer\"</span></span><br><span class=\"line\">  = digits:[<span class=\"number\">0</span><span class=\"number\">-9</span>]+ &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(digits.join(<span class=\"string\">\"\"</span>), <span class=\"number\">10</span>); &#125;</span><br></pre></td></tr></table></figure>\n<p>总体来说, 文法是由rule组成的(例如上面的例子中有5个rule). 每个rule都有一个名字(例如上例中<code>integer</code>) 和 一个解析表达式(例如上例中:<code>digits:[0-9]+ { return parseInt(digits.join(&quot;&quot;), 10); }</code>). 表达式部分首先是一个匹配输入字符串的匹配规则, 然后可能后面还会有一个匹配成功之后要执行的JavaScript代码. rule也可以设置一个更加易于理解的别名, 例如上例中的integer就有一个别名, 该别名主要用于发生解析异常时, 输出日志便于解决问题. 解析动作从第一个rule开始, 我们通常以<code>start</code>命名这个rule.</p>\n<p>rule名称必须符合JavaScript的标识符规则. rule名称后跟一个<code>=</code>符号, 然后<code>=</code>后面是一个解析表达式. 如果rule名称要跟一个别名的话, 该别名必须在rule名称与<code>=</code>之间. rule之间需要由空白行进行分割, rule后也可以跟一个分号<code>;</code></p>\n<p>第一个规则之前可以设置一个初始化器, 初始化器由花括号(“{“和”}”)和花括号内的JavaScript代码组成. 初始化器会在parser开始解析之前被执行. 初始器里定义的变量和方法可以被后续的rule访问到. 初始器可以通过访问<code>options</code>参数访问到传递给parser的参数. 初始化器必须由大括号括起来, 缺一不可. 下面我们看一个简单的使用了初始化代码的示例:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeInteger</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(o.join(<span class=\"string\">\"\"</span>), <span class=\"number\">10</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">start</span><br><span class=\"line\">  = additive</span><br><span class=\"line\"></span><br><span class=\"line\">additive</span><br><span class=\"line\">  = left:multiplicative <span class=\"string\">\"+\"</span> right:additive &#123; <span class=\"keyword\">return</span> left + right; &#125;</span><br><span class=\"line\">  / multiplicative</span><br><span class=\"line\"></span><br><span class=\"line\">multiplicative</span><br><span class=\"line\">  = left:primary <span class=\"string\">\"*\"</span> right:multiplicative &#123; <span class=\"keyword\">return</span> left * right; &#125;</span><br><span class=\"line\">  / primary</span><br><span class=\"line\"></span><br><span class=\"line\">primary</span><br><span class=\"line\">  = integer</span><br><span class=\"line\">  / <span class=\"string\">\"(\"</span> additive:additive <span class=\"string\">\")\"</span> &#123; <span class=\"keyword\">return</span> additive; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">integer <span class=\"string\">\"integer\"</span></span><br><span class=\"line\">  = digits:[<span class=\"number\">0</span><span class=\"number\">-9</span>]+ &#123; <span class=\"keyword\">return</span> makeInteger(digits); &#125;</span><br></pre></td></tr></table></figure>\n<p>peg.js会将输入的字符串与rule中定义的解析表文法进行匹配. 但是存在着很多不同类型的表达式, 例如匹配字符或者字符类型, 或者匹配可选部分, 或者匹配重复情况等等. 表达式可能还包含其他rule的引用.</p>\n<p>当parser将输入字符串与表达式成功的时候, parser会生成一个JavaScript对象的匹配结果. 例如</p>\n<ul>\n<li>表达式匹配到了一个字符串字面量的话, 它会返回一个包含该字符串的JavaScript字符串对象.</li>\n<li>当表达式匹配到重复的子表达式的时候, 会将所有匹配结果放到一个JavaScript数组对象里返回.</li>\n</ul>\n<p>如果rule A在表达式B被引用了, 那么这个rule A的匹配结果也会传递表达式B, 接着会层层传递, 一直传递到start rule里. 当parser全部解析完成成功之后, 会直接将start rule的匹配结果返回出去.</p>\n<p>解析表达式中比较特殊的是parser action,一段包含在大括号内的JavaScript代码，这段代码可以处理表达式中引用的其他rule的匹配结果，然后自己再返回一个JavaScript对象作为当前表达式的处理结果。这个对象就是当前表达式的匹配结果，换句话说，parser action就是一个匹配结果转换器。</p>\n<p>在我们的运算示例中，有许许多多的parser action. 看一下表达式中的这个action <code>digits:[0-9]+ { return parseInt(digits.join(&quot;&quot;), 10); }</code>. 它拿到了<code>[0-9]+</code>的匹配结果<code>digits</code>(<code>digits</code> 是一个包含数字的字符串数组)。它将这些数字字符转换成一个数字，然后转换成一个js数字对象。</p>\n<h3 id=\"解析表达式类型\"><a href=\"#解析表达式类型\" class=\"headerlink\" title=\"解析表达式类型\"></a>解析表达式类型</h3><p>解析表达式可以分为很多种类, 而且有一些还包含子表达式, 包含子表达式的就形成了一种递归结构.</p>\n<h5 id=\"quot-literal-quot-39-literal-39\"><a href=\"#quot-literal-quot-39-literal-39\" class=\"headerlink\" title=\"&quot;literal&quot; &#39;literal&#39;\"></a><code>&quot;literal&quot;</code> <code>&#39;literal&#39;</code></h5><p>严格匹配字面量字符串, 然后直接返回该字符串字面量. 在pegjs里字符串语法和JavaScript里相同. 在常量最后加一个<code>i</code>表示不区分大小写.</p>\n<blockquote>\n<p>输入的字符串必须与该字符串一模一样(可以加<code>i</code>忽略大小写)</p>\n</blockquote>\n<h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\".\"></a><code>.</code></h5><p>严格匹配任意单个字符, 然后将它作为一个字符串返回.</p>\n<h5 id=\"characters\"><a href=\"#characters\" class=\"headerlink\" title=\"[characters]\"></a><code>[characters]</code></h5><p>单个字符匹配, 将匹配成功的单个字符作为字符串返回. The characters in the list can be escaped in exactly the same way as in JavaScript string. 匹配模式中的字符列表也可以指定一个范围(例如<code>[a-z]</code>表示要匹配全部小写字符). 如果匹配规则中有<code>^</code>表示匹配规则相反. (例如<code>[^a-z]</code> 表示匹配除了小写字符之外的全部字符). 如果匹配规则后面跟有<code>i</code>的话, 表示忽略大小写.</p>\n<blockquote>\n<p><code>[characters]</code> 通常会和<code>*</code>, <code>+</code> 组合到一起使用, 匹配字符串. 与<code>&#39;literal&#39;</code> 不同的是, 只要单个字符符合<code>[characters]</code> 中任意一个字符即可.</p>\n</blockquote>\n<h5 id=\"rule\"><a href=\"#rule\" class=\"headerlink\" title=\"rule\"></a><code>rule</code></h5><p>在表达式中引用其他rule, 然后与引用的rule进行匹配, 然后返回引用rule的匹配结果.</p>\n<h5 id=\"expression\"><a href=\"#expression\" class=\"headerlink\" title=\"( expression )\"></a><code>( expression )</code></h5><p>匹配一个子表达式, 并返回它的匹配结果.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"expression-1\"><a href=\"#expression-1\" class=\"headerlink\" title=\"expression *\"></a><code>expression *</code></h5><p>将表达式匹配0次或多次, 然后将匹配结果通过一个数组返回. 这种匹配形式会尽可能多地尝试匹配. 与正则表达式不同的是, 它们不会进行回溯.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"expression-2\"><a href=\"#expression-2\" class=\"headerlink\" title=\"expression +\"></a><code>expression +</code></h5><p>将表达式匹配1次或多次, 然后将匹配结果通过一个数组返回. 这种匹配形式会尽可能多地尝试匹配. 与正则表达式不同的是, 它们不会进行回溯.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"expression-3\"><a href=\"#expression-3\" class=\"headerlink\" title=\"expression ?\"></a><code>expression ?</code></h5><p>尝试去匹配表达式. 如果匹配成功, 则返回匹配结果, 否则返回null. 与正则表达式不同的是, 它们不会进行回溯.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"amp-expression\"><a href=\"#amp-expression\" class=\"headerlink\" title=\"&amp; expression\"></a><code>&amp; expression</code></h5><p>尝试去匹配表达式. 如果匹配成功, 则返回<code>undefined</code>而且不会消耗输入字符串, 否则认为匹配失败.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"expression-4\"><a href=\"#expression-4\" class=\"headerlink\" title=\"! expression\"></a><code>! expression</code></h5><p>尝试去匹配表达式. 如果匹配不成功, 则返回<code>undefined</code>而且不会消耗输入字符串, 否则认为匹配失败.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"amp-predicate\"><a href=\"#amp-predicate\" class=\"headerlink\" title=\"&amp; { predicate }\"></a><code>&amp; { predicate }</code></h5><p>The predicate is a piece of JavaScript code that is executed as if it was inside a function. It gets the match results of labeled expressions in preceding expression as its arguments. It should return some JavaScript value using the return statement. If the returned value evaluates to true in boolean context, just return undefined and do not consume any input; otherwise consider the match failed.</p>\n<p>The code inside the predicate can access all variables and functions defined in the initializer at the beginning of the grammar.</p>\n<p>The code inside the predicate can also access location information using the location function. It returns an object like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  start: &#123; <span class=\"attr\">offset</span>: <span class=\"number\">23</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">6</span> &#125;,</span><br><span class=\"line\">  end:   &#123; <span class=\"attr\">offset</span>: <span class=\"number\">23</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">6</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The start and end properties both refer to the current parse position. The offset property contains an offset as a zero-based index and line and column properties contain a line and a column as one-based indices.</p>\n<p>The code inside the predicate can also access options passed to the parser using the options variable.</p>\n<p>Note that curly braces in the predicate code must be balanced.</p>\n<h5 id=\"predicate\"><a href=\"#predicate\" class=\"headerlink\" title=\"! { predicate }\"></a><code>! { predicate }</code></h5><p>The predicate is a piece of JavaScript code that is executed as if it was inside a function. It gets the match results of labeled expressions in preceding expression as its arguments. It should return some JavaScript value using the return statement. If the returned value evaluates to false in boolean context, just return undefined and do not consume any input; otherwise consider the match failed.</p>\n<p>The code inside the predicate can access all variables and functions defined in the initializer at the beginning of the grammar.</p>\n<p>The code inside the predicate can also access location information using the location function. It returns an object like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  start: &#123; <span class=\"attr\">offset</span>: <span class=\"number\">23</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">6</span> &#125;,</span><br><span class=\"line\">  end:   &#123; <span class=\"attr\">offset</span>: <span class=\"number\">23</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">6</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The start and end properties both refer to the current parse position. The offset property contains an offset as a zero-based index and line and column properties contain a line and a column as one-based indices.</p>\n<p>The code inside the predicate can also access options passed to the parser using the options variable.</p>\n<p>Note that curly braces in the predicate code must be balanced.</p>\n<h5 id=\"expression-5\"><a href=\"#expression-5\" class=\"headerlink\" title=\"$ expression\"></a><code>$ expression</code></h5><p>尝试匹配该表达式. 如果匹配成功, 不会返回匹配结果, 而是返回匹配成功的字符串.</p>\n<blockquote>\n<p>匹配不成功则会抛出异常</p>\n</blockquote>\n<h5 id=\"label-expression\"><a href=\"#label-expression\" class=\"headerlink\" title=\"label : expression\"></a><code>label : expression</code></h5><p>匹配表达式, 然后将匹配结果存储在<code>label</code>里. <code>label</code>必须是一个JavaScript标识符. </p>\n<h5 id=\"expression1-expression2-expressionn\"><a href=\"#expression1-expression2-expressionn\" class=\"headerlink\" title=\"expression1 expression2 ... expressionn\"></a><code>expression1 expression2 ... expressionn</code></h5><p>匹配一个表达式列表, 将全部的匹配结果放到一个数组中返回.</p>\n<h5 id=\"expression-action\"><a href=\"#expression-action\" class=\"headerlink\" title=\"expression { action }\"></a><code>expression { action }</code></h5><p>如果匹配表达式成功, 则运行action, 否则认为匹配失败.</p>\n<blockquote>\n<p>匹配失败返回异常.</p>\n</blockquote>\n<p><code>action</code>是一段JavaScript代码, 可以把它当做一个方法来运行. labeled表达式的匹配结果会被当做action的参数, 传递给action. action应该通过<code>return</code>返回一个JavaScript结果, 该结果会被当做前面表达式的匹配结果.</p>\n<p>在action代码块中, 遇到非预期情况, 想要中断parse可以调用<code>expected</code>方法, 该方法会抛出一个异常. <code>expected</code>方法接受俩个参数, 第一个参数是<code>description</code>, 表明当前位置期望输入以及可选的<code>location</code>信息(默认值是what location would return). <code>description</code>会被当做exception中的message的一部分.</p>\n<p>在action代码中也可以调用<code>error</code>方法, 该方法也会抛出一个异常. <code>error</code>方法接受俩个参数, 第一个参数是error message, 第二个参数是可选的location信息(默认值是 what location would return). message会在抛出异常中使用.<br>action中的代码块可以访问初始器中定义的方法和变量. action代码块的左右大括号必须都在.<br>action 代码块中可以通过<code>text</code>方法访问匹配成功的字符.<br>action代码块中还可以通过访问<code>location</code>方法得到location信息, 该方法会返回下面这种对象.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  start: &#123; <span class=\"attr\">offset</span>: <span class=\"number\">23</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">6</span> &#125;,</span><br><span class=\"line\">  end:   &#123; <span class=\"attr\">offset</span>: <span class=\"number\">25</span>, <span class=\"attr\">line</span>: <span class=\"number\">5</span>, <span class=\"attr\">column</span>: <span class=\"number\">8</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>start</code>属性指向了表达式开始位置, <code>end</code>属性指向表达式的结束位置. <code>offset</code>是一个基于0 的offset索引位置, <code>line</code>和 <code>column</code> 属性是基于1的索引位置.</p>\n<p>action 代码块中可以通过<code>options</code>变量访问传递给parser的options.</p>\n<h5 id=\"expression1-expression2-expressionn-1\"><a href=\"#expression1-expression2-expressionn-1\" class=\"headerlink\" title=\"expression1 / expression2 / ... / expressionn\"></a><code>expression1 / expression2 / ... / expressionn</code></h5><p>按照顺序从左往右一次匹配, 返回第一个匹配成功的结果. 如果都匹配不成功, 则认为匹配失败.</p>\n<blockquote>\n<p>匹配失败返回异常.</p>\n</blockquote>\n<h2 id=\"Compatibility\"><a href=\"#Compatibility\" class=\"headerlink\" title=\"Compatibility\"></a>Compatibility</h2><p>arser generator 和 generated parsers 在以下环境都可以正常运行.</p>\n<ul>\n<li>Node.js 0.10.0+</li>\n<li>Internet Explorer 8+</li>\n<li>Edge</li>\n<li>Firefox</li>\n<li>Chrome</li>\n<li>Safari</li>\n<li>Opera</li>\n</ul>\n"},{"title":"工作/生活中用到的软件/插件/小工具","date":"2018-10-30T12:43:00.000Z","_content":"\n## Chrome\n\n* Awesome Autocomplete for GitHub\n* Enhanced Github\n* Octotree\n* OneTab\n* Pinbox\n* Tampermonkey\n\n\n## Mac\n这部分参考自[有哪些命令行的软件堪称神器？](https://www.zhihu.com/question/59227720)\n* bat: cat 替换工具\n* mycli: mysql客户端\n* brew: mac安装包管理\n* ag：比grep、ack更快的递归搜索文件内容。\n* jq: json文件处理以及格式化显示\n* shellcheck：shell脚本静态检查工具\n* fzf：命令行下模糊搜索工具\n* mosh：基于UDP的终端连接\n* you-get: 非常强大的媒体下载工具\n* glances：更强大的 htop / top 代替者\n* figlet: 将输入字符转换成艺术字体。\n* Pandoc: 可以将 markdown 转成各式各样的格式：PDF、DOCX、EPUB、MOBI\n* httpie: \n* asciinema: 终端下的录制分享软件\n* ttygif: 终端录屏工具\n* Teleport\n* prettyping: ping 替代品\n* fzf\n* aria2\n* ncdu\n* jenv\n* nnn: 文件管理器\n* fd: find替代命令\n* htop\n* sz/rz\n* ip\n* fcrackzip，破解zip压缩包密码。\n* Rename-CLI\n* alder\n* fasd\n\n\n<!--more-->\n\n## VSCode\n\n* Code Runner\n* Markdown Preview Enhanced\n* MySQL Syntax\n* Open in Browser\n* Path Intellisense\n* PEG.js Language\n* Prettier - Code formatter\n* REST Client\n* Settings Sync\n* Terminal\n\n## IDEA\n列举一下idea中常用的插件(仅限于自己要安装的)\n* ASM Bytecode Outline\n* BashSupport\n* Free Mybatis Plugin\n* Grep Console\n* JavaCC Plugin\n* Translation\n\n<!--more-->","source":"_posts/work-knife.md","raw":"---\ntitle: 工作/生活中用到的软件/插件/小工具\ndate: 2018-10-30 20:43:00\n---\n\n## Chrome\n\n* Awesome Autocomplete for GitHub\n* Enhanced Github\n* Octotree\n* OneTab\n* Pinbox\n* Tampermonkey\n\n\n## Mac\n这部分参考自[有哪些命令行的软件堪称神器？](https://www.zhihu.com/question/59227720)\n* bat: cat 替换工具\n* mycli: mysql客户端\n* brew: mac安装包管理\n* ag：比grep、ack更快的递归搜索文件内容。\n* jq: json文件处理以及格式化显示\n* shellcheck：shell脚本静态检查工具\n* fzf：命令行下模糊搜索工具\n* mosh：基于UDP的终端连接\n* you-get: 非常强大的媒体下载工具\n* glances：更强大的 htop / top 代替者\n* figlet: 将输入字符转换成艺术字体。\n* Pandoc: 可以将 markdown 转成各式各样的格式：PDF、DOCX、EPUB、MOBI\n* httpie: \n* asciinema: 终端下的录制分享软件\n* ttygif: 终端录屏工具\n* Teleport\n* prettyping: ping 替代品\n* fzf\n* aria2\n* ncdu\n* jenv\n* nnn: 文件管理器\n* fd: find替代命令\n* htop\n* sz/rz\n* ip\n* fcrackzip，破解zip压缩包密码。\n* Rename-CLI\n* alder\n* fasd\n\n\n<!--more-->\n\n## VSCode\n\n* Code Runner\n* Markdown Preview Enhanced\n* MySQL Syntax\n* Open in Browser\n* Path Intellisense\n* PEG.js Language\n* Prettier - Code formatter\n* REST Client\n* Settings Sync\n* Terminal\n\n## IDEA\n列举一下idea中常用的插件(仅限于自己要安装的)\n* ASM Bytecode Outline\n* BashSupport\n* Free Mybatis Plugin\n* Grep Console\n* JavaCC Plugin\n* Translation\n\n<!--more-->","slug":"work-knife","published":1,"updated":"2019-11-04T05:49:02.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2k1g06u00045c37210xc9ba","content":"<h2 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h2><ul>\n<li>Awesome Autocomplete for GitHub</li>\n<li>Enhanced Github</li>\n<li>Octotree</li>\n<li>OneTab</li>\n<li>Pinbox</li>\n<li>Tampermonkey</li>\n</ul>\n<h2 id=\"Mac\"><a href=\"#Mac\" class=\"headerlink\" title=\"Mac\"></a>Mac</h2><p>这部分参考自<a href=\"https://www.zhihu.com/question/59227720\" target=\"_blank\" rel=\"noopener\">有哪些命令行的软件堪称神器？</a></p>\n<ul>\n<li>bat: cat 替换工具</li>\n<li>mycli: mysql客户端</li>\n<li>brew: mac安装包管理</li>\n<li>ag：比grep、ack更快的递归搜索文件内容。</li>\n<li>jq: json文件处理以及格式化显示</li>\n<li>shellcheck：shell脚本静态检查工具</li>\n<li>fzf：命令行下模糊搜索工具</li>\n<li>mosh：基于UDP的终端连接</li>\n<li>you-get: 非常强大的媒体下载工具</li>\n<li>glances：更强大的 htop / top 代替者</li>\n<li>figlet: 将输入字符转换成艺术字体。</li>\n<li>Pandoc: 可以将 markdown 转成各式各样的格式：PDF、DOCX、EPUB、MOBI</li>\n<li>httpie: </li>\n<li>asciinema: 终端下的录制分享软件</li>\n<li>ttygif: 终端录屏工具</li>\n<li>Teleport</li>\n<li>prettyping: ping 替代品</li>\n<li>fzf</li>\n<li>aria2</li>\n<li>ncdu</li>\n<li>jenv</li>\n<li>nnn: 文件管理器</li>\n<li>fd: find替代命令</li>\n<li>htop</li>\n<li>sz/rz</li>\n<li>ip</li>\n<li>fcrackzip，破解zip压缩包密码。</li>\n<li>Rename-CLI</li>\n<li>alder</li>\n<li>fasd</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"VSCode\"><a href=\"#VSCode\" class=\"headerlink\" title=\"VSCode\"></a>VSCode</h2><ul>\n<li>Code Runner</li>\n<li>Markdown Preview Enhanced</li>\n<li>MySQL Syntax</li>\n<li>Open in Browser</li>\n<li>Path Intellisense</li>\n<li>PEG.js Language</li>\n<li>Prettier - Code formatter</li>\n<li>REST Client</li>\n<li>Settings Sync</li>\n<li>Terminal</li>\n</ul>\n<h2 id=\"IDEA\"><a href=\"#IDEA\" class=\"headerlink\" title=\"IDEA\"></a>IDEA</h2><p>列举一下idea中常用的插件(仅限于自己要安装的)</p>\n<ul>\n<li>ASM Bytecode Outline</li>\n<li>BashSupport</li>\n<li>Free Mybatis Plugin</li>\n<li>Grep Console</li>\n<li>JavaCC Plugin</li>\n<li>Translation</li>\n</ul>\n<!--more-->","site":{"data":{}},"excerpt":"<h2 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h2><ul>\n<li>Awesome Autocomplete for GitHub</li>\n<li>Enhanced Github</li>\n<li>Octotree</li>\n<li>OneTab</li>\n<li>Pinbox</li>\n<li>Tampermonkey</li>\n</ul>\n<h2 id=\"Mac\"><a href=\"#Mac\" class=\"headerlink\" title=\"Mac\"></a>Mac</h2><p>这部分参考自<a href=\"https://www.zhihu.com/question/59227720\" target=\"_blank\" rel=\"noopener\">有哪些命令行的软件堪称神器？</a></p>\n<ul>\n<li>bat: cat 替换工具</li>\n<li>mycli: mysql客户端</li>\n<li>brew: mac安装包管理</li>\n<li>ag：比grep、ack更快的递归搜索文件内容。</li>\n<li>jq: json文件处理以及格式化显示</li>\n<li>shellcheck：shell脚本静态检查工具</li>\n<li>fzf：命令行下模糊搜索工具</li>\n<li>mosh：基于UDP的终端连接</li>\n<li>you-get: 非常强大的媒体下载工具</li>\n<li>glances：更强大的 htop / top 代替者</li>\n<li>figlet: 将输入字符转换成艺术字体。</li>\n<li>Pandoc: 可以将 markdown 转成各式各样的格式：PDF、DOCX、EPUB、MOBI</li>\n<li>httpie: </li>\n<li>asciinema: 终端下的录制分享软件</li>\n<li>ttygif: 终端录屏工具</li>\n<li>Teleport</li>\n<li>prettyping: ping 替代品</li>\n<li>fzf</li>\n<li>aria2</li>\n<li>ncdu</li>\n<li>jenv</li>\n<li>nnn: 文件管理器</li>\n<li>fd: find替代命令</li>\n<li>htop</li>\n<li>sz/rz</li>\n<li>ip</li>\n<li>fcrackzip，破解zip压缩包密码。</li>\n<li>Rename-CLI</li>\n<li>alder</li>\n<li>fasd</li>\n</ul>","more":"<h2 id=\"VSCode\"><a href=\"#VSCode\" class=\"headerlink\" title=\"VSCode\"></a>VSCode</h2><ul>\n<li>Code Runner</li>\n<li>Markdown Preview Enhanced</li>\n<li>MySQL Syntax</li>\n<li>Open in Browser</li>\n<li>Path Intellisense</li>\n<li>PEG.js Language</li>\n<li>Prettier - Code formatter</li>\n<li>REST Client</li>\n<li>Settings Sync</li>\n<li>Terminal</li>\n</ul>\n<h2 id=\"IDEA\"><a href=\"#IDEA\" class=\"headerlink\" title=\"IDEA\"></a>IDEA</h2><p>列举一下idea中常用的插件(仅限于自己要安装的)</p>\n<ul>\n<li>ASM Bytecode Outline</li>\n<li>BashSupport</li>\n<li>Free Mybatis Plugin</li>\n<li>Grep Console</li>\n<li>JavaCC Plugin</li>\n<li>Translation</li>\n</ul>\n<!--more-->"},{"title":"Javasist Reading and writing bytecode","date":"2019-05-01T12:15:00.000Z","_content":"\n`Javassist` is a class library for dealing with Java bytecode. Java bytecode is stored in a binary file called a class file. Each class file contains one Java class or interface.\n\n`Javassist` 是一个用于处理 Java 字节码的类库, Java 字节码被存储在一个后缀为 class 的二进制文件中. 每个 class 文件包含一个 Java 类或者 Java 接口.\n\nThe class Javassist.CtClass is an abstract representation of a class file. A CtClass (compile-time class) object is a handle for dealing with a class file. The following program is a very simple example:\n\n`Javassist.CtClass` 类是对 class 文件的一个抽象表示. 一个 `CtClass` (compile-time class) 对象处理一个 class 文件. 下面的程序是一个非常简单的示例:\n\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"test.Rectangle\");\ncc.setSuperclass(pool.get(\"test.Point\"));\ncc.writeFile();\n```\n\nThis program first obtains a ClassPool object, which controls bytecode modification with Javassist. The ClassPool object is a container of CtClass object representing a class file. It reads a class file on demand for constructing a CtClass object and records the constructed object for responding later accesses. To modify the definition of a class, the users must first obtain from a ClassPool object a reference to a CtClass object representing that class. get() in ClassPool is used for this purpose. In the case of the program shown above, the CtClass object representing a class test.Rectangle is obtained from the ClassPool object and it is assigned to a variable cc. The ClassPool object returned by getDefault() searches the default system search path.\n\n这个程序首先获得了一个`ClassPool`对象, 该对象在 Javassist 中用于控制字节码的修改. `ClassPool` 对象是一个 `CtClass`对象的容器. `ClassPool`将读取的class文件构建出`CtClass`对象, 同时将构建出来的对象缓存起来, 以便后期访问. `ClassPool`的`get()`方法正是出于上述目的. 在上面的代码中, 从`ClassPool`得到的`CtClass`对象表示的是一个`test.Rectangle`对象, 然后将该对象分配给了一个变量`cc`. `getDefault()`方法会从默认的系统搜索路径中进行搜索, 然后返回`ClassPool`对象.\n\n\nFrom the implementation viewpoint, ClassPool is a hash table of CtClass objects, which uses the class names as keys. get() in ClassPool searches this hash table to find a CtClass object associated with the specified key. If such a CtClass object is not found, get() reads a class file to construct a new CtClass object, which is recorded in the hash table and then returned as the resulting value of get().\n\n从实现上来说, `ClassPool`是一个`CtClass`对象的哈希表, 将class的名称作为key. `ClassPool`中的 `get()` 方法会根据指定的key对整个哈希表进行搜索找到一个`CtClass`对象. 如果搜索不到的话, `get()`方法会尝试读取class文件, 然后构造出一个新的`CtClass`对象, 将新的`CtClass`对象缓存后, 再返回出去.\n\nThe CtClass object obtained from a ClassPool object can be modified (details of how to modify a CtClass will be presented later). In the example above, it is modified so that the superclass of test.Rectangle is changed into a class test.Point. This change is reflected on the original class file when writeFile() in CtClass() is finally called.\n\n从`ClassPool`中拿到的`CtClass`对象可以对其进行修改(修改`CtClass`的细节会在后续的文章中讲解). 在上面的例子中, 通过`CtClass`的修改就将`test.Rectangle`的父类修改了`test.Point`. 如果我们调用了`CtClass`的`writeFile()`方法, 这个修改也对原先的class文件生效了.\n\nwriteFile() translates the CtClass object into a class file and writes it on a local disk. Javassist also provides a method for directly obtaining the modified bytecode. To obtain the bytecode, call toBytecode():\n\n`writeFile()`将`CtClass`对象转换成一个class文件, 然后将该文件写到本地磁盘上. Javassist还提供了用于直接获得修改后的字节码的方法-`toBytecode()`:\n\n```java\nbyte[] b = cc.toBytecode();\n```\n\nYou can directly load the CtClass as well:\n\n你也可以直接将Class加载进去.\n```java\nClass clazz = cc.toClass();\n```\n\ntoClass() requests the context class loader for the current thread to load the class file represented by the CtClass. It returns a java.lang.Class object representing the loaded class. For more details, please see this section below.\n\n`toClass()`方法 会使用当前线程的context class loader将`CtClass`内的字节码加载进JVM里, 然后返回一个`java.lang.Class`对象.\n\n## Defining a new class\nTo define a new class from scratch, makeClass() must be called on a ClassPool.\n\n从头开始定义一个新的class, 必须调用`ClassPool`的`makeClass()` 方法.\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.makeClass(\"Point\");\n```\nThis program defines a class Point including no members. Member methods of Point can be created with factory methods declared in CtNewMethod and appended to Point with addMethod() in CtClass.\n\n上面的程序定义了一个没有任何成员的名称为`Point`的class. 可以通过`CtNewMethod`里声明的一些工厂方法为`Point`类生成一些方法, 然后通过调用`CtClass`的`addMethod()`方法, 将这些新生成的方法加到`Point`class里面去.\n\nmakeClass() cannot create a new interface; makeInterface() in ClassPool can do. Member methods in an interface can be created with abstractMethod() in CtNewMethod. Note that an interface method is an abstract method.\n\n`makeClass()` 不能创建新的接口, 但是可以使用`ClassPool`中的`makeInterface()`创建一个新的接口. 接口中的方法可以使用`CtNewMethod`的`abstractMethod()`方法创建出来. 注意, 一个接口方法就是一个抽象方法.\n\n## Frozen classes\nIf a CtClass object is converted into a class file by writeFile(), toClass(), or toBytecode(), Javassist freezes that CtClass object. Further modifications of that CtClass object are not permitted. This is for warning the developers when they attempt to modify a class file that has been already loaded since the JVM does not allow reloading a class.\n\n如果`CtClass`对象通过`writeFile(), toClass(), or toBytecode()`等方式转换成一个class文件, Javassist会将`CtClass`对象冻结. 被冻结的`CtClass`对象不允许再次修改. 这是为了警告开发者, 他们尝试修改一个已经被load的class文件, 而JVM不允许重新加载class.\n\nA frozen CtClass can be defrost so that modifications of the class definition will be permitted. For example,\n\n被冻结的`CtClass`也可以进行解冻, 解冻之后就可以继续就那些修改了, 例如:\n```java\nCtClasss cc = ...;\n    :\ncc.writeFile();\ncc.defrost();\ncc.setSuperclass(...);    // OK since the class is not frozen.\n```\n\nAfter defrost() is called, the CtClass object can be modified again.\n\n当`defrost()`方法被调用之后, `CtClass`就可以再次修改了.\n\nIf ClassPool.doPruning is set to true, then Javassist prunes the data structure contained in a CtClass object when Javassist freezes that object. To reduce memory consumption, pruning discards unnecessary attributes (attribute_info structures) in that object. For example, Code_attribute structures (method bodies) are discarded. Thus, after a CtClass object is pruned, the bytecode of a method is not accessible except method names, signatures, and annotations. The pruned CtClass object cannot be defrost again. The default value of ClassPool.doPruning is false.\n\n如果`ClassPool.doPruning`被设置为true的话, 当Javassist冻结`CtClass`对象的时候, 会对其内部的数据结构进行精简. 为了减少内存消耗, pruning精简了`attribute_info`结构里不必要的属性. 例如方法体里面的`Code_attribute`结构就会被舍弃掉. 因此一旦`CtClass`对象被精简之后, 方法除了名称, 签名, 注解等其他信息都不可再被访问到. 而且被精简过后的`CtClass`对象也不可以再被解冻. `ClassPool.doPruning`默认值是false.\n\nTo disallow pruning a particular CtClass, stopPruning() must be called on that object in advance:\n\n如果将要设置某个特殊的`CtClass`不允许精简, 必选提前调用`CtClasss`对象的`stopPruning()`方法.\n```java\nCtClasss cc = ...;\ncc.stopPruning(true);\n    :\ncc.writeFile();                             // convert to a class file.\n// cc is not pruned.\n```\n\nThe CtClass object cc is not pruned. Thus it can be defrost after writeFile() is called.\n\n上面`CtClass`对象没有被精简, 因此当它调用了`writeFile()`方法之后, 还可以被解冻.\n\n> Note: While debugging, you might want to temporarily stop pruning and freezing and write a modified class file to a disk drive. debugWriteFile() is a convenient method for that purpose. It stops pruning, writes a class file, defrosts it, and turns pruning on again (if it was initially on).\n\n> 注意: 在调试阶段, 你也许想要临时地停止精简和冻结操作, 然后将一个修改过的class文件写到磁盘中, 此时你可以调用`debugWriteFile()`方法. 它首先停止精简操作, 然后对class文件执行写入操作, 最后再解冻, 最后回复精简状态.\n\n## Class search path\nThe default ClassPool returned by a static method ClassPool.getDefault() searches the same path that the underlying JVM (Java virtual machine) has. If a program is running on a web application server such as JBoss and Tomcat, the ClassPool object may not be able to find user classes since such a web application server uses multiple class loaders as well as the system class loader. In that case, an additional class path must be registered to the ClassPool. Suppose that pool refers to a ClassPool object:\n\n`ClassPool.getDefault()`返回的默认的`ClassPool`是基于JVM的path上面搜索得到的. 如果应用程序是运行在一个web应用服务器上(例如JBoss或者Tomcat), `ClassPool`对象可能会找不到用户定义的class, 因为web应用服务器可能会使用多个class Loader. 在这种情况下可以向`ClassPool`上注册一个新的class path.\n\n```java\npool.insertClassPath(new ClassClassPath(this.getClass()));\n```\n\nThis statement registers the class path that was used for loading the class of the object that this refers to. You can use any Class object as an argument instead of this.getClass(). The class path used for loading the class represented by that Class object is registered.\n\nYou can register a directory name as the class search path. For example, the following code adds a directory /usr/local/javalib to the search path:\n```java\nClassPool pool = ClassPool.getDefault();\npool.insertClassPath(\"/usr/local/javalib\");\n```\n\nThe search path that the users can add is not only a directory but also a URL:\n\n用户能添加的search path不仅仅是目录, 还可以添加URL:\n```java\nClassPool pool = ClassPool.getDefault();\nClassPath cp = new URLClassPath(\"www.javassist.org\", 80, \"/java/\", \"org.javassist.\");\npool.insertClassPath(cp);\n```\n这个应用程序添加了一个`http://www.javassist.org:80/java/`url到search path上. 只有当搜索属于`org.javassist`这个包下的类的时候, 才会去这个URL上进行搜索. 例如当加载`org.javassist.test.Main`类时, 它的class 文件将会从`http://www.javassist.org:80/java/org/javassist/test/Main.class`上进行加载.\n\nThis program adds \"http://www.javassist.org:80/java/\" to the class search path. This URL is used only for searching classes belonging to a package org.javassist. For example, to load a class org.javassist.test.Main, its class file will be obtained from:\n\nhttp://www.javassist.org:80/java/org/javassist/test/Main.class\n\nFurthermore, you can directly give a byte array to a ClassPool object and construct a CtClass object from that array. To do this, use ByteArrayClassPath. For example,\n\n另外, 你可以直接向`ClassPool`对象里指定一个byte数组, `ClassPool`会从这个byte数组里构建出一个`CtClass`对象. 想要使用这种方案, 可以用`ByteArrayClassPath`, 例如:\n```java\nClassPool cp = ClassPool.getDefault();\nbyte[] b = a byte array;\nString name = class name;\ncp.insertClassPath(new ByteArrayClassPath(name, b));\nCtClass cc = cp.get(name);\n```\n\nThe obtained CtClass object represents a class defined by the class file specified by b. The ClassPool reads a class file from the given ByteArrayClassPath if get() is called and the class name given to get() is equal to one specified by name.\n\n获取到的`CtClass`对象就是从`b`数组里定义出来的. 当`get()`方法被调用的时候, `ClassPool`会从给定的`ByteArrayClassPath`里读取出一个class文件, class名称就是参数name.\n\nIf you do not know the fully-qualified name of the class, then you can use makeClass() in ClassPool:\n如果你不知道class的全限定名称, 你可以使用`ClassPool`的`makeClass()`方法.\n```java\nClassPool cp = ClassPool.getDefault();\nInputStream ins = an input stream for reading a class file;\nCtClass cc = cp.makeClass(ins);\n```\n\nmakeClass() returns the CtClass object constructed from the given input stream. You can use makeClass() for eagerly feeding class files to the ClassPool object. This might improve performance if the search path includes a large jar file. Since a ClassPool object reads a class file on demand, it might repeatedly search the whole jar file for every class file. makeClass() can be used for optimizing this search. The CtClass constructed by makeClass() is kept in the ClassPool object and the class file is never read again.\n\n`makeClass()`方法会从给定的输入流里构建出一个`CtClass`对象. 你可以使用`makeClass()`方法先一步地将class文件传给给`ClassPool`对象. 如果在搜索路径里面有一个特别大的jar文件时, 这有可能提升性能. 因为`ClassPool`在后台读取class文件时, 有可能将每一个class文件都在jar文件中匹配一遍. `makeClass()` 可以优化类似的搜索. 通过`makeClass()`构建出来的`CtClass`可以缓存在`ClassPool`里, 当再次查找相同class时, 就不需要再次去class path上搜索了.\n\nThe users can extend the class search path. They can define a new class implementing ClassPath interface and give an instance of that class to insertClassPath() in ClassPool. This allows a non-standard resource to be included in the search path.\n\n用户可以拓展class search path. 他们可以将`ClassPath`接口实现类的实例通过`insertClassPath()`方法添加到`ClassPool`里. 这就可以允许一个非标准的资源路径加载到search path上.","source":"_posts/javassist/Javasist 1 Reading and writing bytecode.md","raw":"---\ntitle: Javasist Reading and writing bytecode\ndate: 2019-05-01 20:15:00\n---\n\n`Javassist` is a class library for dealing with Java bytecode. Java bytecode is stored in a binary file called a class file. Each class file contains one Java class or interface.\n\n`Javassist` 是一个用于处理 Java 字节码的类库, Java 字节码被存储在一个后缀为 class 的二进制文件中. 每个 class 文件包含一个 Java 类或者 Java 接口.\n\nThe class Javassist.CtClass is an abstract representation of a class file. A CtClass (compile-time class) object is a handle for dealing with a class file. The following program is a very simple example:\n\n`Javassist.CtClass` 类是对 class 文件的一个抽象表示. 一个 `CtClass` (compile-time class) 对象处理一个 class 文件. 下面的程序是一个非常简单的示例:\n\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"test.Rectangle\");\ncc.setSuperclass(pool.get(\"test.Point\"));\ncc.writeFile();\n```\n\nThis program first obtains a ClassPool object, which controls bytecode modification with Javassist. The ClassPool object is a container of CtClass object representing a class file. It reads a class file on demand for constructing a CtClass object and records the constructed object for responding later accesses. To modify the definition of a class, the users must first obtain from a ClassPool object a reference to a CtClass object representing that class. get() in ClassPool is used for this purpose. In the case of the program shown above, the CtClass object representing a class test.Rectangle is obtained from the ClassPool object and it is assigned to a variable cc. The ClassPool object returned by getDefault() searches the default system search path.\n\n这个程序首先获得了一个`ClassPool`对象, 该对象在 Javassist 中用于控制字节码的修改. `ClassPool` 对象是一个 `CtClass`对象的容器. `ClassPool`将读取的class文件构建出`CtClass`对象, 同时将构建出来的对象缓存起来, 以便后期访问. `ClassPool`的`get()`方法正是出于上述目的. 在上面的代码中, 从`ClassPool`得到的`CtClass`对象表示的是一个`test.Rectangle`对象, 然后将该对象分配给了一个变量`cc`. `getDefault()`方法会从默认的系统搜索路径中进行搜索, 然后返回`ClassPool`对象.\n\n\nFrom the implementation viewpoint, ClassPool is a hash table of CtClass objects, which uses the class names as keys. get() in ClassPool searches this hash table to find a CtClass object associated with the specified key. If such a CtClass object is not found, get() reads a class file to construct a new CtClass object, which is recorded in the hash table and then returned as the resulting value of get().\n\n从实现上来说, `ClassPool`是一个`CtClass`对象的哈希表, 将class的名称作为key. `ClassPool`中的 `get()` 方法会根据指定的key对整个哈希表进行搜索找到一个`CtClass`对象. 如果搜索不到的话, `get()`方法会尝试读取class文件, 然后构造出一个新的`CtClass`对象, 将新的`CtClass`对象缓存后, 再返回出去.\n\nThe CtClass object obtained from a ClassPool object can be modified (details of how to modify a CtClass will be presented later). In the example above, it is modified so that the superclass of test.Rectangle is changed into a class test.Point. This change is reflected on the original class file when writeFile() in CtClass() is finally called.\n\n从`ClassPool`中拿到的`CtClass`对象可以对其进行修改(修改`CtClass`的细节会在后续的文章中讲解). 在上面的例子中, 通过`CtClass`的修改就将`test.Rectangle`的父类修改了`test.Point`. 如果我们调用了`CtClass`的`writeFile()`方法, 这个修改也对原先的class文件生效了.\n\nwriteFile() translates the CtClass object into a class file and writes it on a local disk. Javassist also provides a method for directly obtaining the modified bytecode. To obtain the bytecode, call toBytecode():\n\n`writeFile()`将`CtClass`对象转换成一个class文件, 然后将该文件写到本地磁盘上. Javassist还提供了用于直接获得修改后的字节码的方法-`toBytecode()`:\n\n```java\nbyte[] b = cc.toBytecode();\n```\n\nYou can directly load the CtClass as well:\n\n你也可以直接将Class加载进去.\n```java\nClass clazz = cc.toClass();\n```\n\ntoClass() requests the context class loader for the current thread to load the class file represented by the CtClass. It returns a java.lang.Class object representing the loaded class. For more details, please see this section below.\n\n`toClass()`方法 会使用当前线程的context class loader将`CtClass`内的字节码加载进JVM里, 然后返回一个`java.lang.Class`对象.\n\n## Defining a new class\nTo define a new class from scratch, makeClass() must be called on a ClassPool.\n\n从头开始定义一个新的class, 必须调用`ClassPool`的`makeClass()` 方法.\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.makeClass(\"Point\");\n```\nThis program defines a class Point including no members. Member methods of Point can be created with factory methods declared in CtNewMethod and appended to Point with addMethod() in CtClass.\n\n上面的程序定义了一个没有任何成员的名称为`Point`的class. 可以通过`CtNewMethod`里声明的一些工厂方法为`Point`类生成一些方法, 然后通过调用`CtClass`的`addMethod()`方法, 将这些新生成的方法加到`Point`class里面去.\n\nmakeClass() cannot create a new interface; makeInterface() in ClassPool can do. Member methods in an interface can be created with abstractMethod() in CtNewMethod. Note that an interface method is an abstract method.\n\n`makeClass()` 不能创建新的接口, 但是可以使用`ClassPool`中的`makeInterface()`创建一个新的接口. 接口中的方法可以使用`CtNewMethod`的`abstractMethod()`方法创建出来. 注意, 一个接口方法就是一个抽象方法.\n\n## Frozen classes\nIf a CtClass object is converted into a class file by writeFile(), toClass(), or toBytecode(), Javassist freezes that CtClass object. Further modifications of that CtClass object are not permitted. This is for warning the developers when they attempt to modify a class file that has been already loaded since the JVM does not allow reloading a class.\n\n如果`CtClass`对象通过`writeFile(), toClass(), or toBytecode()`等方式转换成一个class文件, Javassist会将`CtClass`对象冻结. 被冻结的`CtClass`对象不允许再次修改. 这是为了警告开发者, 他们尝试修改一个已经被load的class文件, 而JVM不允许重新加载class.\n\nA frozen CtClass can be defrost so that modifications of the class definition will be permitted. For example,\n\n被冻结的`CtClass`也可以进行解冻, 解冻之后就可以继续就那些修改了, 例如:\n```java\nCtClasss cc = ...;\n    :\ncc.writeFile();\ncc.defrost();\ncc.setSuperclass(...);    // OK since the class is not frozen.\n```\n\nAfter defrost() is called, the CtClass object can be modified again.\n\n当`defrost()`方法被调用之后, `CtClass`就可以再次修改了.\n\nIf ClassPool.doPruning is set to true, then Javassist prunes the data structure contained in a CtClass object when Javassist freezes that object. To reduce memory consumption, pruning discards unnecessary attributes (attribute_info structures) in that object. For example, Code_attribute structures (method bodies) are discarded. Thus, after a CtClass object is pruned, the bytecode of a method is not accessible except method names, signatures, and annotations. The pruned CtClass object cannot be defrost again. The default value of ClassPool.doPruning is false.\n\n如果`ClassPool.doPruning`被设置为true的话, 当Javassist冻结`CtClass`对象的时候, 会对其内部的数据结构进行精简. 为了减少内存消耗, pruning精简了`attribute_info`结构里不必要的属性. 例如方法体里面的`Code_attribute`结构就会被舍弃掉. 因此一旦`CtClass`对象被精简之后, 方法除了名称, 签名, 注解等其他信息都不可再被访问到. 而且被精简过后的`CtClass`对象也不可以再被解冻. `ClassPool.doPruning`默认值是false.\n\nTo disallow pruning a particular CtClass, stopPruning() must be called on that object in advance:\n\n如果将要设置某个特殊的`CtClass`不允许精简, 必选提前调用`CtClasss`对象的`stopPruning()`方法.\n```java\nCtClasss cc = ...;\ncc.stopPruning(true);\n    :\ncc.writeFile();                             // convert to a class file.\n// cc is not pruned.\n```\n\nThe CtClass object cc is not pruned. Thus it can be defrost after writeFile() is called.\n\n上面`CtClass`对象没有被精简, 因此当它调用了`writeFile()`方法之后, 还可以被解冻.\n\n> Note: While debugging, you might want to temporarily stop pruning and freezing and write a modified class file to a disk drive. debugWriteFile() is a convenient method for that purpose. It stops pruning, writes a class file, defrosts it, and turns pruning on again (if it was initially on).\n\n> 注意: 在调试阶段, 你也许想要临时地停止精简和冻结操作, 然后将一个修改过的class文件写到磁盘中, 此时你可以调用`debugWriteFile()`方法. 它首先停止精简操作, 然后对class文件执行写入操作, 最后再解冻, 最后回复精简状态.\n\n## Class search path\nThe default ClassPool returned by a static method ClassPool.getDefault() searches the same path that the underlying JVM (Java virtual machine) has. If a program is running on a web application server such as JBoss and Tomcat, the ClassPool object may not be able to find user classes since such a web application server uses multiple class loaders as well as the system class loader. In that case, an additional class path must be registered to the ClassPool. Suppose that pool refers to a ClassPool object:\n\n`ClassPool.getDefault()`返回的默认的`ClassPool`是基于JVM的path上面搜索得到的. 如果应用程序是运行在一个web应用服务器上(例如JBoss或者Tomcat), `ClassPool`对象可能会找不到用户定义的class, 因为web应用服务器可能会使用多个class Loader. 在这种情况下可以向`ClassPool`上注册一个新的class path.\n\n```java\npool.insertClassPath(new ClassClassPath(this.getClass()));\n```\n\nThis statement registers the class path that was used for loading the class of the object that this refers to. You can use any Class object as an argument instead of this.getClass(). The class path used for loading the class represented by that Class object is registered.\n\nYou can register a directory name as the class search path. For example, the following code adds a directory /usr/local/javalib to the search path:\n```java\nClassPool pool = ClassPool.getDefault();\npool.insertClassPath(\"/usr/local/javalib\");\n```\n\nThe search path that the users can add is not only a directory but also a URL:\n\n用户能添加的search path不仅仅是目录, 还可以添加URL:\n```java\nClassPool pool = ClassPool.getDefault();\nClassPath cp = new URLClassPath(\"www.javassist.org\", 80, \"/java/\", \"org.javassist.\");\npool.insertClassPath(cp);\n```\n这个应用程序添加了一个`http://www.javassist.org:80/java/`url到search path上. 只有当搜索属于`org.javassist`这个包下的类的时候, 才会去这个URL上进行搜索. 例如当加载`org.javassist.test.Main`类时, 它的class 文件将会从`http://www.javassist.org:80/java/org/javassist/test/Main.class`上进行加载.\n\nThis program adds \"http://www.javassist.org:80/java/\" to the class search path. This URL is used only for searching classes belonging to a package org.javassist. For example, to load a class org.javassist.test.Main, its class file will be obtained from:\n\nhttp://www.javassist.org:80/java/org/javassist/test/Main.class\n\nFurthermore, you can directly give a byte array to a ClassPool object and construct a CtClass object from that array. To do this, use ByteArrayClassPath. For example,\n\n另外, 你可以直接向`ClassPool`对象里指定一个byte数组, `ClassPool`会从这个byte数组里构建出一个`CtClass`对象. 想要使用这种方案, 可以用`ByteArrayClassPath`, 例如:\n```java\nClassPool cp = ClassPool.getDefault();\nbyte[] b = a byte array;\nString name = class name;\ncp.insertClassPath(new ByteArrayClassPath(name, b));\nCtClass cc = cp.get(name);\n```\n\nThe obtained CtClass object represents a class defined by the class file specified by b. The ClassPool reads a class file from the given ByteArrayClassPath if get() is called and the class name given to get() is equal to one specified by name.\n\n获取到的`CtClass`对象就是从`b`数组里定义出来的. 当`get()`方法被调用的时候, `ClassPool`会从给定的`ByteArrayClassPath`里读取出一个class文件, class名称就是参数name.\n\nIf you do not know the fully-qualified name of the class, then you can use makeClass() in ClassPool:\n如果你不知道class的全限定名称, 你可以使用`ClassPool`的`makeClass()`方法.\n```java\nClassPool cp = ClassPool.getDefault();\nInputStream ins = an input stream for reading a class file;\nCtClass cc = cp.makeClass(ins);\n```\n\nmakeClass() returns the CtClass object constructed from the given input stream. You can use makeClass() for eagerly feeding class files to the ClassPool object. This might improve performance if the search path includes a large jar file. Since a ClassPool object reads a class file on demand, it might repeatedly search the whole jar file for every class file. makeClass() can be used for optimizing this search. The CtClass constructed by makeClass() is kept in the ClassPool object and the class file is never read again.\n\n`makeClass()`方法会从给定的输入流里构建出一个`CtClass`对象. 你可以使用`makeClass()`方法先一步地将class文件传给给`ClassPool`对象. 如果在搜索路径里面有一个特别大的jar文件时, 这有可能提升性能. 因为`ClassPool`在后台读取class文件时, 有可能将每一个class文件都在jar文件中匹配一遍. `makeClass()` 可以优化类似的搜索. 通过`makeClass()`构建出来的`CtClass`可以缓存在`ClassPool`里, 当再次查找相同class时, 就不需要再次去class path上搜索了.\n\nThe users can extend the class search path. They can define a new class implementing ClassPath interface and give an instance of that class to insertClassPath() in ClassPool. This allows a non-standard resource to be included in the search path.\n\n用户可以拓展class search path. 他们可以将`ClassPath`接口实现类的实例通过`insertClassPath()`方法添加到`ClassPool`里. 这就可以允许一个非标准的资源路径加载到search path上.","slug":"javassist/Javasist 1 Reading and writing bytecode","published":1,"updated":"2019-11-04T05:49:02.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2k1g07d00055c37aeq13x3h","content":"<p><code>Javassist</code> is a class library for dealing with Java bytecode. Java bytecode is stored in a binary file called a class file. Each class file contains one Java class or interface.</p>\n<p><code>Javassist</code> 是一个用于处理 Java 字节码的类库, Java 字节码被存储在一个后缀为 class 的二进制文件中. 每个 class 文件包含一个 Java 类或者 Java 接口.</p>\n<p>The class Javassist.CtClass is an abstract representation of a class file. A CtClass (compile-time class) object is a handle for dealing with a class file. The following program is a very simple example:</p>\n<p><code>Javassist.CtClass</code> 类是对 class 文件的一个抽象表示. 一个 <code>CtClass</code> (compile-time class) 对象处理一个 class 文件. 下面的程序是一个非常简单的示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"test.Rectangle\"</span>);</span><br><span class=\"line\">cc.setSuperclass(pool.get(<span class=\"string\">\"test.Point\"</span>));</span><br><span class=\"line\">cc.writeFile();</span><br></pre></td></tr></table></figure>\n\n<p>This program first obtains a ClassPool object, which controls bytecode modification with Javassist. The ClassPool object is a container of CtClass object representing a class file. It reads a class file on demand for constructing a CtClass object and records the constructed object for responding later accesses. To modify the definition of a class, the users must first obtain from a ClassPool object a reference to a CtClass object representing that class. get() in ClassPool is used for this purpose. In the case of the program shown above, the CtClass object representing a class test.Rectangle is obtained from the ClassPool object and it is assigned to a variable cc. The ClassPool object returned by getDefault() searches the default system search path.</p>\n<p>这个程序首先获得了一个<code>ClassPool</code>对象, 该对象在 Javassist 中用于控制字节码的修改. <code>ClassPool</code> 对象是一个 <code>CtClass</code>对象的容器. <code>ClassPool</code>将读取的class文件构建出<code>CtClass</code>对象, 同时将构建出来的对象缓存起来, 以便后期访问. <code>ClassPool</code>的<code>get()</code>方法正是出于上述目的. 在上面的代码中, 从<code>ClassPool</code>得到的<code>CtClass</code>对象表示的是一个<code>test.Rectangle</code>对象, 然后将该对象分配给了一个变量<code>cc</code>. <code>getDefault()</code>方法会从默认的系统搜索路径中进行搜索, 然后返回<code>ClassPool</code>对象.</p>\n<p>From the implementation viewpoint, ClassPool is a hash table of CtClass objects, which uses the class names as keys. get() in ClassPool searches this hash table to find a CtClass object associated with the specified key. If such a CtClass object is not found, get() reads a class file to construct a new CtClass object, which is recorded in the hash table and then returned as the resulting value of get().</p>\n<p>从实现上来说, <code>ClassPool</code>是一个<code>CtClass</code>对象的哈希表, 将class的名称作为key. <code>ClassPool</code>中的 <code>get()</code> 方法会根据指定的key对整个哈希表进行搜索找到一个<code>CtClass</code>对象. 如果搜索不到的话, <code>get()</code>方法会尝试读取class文件, 然后构造出一个新的<code>CtClass</code>对象, 将新的<code>CtClass</code>对象缓存后, 再返回出去.</p>\n<p>The CtClass object obtained from a ClassPool object can be modified (details of how to modify a CtClass will be presented later). In the example above, it is modified so that the superclass of test.Rectangle is changed into a class test.Point. This change is reflected on the original class file when writeFile() in CtClass() is finally called.</p>\n<p>从<code>ClassPool</code>中拿到的<code>CtClass</code>对象可以对其进行修改(修改<code>CtClass</code>的细节会在后续的文章中讲解). 在上面的例子中, 通过<code>CtClass</code>的修改就将<code>test.Rectangle</code>的父类修改了<code>test.Point</code>. 如果我们调用了<code>CtClass</code>的<code>writeFile()</code>方法, 这个修改也对原先的class文件生效了.</p>\n<p>writeFile() translates the CtClass object into a class file and writes it on a local disk. Javassist also provides a method for directly obtaining the modified bytecode. To obtain the bytecode, call toBytecode():</p>\n<p><code>writeFile()</code>将<code>CtClass</code>对象转换成一个class文件, 然后将该文件写到本地磁盘上. Javassist还提供了用于直接获得修改后的字节码的方法-<code>toBytecode()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] b = cc.toBytecode();</span><br></pre></td></tr></table></figure>\n\n<p>You can directly load the CtClass as well:</p>\n<p>你也可以直接将Class加载进去.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class clazz = cc.toClass();</span><br></pre></td></tr></table></figure>\n\n<p>toClass() requests the context class loader for the current thread to load the class file represented by the CtClass. It returns a java.lang.Class object representing the loaded class. For more details, please see this section below.</p>\n<p><code>toClass()</code>方法 会使用当前线程的context class loader将<code>CtClass</code>内的字节码加载进JVM里, 然后返回一个<code>java.lang.Class</code>对象.</p>\n<h2 id=\"Defining-a-new-class\"><a href=\"#Defining-a-new-class\" class=\"headerlink\" title=\"Defining a new class\"></a>Defining a new class</h2><p>To define a new class from scratch, makeClass() must be called on a ClassPool.</p>\n<p>从头开始定义一个新的class, 必须调用<code>ClassPool</code>的<code>makeClass()</code> 方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.makeClass(<span class=\"string\">\"Point\"</span>);</span><br></pre></td></tr></table></figure>\n<p>This program defines a class Point including no members. Member methods of Point can be created with factory methods declared in CtNewMethod and appended to Point with addMethod() in CtClass.</p>\n<p>上面的程序定义了一个没有任何成员的名称为<code>Point</code>的class. 可以通过<code>CtNewMethod</code>里声明的一些工厂方法为<code>Point</code>类生成一些方法, 然后通过调用<code>CtClass</code>的<code>addMethod()</code>方法, 将这些新生成的方法加到<code>Point</code>class里面去.</p>\n<p>makeClass() cannot create a new interface; makeInterface() in ClassPool can do. Member methods in an interface can be created with abstractMethod() in CtNewMethod. Note that an interface method is an abstract method.</p>\n<p><code>makeClass()</code> 不能创建新的接口, 但是可以使用<code>ClassPool</code>中的<code>makeInterface()</code>创建一个新的接口. 接口中的方法可以使用<code>CtNewMethod</code>的<code>abstractMethod()</code>方法创建出来. 注意, 一个接口方法就是一个抽象方法.</p>\n<h2 id=\"Frozen-classes\"><a href=\"#Frozen-classes\" class=\"headerlink\" title=\"Frozen classes\"></a>Frozen classes</h2><p>If a CtClass object is converted into a class file by writeFile(), toClass(), or toBytecode(), Javassist freezes that CtClass object. Further modifications of that CtClass object are not permitted. This is for warning the developers when they attempt to modify a class file that has been already loaded since the JVM does not allow reloading a class.</p>\n<p>如果<code>CtClass</code>对象通过<code>writeFile(), toClass(), or toBytecode()</code>等方式转换成一个class文件, Javassist会将<code>CtClass</code>对象冻结. 被冻结的<code>CtClass</code>对象不允许再次修改. 这是为了警告开发者, 他们尝试修改一个已经被load的class文件, 而JVM不允许重新加载class.</p>\n<p>A frozen CtClass can be defrost so that modifications of the class definition will be permitted. For example,</p>\n<p>被冻结的<code>CtClass</code>也可以进行解冻, 解冻之后就可以继续就那些修改了, 例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClasss cc = ...;</span><br><span class=\"line\">    :</span><br><span class=\"line\">cc.writeFile();</span><br><span class=\"line\">cc.defrost();</span><br><span class=\"line\">cc.setSuperclass(...);    <span class=\"comment\">// OK since the class is not frozen.</span></span><br></pre></td></tr></table></figure>\n\n<p>After defrost() is called, the CtClass object can be modified again.</p>\n<p>当<code>defrost()</code>方法被调用之后, <code>CtClass</code>就可以再次修改了.</p>\n<p>If ClassPool.doPruning is set to true, then Javassist prunes the data structure contained in a CtClass object when Javassist freezes that object. To reduce memory consumption, pruning discards unnecessary attributes (attribute_info structures) in that object. For example, Code_attribute structures (method bodies) are discarded. Thus, after a CtClass object is pruned, the bytecode of a method is not accessible except method names, signatures, and annotations. The pruned CtClass object cannot be defrost again. The default value of ClassPool.doPruning is false.</p>\n<p>如果<code>ClassPool.doPruning</code>被设置为true的话, 当Javassist冻结<code>CtClass</code>对象的时候, 会对其内部的数据结构进行精简. 为了减少内存消耗, pruning精简了<code>attribute_info</code>结构里不必要的属性. 例如方法体里面的<code>Code_attribute</code>结构就会被舍弃掉. 因此一旦<code>CtClass</code>对象被精简之后, 方法除了名称, 签名, 注解等其他信息都不可再被访问到. 而且被精简过后的<code>CtClass</code>对象也不可以再被解冻. <code>ClassPool.doPruning</code>默认值是false.</p>\n<p>To disallow pruning a particular CtClass, stopPruning() must be called on that object in advance:</p>\n<p>如果将要设置某个特殊的<code>CtClass</code>不允许精简, 必选提前调用<code>CtClasss</code>对象的<code>stopPruning()</code>方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClasss cc = ...;</span><br><span class=\"line\">cc.stopPruning(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    :</span><br><span class=\"line\">cc.writeFile();                             <span class=\"comment\">// convert to a class file.</span></span><br><span class=\"line\"><span class=\"comment\">// cc is not pruned.</span></span><br></pre></td></tr></table></figure>\n\n<p>The CtClass object cc is not pruned. Thus it can be defrost after writeFile() is called.</p>\n<p>上面<code>CtClass</code>对象没有被精简, 因此当它调用了<code>writeFile()</code>方法之后, 还可以被解冻.</p>\n<blockquote>\n<p>Note: While debugging, you might want to temporarily stop pruning and freezing and write a modified class file to a disk drive. debugWriteFile() is a convenient method for that purpose. It stops pruning, writes a class file, defrosts it, and turns pruning on again (if it was initially on).</p>\n</blockquote>\n<blockquote>\n<p>注意: 在调试阶段, 你也许想要临时地停止精简和冻结操作, 然后将一个修改过的class文件写到磁盘中, 此时你可以调用<code>debugWriteFile()</code>方法. 它首先停止精简操作, 然后对class文件执行写入操作, 最后再解冻, 最后回复精简状态.</p>\n</blockquote>\n<h2 id=\"Class-search-path\"><a href=\"#Class-search-path\" class=\"headerlink\" title=\"Class search path\"></a>Class search path</h2><p>The default ClassPool returned by a static method ClassPool.getDefault() searches the same path that the underlying JVM (Java virtual machine) has. If a program is running on a web application server such as JBoss and Tomcat, the ClassPool object may not be able to find user classes since such a web application server uses multiple class loaders as well as the system class loader. In that case, an additional class path must be registered to the ClassPool. Suppose that pool refers to a ClassPool object:</p>\n<p><code>ClassPool.getDefault()</code>返回的默认的<code>ClassPool</code>是基于JVM的path上面搜索得到的. 如果应用程序是运行在一个web应用服务器上(例如JBoss或者Tomcat), <code>ClassPool</code>对象可能会找不到用户定义的class, 因为web应用服务器可能会使用多个class Loader. 在这种情况下可以向<code>ClassPool</code>上注册一个新的class path.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool.insertClassPath(<span class=\"keyword\">new</span> ClassClassPath(<span class=\"keyword\">this</span>.getClass()));</span><br></pre></td></tr></table></figure>\n\n<p>This statement registers the class path that was used for loading the class of the object that this refers to. You can use any Class object as an argument instead of this.getClass(). The class path used for loading the class represented by that Class object is registered.</p>\n<p>You can register a directory name as the class search path. For example, the following code adds a directory /usr/local/javalib to the search path:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">pool.insertClassPath(<span class=\"string\">\"/usr/local/javalib\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>The search path that the users can add is not only a directory but also a URL:</p>\n<p>用户能添加的search path不仅仅是目录, 还可以添加URL:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">ClassPath cp = <span class=\"keyword\">new</span> URLClassPath(<span class=\"string\">\"www.javassist.org\"</span>, <span class=\"number\">80</span>, <span class=\"string\">\"/java/\"</span>, <span class=\"string\">\"org.javassist.\"</span>);</span><br><span class=\"line\">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure>\n<p>这个应用程序添加了一个<code>http://www.javassist.org:80/java/</code>url到search path上. 只有当搜索属于<code>org.javassist</code>这个包下的类的时候, 才会去这个URL上进行搜索. 例如当加载<code>org.javassist.test.Main</code>类时, 它的class 文件将会从<code>http://www.javassist.org:80/java/org/javassist/test/Main.class</code>上进行加载.</p>\n<p>This program adds “<a href=\"http://www.javassist.org:80/java/&quot;\" target=\"_blank\" rel=\"noopener\">http://www.javassist.org:80/java/&quot;</a> to the class search path. This URL is used only for searching classes belonging to a package org.javassist. For example, to load a class org.javassist.test.Main, its class file will be obtained from:</p>\n<p><a href=\"http://www.javassist.org:80/java/org/javassist/test/Main.class\" target=\"_blank\" rel=\"noopener\">http://www.javassist.org:80/java/org/javassist/test/Main.class</a></p>\n<p>Furthermore, you can directly give a byte array to a ClassPool object and construct a CtClass object from that array. To do this, use ByteArrayClassPath. For example,</p>\n<p>另外, 你可以直接向<code>ClassPool</code>对象里指定一个byte数组, <code>ClassPool</code>会从这个byte数组里构建出一个<code>CtClass</code>对象. 想要使用这种方案, 可以用<code>ByteArrayClassPath</code>, 例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool cp = ClassPool.getDefault();</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] b = a <span class=\"keyword\">byte</span> array;</span><br><span class=\"line\">String name = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">name</span></span>;</span><br><span class=\"line\">cp.insertClassPath(<span class=\"keyword\">new</span> ByteArrayClassPath(name, b));</span><br><span class=\"line\">CtClass cc = cp.get(name);</span><br></pre></td></tr></table></figure>\n\n<p>The obtained CtClass object represents a class defined by the class file specified by b. The ClassPool reads a class file from the given ByteArrayClassPath if get() is called and the class name given to get() is equal to one specified by name.</p>\n<p>获取到的<code>CtClass</code>对象就是从<code>b</code>数组里定义出来的. 当<code>get()</code>方法被调用的时候, <code>ClassPool</code>会从给定的<code>ByteArrayClassPath</code>里读取出一个class文件, class名称就是参数name.</p>\n<p>If you do not know the fully-qualified name of the class, then you can use makeClass() in ClassPool:<br>如果你不知道class的全限定名称, 你可以使用<code>ClassPool</code>的<code>makeClass()</code>方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool cp = ClassPool.getDefault();</span><br><span class=\"line\">InputStream ins = an input stream <span class=\"keyword\">for</span> reading a <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">file</span></span>;</span><br><span class=\"line\">CtClass cc = cp.makeClass(ins);</span><br></pre></td></tr></table></figure>\n\n<p>makeClass() returns the CtClass object constructed from the given input stream. You can use makeClass() for eagerly feeding class files to the ClassPool object. This might improve performance if the search path includes a large jar file. Since a ClassPool object reads a class file on demand, it might repeatedly search the whole jar file for every class file. makeClass() can be used for optimizing this search. The CtClass constructed by makeClass() is kept in the ClassPool object and the class file is never read again.</p>\n<p><code>makeClass()</code>方法会从给定的输入流里构建出一个<code>CtClass</code>对象. 你可以使用<code>makeClass()</code>方法先一步地将class文件传给给<code>ClassPool</code>对象. 如果在搜索路径里面有一个特别大的jar文件时, 这有可能提升性能. 因为<code>ClassPool</code>在后台读取class文件时, 有可能将每一个class文件都在jar文件中匹配一遍. <code>makeClass()</code> 可以优化类似的搜索. 通过<code>makeClass()</code>构建出来的<code>CtClass</code>可以缓存在<code>ClassPool</code>里, 当再次查找相同class时, 就不需要再次去class path上搜索了.</p>\n<p>The users can extend the class search path. They can define a new class implementing ClassPath interface and give an instance of that class to insertClassPath() in ClassPool. This allows a non-standard resource to be included in the search path.</p>\n<p>用户可以拓展class search path. 他们可以将<code>ClassPath</code>接口实现类的实例通过<code>insertClassPath()</code>方法添加到<code>ClassPool</code>里. 这就可以允许一个非标准的资源路径加载到search path上.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>Javassist</code> is a class library for dealing with Java bytecode. Java bytecode is stored in a binary file called a class file. Each class file contains one Java class or interface.</p>\n<p><code>Javassist</code> 是一个用于处理 Java 字节码的类库, Java 字节码被存储在一个后缀为 class 的二进制文件中. 每个 class 文件包含一个 Java 类或者 Java 接口.</p>\n<p>The class Javassist.CtClass is an abstract representation of a class file. A CtClass (compile-time class) object is a handle for dealing with a class file. The following program is a very simple example:</p>\n<p><code>Javassist.CtClass</code> 类是对 class 文件的一个抽象表示. 一个 <code>CtClass</code> (compile-time class) 对象处理一个 class 文件. 下面的程序是一个非常简单的示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"test.Rectangle\"</span>);</span><br><span class=\"line\">cc.setSuperclass(pool.get(<span class=\"string\">\"test.Point\"</span>));</span><br><span class=\"line\">cc.writeFile();</span><br></pre></td></tr></table></figure>\n\n<p>This program first obtains a ClassPool object, which controls bytecode modification with Javassist. The ClassPool object is a container of CtClass object representing a class file. It reads a class file on demand for constructing a CtClass object and records the constructed object for responding later accesses. To modify the definition of a class, the users must first obtain from a ClassPool object a reference to a CtClass object representing that class. get() in ClassPool is used for this purpose. In the case of the program shown above, the CtClass object representing a class test.Rectangle is obtained from the ClassPool object and it is assigned to a variable cc. The ClassPool object returned by getDefault() searches the default system search path.</p>\n<p>这个程序首先获得了一个<code>ClassPool</code>对象, 该对象在 Javassist 中用于控制字节码的修改. <code>ClassPool</code> 对象是一个 <code>CtClass</code>对象的容器. <code>ClassPool</code>将读取的class文件构建出<code>CtClass</code>对象, 同时将构建出来的对象缓存起来, 以便后期访问. <code>ClassPool</code>的<code>get()</code>方法正是出于上述目的. 在上面的代码中, 从<code>ClassPool</code>得到的<code>CtClass</code>对象表示的是一个<code>test.Rectangle</code>对象, 然后将该对象分配给了一个变量<code>cc</code>. <code>getDefault()</code>方法会从默认的系统搜索路径中进行搜索, 然后返回<code>ClassPool</code>对象.</p>\n<p>From the implementation viewpoint, ClassPool is a hash table of CtClass objects, which uses the class names as keys. get() in ClassPool searches this hash table to find a CtClass object associated with the specified key. If such a CtClass object is not found, get() reads a class file to construct a new CtClass object, which is recorded in the hash table and then returned as the resulting value of get().</p>\n<p>从实现上来说, <code>ClassPool</code>是一个<code>CtClass</code>对象的哈希表, 将class的名称作为key. <code>ClassPool</code>中的 <code>get()</code> 方法会根据指定的key对整个哈希表进行搜索找到一个<code>CtClass</code>对象. 如果搜索不到的话, <code>get()</code>方法会尝试读取class文件, 然后构造出一个新的<code>CtClass</code>对象, 将新的<code>CtClass</code>对象缓存后, 再返回出去.</p>\n<p>The CtClass object obtained from a ClassPool object can be modified (details of how to modify a CtClass will be presented later). In the example above, it is modified so that the superclass of test.Rectangle is changed into a class test.Point. This change is reflected on the original class file when writeFile() in CtClass() is finally called.</p>\n<p>从<code>ClassPool</code>中拿到的<code>CtClass</code>对象可以对其进行修改(修改<code>CtClass</code>的细节会在后续的文章中讲解). 在上面的例子中, 通过<code>CtClass</code>的修改就将<code>test.Rectangle</code>的父类修改了<code>test.Point</code>. 如果我们调用了<code>CtClass</code>的<code>writeFile()</code>方法, 这个修改也对原先的class文件生效了.</p>\n<p>writeFile() translates the CtClass object into a class file and writes it on a local disk. Javassist also provides a method for directly obtaining the modified bytecode. To obtain the bytecode, call toBytecode():</p>\n<p><code>writeFile()</code>将<code>CtClass</code>对象转换成一个class文件, 然后将该文件写到本地磁盘上. Javassist还提供了用于直接获得修改后的字节码的方法-<code>toBytecode()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] b = cc.toBytecode();</span><br></pre></td></tr></table></figure>\n\n<p>You can directly load the CtClass as well:</p>\n<p>你也可以直接将Class加载进去.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class clazz = cc.toClass();</span><br></pre></td></tr></table></figure>\n\n<p>toClass() requests the context class loader for the current thread to load the class file represented by the CtClass. It returns a java.lang.Class object representing the loaded class. For more details, please see this section below.</p>\n<p><code>toClass()</code>方法 会使用当前线程的context class loader将<code>CtClass</code>内的字节码加载进JVM里, 然后返回一个<code>java.lang.Class</code>对象.</p>\n<h2 id=\"Defining-a-new-class\"><a href=\"#Defining-a-new-class\" class=\"headerlink\" title=\"Defining a new class\"></a>Defining a new class</h2><p>To define a new class from scratch, makeClass() must be called on a ClassPool.</p>\n<p>从头开始定义一个新的class, 必须调用<code>ClassPool</code>的<code>makeClass()</code> 方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.makeClass(<span class=\"string\">\"Point\"</span>);</span><br></pre></td></tr></table></figure>\n<p>This program defines a class Point including no members. Member methods of Point can be created with factory methods declared in CtNewMethod and appended to Point with addMethod() in CtClass.</p>\n<p>上面的程序定义了一个没有任何成员的名称为<code>Point</code>的class. 可以通过<code>CtNewMethod</code>里声明的一些工厂方法为<code>Point</code>类生成一些方法, 然后通过调用<code>CtClass</code>的<code>addMethod()</code>方法, 将这些新生成的方法加到<code>Point</code>class里面去.</p>\n<p>makeClass() cannot create a new interface; makeInterface() in ClassPool can do. Member methods in an interface can be created with abstractMethod() in CtNewMethod. Note that an interface method is an abstract method.</p>\n<p><code>makeClass()</code> 不能创建新的接口, 但是可以使用<code>ClassPool</code>中的<code>makeInterface()</code>创建一个新的接口. 接口中的方法可以使用<code>CtNewMethod</code>的<code>abstractMethod()</code>方法创建出来. 注意, 一个接口方法就是一个抽象方法.</p>\n<h2 id=\"Frozen-classes\"><a href=\"#Frozen-classes\" class=\"headerlink\" title=\"Frozen classes\"></a>Frozen classes</h2><p>If a CtClass object is converted into a class file by writeFile(), toClass(), or toBytecode(), Javassist freezes that CtClass object. Further modifications of that CtClass object are not permitted. This is for warning the developers when they attempt to modify a class file that has been already loaded since the JVM does not allow reloading a class.</p>\n<p>如果<code>CtClass</code>对象通过<code>writeFile(), toClass(), or toBytecode()</code>等方式转换成一个class文件, Javassist会将<code>CtClass</code>对象冻结. 被冻结的<code>CtClass</code>对象不允许再次修改. 这是为了警告开发者, 他们尝试修改一个已经被load的class文件, 而JVM不允许重新加载class.</p>\n<p>A frozen CtClass can be defrost so that modifications of the class definition will be permitted. For example,</p>\n<p>被冻结的<code>CtClass</code>也可以进行解冻, 解冻之后就可以继续就那些修改了, 例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClasss cc = ...;</span><br><span class=\"line\">    :</span><br><span class=\"line\">cc.writeFile();</span><br><span class=\"line\">cc.defrost();</span><br><span class=\"line\">cc.setSuperclass(...);    <span class=\"comment\">// OK since the class is not frozen.</span></span><br></pre></td></tr></table></figure>\n\n<p>After defrost() is called, the CtClass object can be modified again.</p>\n<p>当<code>defrost()</code>方法被调用之后, <code>CtClass</code>就可以再次修改了.</p>\n<p>If ClassPool.doPruning is set to true, then Javassist prunes the data structure contained in a CtClass object when Javassist freezes that object. To reduce memory consumption, pruning discards unnecessary attributes (attribute_info structures) in that object. For example, Code_attribute structures (method bodies) are discarded. Thus, after a CtClass object is pruned, the bytecode of a method is not accessible except method names, signatures, and annotations. The pruned CtClass object cannot be defrost again. The default value of ClassPool.doPruning is false.</p>\n<p>如果<code>ClassPool.doPruning</code>被设置为true的话, 当Javassist冻结<code>CtClass</code>对象的时候, 会对其内部的数据结构进行精简. 为了减少内存消耗, pruning精简了<code>attribute_info</code>结构里不必要的属性. 例如方法体里面的<code>Code_attribute</code>结构就会被舍弃掉. 因此一旦<code>CtClass</code>对象被精简之后, 方法除了名称, 签名, 注解等其他信息都不可再被访问到. 而且被精简过后的<code>CtClass</code>对象也不可以再被解冻. <code>ClassPool.doPruning</code>默认值是false.</p>\n<p>To disallow pruning a particular CtClass, stopPruning() must be called on that object in advance:</p>\n<p>如果将要设置某个特殊的<code>CtClass</code>不允许精简, 必选提前调用<code>CtClasss</code>对象的<code>stopPruning()</code>方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClasss cc = ...;</span><br><span class=\"line\">cc.stopPruning(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    :</span><br><span class=\"line\">cc.writeFile();                             <span class=\"comment\">// convert to a class file.</span></span><br><span class=\"line\"><span class=\"comment\">// cc is not pruned.</span></span><br></pre></td></tr></table></figure>\n\n<p>The CtClass object cc is not pruned. Thus it can be defrost after writeFile() is called.</p>\n<p>上面<code>CtClass</code>对象没有被精简, 因此当它调用了<code>writeFile()</code>方法之后, 还可以被解冻.</p>\n<blockquote>\n<p>Note: While debugging, you might want to temporarily stop pruning and freezing and write a modified class file to a disk drive. debugWriteFile() is a convenient method for that purpose. It stops pruning, writes a class file, defrosts it, and turns pruning on again (if it was initially on).</p>\n</blockquote>\n<blockquote>\n<p>注意: 在调试阶段, 你也许想要临时地停止精简和冻结操作, 然后将一个修改过的class文件写到磁盘中, 此时你可以调用<code>debugWriteFile()</code>方法. 它首先停止精简操作, 然后对class文件执行写入操作, 最后再解冻, 最后回复精简状态.</p>\n</blockquote>\n<h2 id=\"Class-search-path\"><a href=\"#Class-search-path\" class=\"headerlink\" title=\"Class search path\"></a>Class search path</h2><p>The default ClassPool returned by a static method ClassPool.getDefault() searches the same path that the underlying JVM (Java virtual machine) has. If a program is running on a web application server such as JBoss and Tomcat, the ClassPool object may not be able to find user classes since such a web application server uses multiple class loaders as well as the system class loader. In that case, an additional class path must be registered to the ClassPool. Suppose that pool refers to a ClassPool object:</p>\n<p><code>ClassPool.getDefault()</code>返回的默认的<code>ClassPool</code>是基于JVM的path上面搜索得到的. 如果应用程序是运行在一个web应用服务器上(例如JBoss或者Tomcat), <code>ClassPool</code>对象可能会找不到用户定义的class, 因为web应用服务器可能会使用多个class Loader. 在这种情况下可以向<code>ClassPool</code>上注册一个新的class path.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool.insertClassPath(<span class=\"keyword\">new</span> ClassClassPath(<span class=\"keyword\">this</span>.getClass()));</span><br></pre></td></tr></table></figure>\n\n<p>This statement registers the class path that was used for loading the class of the object that this refers to. You can use any Class object as an argument instead of this.getClass(). The class path used for loading the class represented by that Class object is registered.</p>\n<p>You can register a directory name as the class search path. For example, the following code adds a directory /usr/local/javalib to the search path:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">pool.insertClassPath(<span class=\"string\">\"/usr/local/javalib\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>The search path that the users can add is not only a directory but also a URL:</p>\n<p>用户能添加的search path不仅仅是目录, 还可以添加URL:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">ClassPath cp = <span class=\"keyword\">new</span> URLClassPath(<span class=\"string\">\"www.javassist.org\"</span>, <span class=\"number\">80</span>, <span class=\"string\">\"/java/\"</span>, <span class=\"string\">\"org.javassist.\"</span>);</span><br><span class=\"line\">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure>\n<p>这个应用程序添加了一个<code>http://www.javassist.org:80/java/</code>url到search path上. 只有当搜索属于<code>org.javassist</code>这个包下的类的时候, 才会去这个URL上进行搜索. 例如当加载<code>org.javassist.test.Main</code>类时, 它的class 文件将会从<code>http://www.javassist.org:80/java/org/javassist/test/Main.class</code>上进行加载.</p>\n<p>This program adds “<a href=\"http://www.javassist.org:80/java/&quot;\" target=\"_blank\" rel=\"noopener\">http://www.javassist.org:80/java/&quot;</a> to the class search path. This URL is used only for searching classes belonging to a package org.javassist. For example, to load a class org.javassist.test.Main, its class file will be obtained from:</p>\n<p><a href=\"http://www.javassist.org:80/java/org/javassist/test/Main.class\" target=\"_blank\" rel=\"noopener\">http://www.javassist.org:80/java/org/javassist/test/Main.class</a></p>\n<p>Furthermore, you can directly give a byte array to a ClassPool object and construct a CtClass object from that array. To do this, use ByteArrayClassPath. For example,</p>\n<p>另外, 你可以直接向<code>ClassPool</code>对象里指定一个byte数组, <code>ClassPool</code>会从这个byte数组里构建出一个<code>CtClass</code>对象. 想要使用这种方案, 可以用<code>ByteArrayClassPath</code>, 例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool cp = ClassPool.getDefault();</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] b = a <span class=\"keyword\">byte</span> array;</span><br><span class=\"line\">String name = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">name</span></span>;</span><br><span class=\"line\">cp.insertClassPath(<span class=\"keyword\">new</span> ByteArrayClassPath(name, b));</span><br><span class=\"line\">CtClass cc = cp.get(name);</span><br></pre></td></tr></table></figure>\n\n<p>The obtained CtClass object represents a class defined by the class file specified by b. The ClassPool reads a class file from the given ByteArrayClassPath if get() is called and the class name given to get() is equal to one specified by name.</p>\n<p>获取到的<code>CtClass</code>对象就是从<code>b</code>数组里定义出来的. 当<code>get()</code>方法被调用的时候, <code>ClassPool</code>会从给定的<code>ByteArrayClassPath</code>里读取出一个class文件, class名称就是参数name.</p>\n<p>If you do not know the fully-qualified name of the class, then you can use makeClass() in ClassPool:<br>如果你不知道class的全限定名称, 你可以使用<code>ClassPool</code>的<code>makeClass()</code>方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool cp = ClassPool.getDefault();</span><br><span class=\"line\">InputStream ins = an input stream <span class=\"keyword\">for</span> reading a <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">file</span></span>;</span><br><span class=\"line\">CtClass cc = cp.makeClass(ins);</span><br></pre></td></tr></table></figure>\n\n<p>makeClass() returns the CtClass object constructed from the given input stream. You can use makeClass() for eagerly feeding class files to the ClassPool object. This might improve performance if the search path includes a large jar file. Since a ClassPool object reads a class file on demand, it might repeatedly search the whole jar file for every class file. makeClass() can be used for optimizing this search. The CtClass constructed by makeClass() is kept in the ClassPool object and the class file is never read again.</p>\n<p><code>makeClass()</code>方法会从给定的输入流里构建出一个<code>CtClass</code>对象. 你可以使用<code>makeClass()</code>方法先一步地将class文件传给给<code>ClassPool</code>对象. 如果在搜索路径里面有一个特别大的jar文件时, 这有可能提升性能. 因为<code>ClassPool</code>在后台读取class文件时, 有可能将每一个class文件都在jar文件中匹配一遍. <code>makeClass()</code> 可以优化类似的搜索. 通过<code>makeClass()</code>构建出来的<code>CtClass</code>可以缓存在<code>ClassPool</code>里, 当再次查找相同class时, 就不需要再次去class path上搜索了.</p>\n<p>The users can extend the class search path. They can define a new class implementing ClassPath interface and give an instance of that class to insertClassPath() in ClassPool. This allows a non-standard resource to be included in the search path.</p>\n<p>用户可以拓展class search path. 他们可以将<code>ClassPath</code>接口实现类的实例通过<code>insertClassPath()</code>方法添加到<code>ClassPool</code>里. 这就可以允许一个非标准的资源路径加载到search path上.</p>\n"},{"title":"Javasist ClassPool","date":"2019-05-02T12:15:00.000Z","_content":"\nA ClassPool object is a container of CtClass objects. Once a CtClass object is created, it is recorded in a ClassPool for ever. This is because a compiler may need to access the CtClass object later when it compiles source code that refers to the class represented by that CtClass.\n\n`ClassPool`对象是CtClass对象的集合. 一旦CtClass对象被创建出来, 它就会被永远地保存在ClassPool中. 这是因为编译器在编译源码的时候可能还需要访问这些CtClass对象.\n\nFor example, suppose that a new method getter() is added to a CtClass object representing Point class. Later, the program attempts to compile source code including a method call to getter() in Point and use the compiled code as the body of a method, which will be added to another class Line. If the CtClass object representing Point is lost, the compiler cannot compile the method call to getter(). Note that the original class definition does not include getter(). Therefore, to correctly compile such a method call, the ClassPool must contain all the instances of CtClass all the time of program execution.\n\n例如, 向Point类的CtClass对象添加一个新的getter()方法. 然后程序将某段调用Point的getter()方法的源码片段进行编译, 然后将编译好的代码片段放到另外一个类里. 如果找不到代表Point的CtClass的话, 编译器就没办法编译对getter()方法的调用. 注意, 原先的class是不包含getter()方法的. 因此, 为了能正确进行编译, 在程序运行期间, ClassPool必须包含全部的CtClass实例.\n\n## Avoid out of memory\nThis specification of ClassPool may cause huge memory consumption if the number of CtClass objects becomes amazingly large (this rarely happens since Javassist tries to reduce memory consumption in various ways). To avoid this problem, you can explicitly remove an unnecessary CtClass object from the ClassPool. If you call detach() on a CtClass object, then that CtClass object is removed from the ClassPool. For example,\n\n按照上文描述的那样, 如果CtClass实例数量飞速增长的话, ClassPool就有可能会引起巨大的内存消耗(但是实际上这种情况很少发生, 因此Javassist会通过多种方式减少内存消耗). 为了解决这种问题, 你可以显式地从ClassPool里面删除不需要的CtClass实例. 如果你在CtClass对象上调用detach()方法的, 该对象就会从ClassPool里面移除. 例如: \n\n\n```java\nCtClass cc = ... ;\ncc.writeFile();\ncc.detach();\n```\n\n当 detach() 方法被调用之后, CtClass实例的其他方法就不再允许被调用. 但是你可以接着调用ClassPool的get()方法, 再获得一个相同class的新的CtClass实例. 如果你调用了`get()`方法, ClassPool会重新读取class 文件, 然后再创建一个新的CtClass对象.\n\nYou must not call any method on that CtClass object after detach() is called. However, you can call get() on ClassPool to make a new instance of CtClass representing the same class. If you call get(), the ClassPool reads a class file again and newly creates a CtClass object, which is returned by get().\n\n另一种思路是再重新创建一个ClassPool, 然后将旧的那个舍弃掉. 如果旧的ClassPool被gc掉了, 那么原先ClassPool里的CtClass对象也都被gc掉了. 如果要创建一个新的ClassPool实例, 执行下面的代码即可:\n\nAnother idea is to occasionally replace a ClassPool with a new one and discard the old one. If an old ClassPool is garbage collected, the CtClass objects included in that ClassPool are also garbage collected. To create a new instance of ClassPool, execute the following code snippet:\n\n```java\nClassPool cp = new ClassPool(true);\n// if needed, append an extra search path by appendClassPath()\n```\n\n刚才创建的ClassPool的行为和通过调用ClassPool.getDefault()返回的默认ClassPool是一样的. 注意ClassPool.getDefault()是出于便捷目的而存在的一个单例工厂方法. ClassPool.getDefault() 会像上面那样创建一个ClassPool 对象, 然后作为单例存在, 一直复用它. 通过getDefault()返回的ClassPool并没有特殊的规则. getDefault() 只是一个快捷方法.\n\nThis creates a ClassPool object that behaves as the default ClassPool returned by ClassPool.getDefault() does. Note that ClassPool.getDefault() is a singleton factory method provided for convenience. It creates a ClassPool object in the same way shown above although it keeps a single instance of ClassPool and reuses it. A ClassPool object returned by getDefault() does not have a special role. getDefault() is a convenience method.\n\n注意 new ClassPool(true) 是一个快捷构造器,  它只是构建了一个ClassPool对象, 然后将系统搜索路径添加到这上面. 该构造器方法和下面方法等同.\nNote that new ClassPool(true) is a convenient constructor, which constructs a ClassPool object and appends the system search path to it. Calling that constructor is equivalent to the following code:\n\n```java\nClassPool cp = new ClassPool();\ncp.appendSystemPath();  // or append another path by appendClassPath()\n```\n\n## Cascaded ClassPools\n\n如果应用程序是运行在一个web 服务器上, 那么就有可能需要创建多个ClassPool实例. 每个class Loader都需要创建一个ClassPool实例. 在这种背景下, 就需要通过ClassPool的构造器创建ClassPool实例, 而不能再通过getDefault()方法获得了.\n\nIf a program is running on a web application server, creating multiple instances of ClassPool might be necessary; an instance of ClassPool should be created for each class loader (i.e. container). The program should create a ClassPool object by not calling getDefault() but a constructor of ClassPool.\n\nMultiple ClassPool objects can be cascaded like java.lang.ClassLoader. For example,\n\n多个ClassPool对象可以像java.lang.ClassLoader那样呗级联起来. 例如:\n\n```java\nClassPool parent = ClassPool.getDefault();\nClassPool child = new ClassPool(parent);\nchild.insertClassPath(\"./classes\");\n```\n\n如果child.get()方法被调用, child ClassPool首先将该请求委托给上一级ClassPool. 如果上一级ClassPool没有找到目标class文件, 那么child ClassPool就会尝试在./classes目录里查找class文件.\n\nIf child.get() is called, the child ClassPool first delegates to the parent ClassPool. If the parent ClassPool fails to find a class file, then the child ClassPool attempts to find a class file under the ./classes directory.\n\n如果 child.childFirstLookup 被设置为true的话, child ClassPool就会首先尝试尝试查找class文件, 找不到再去上一级ClassPool中查找. 例如:\n\nIf child.childFirstLookup is true, the child ClassPool attempts to find a class file before delegating to the parent ClassPool. For example,\n\n```java\nClassPool parent = ClassPool.getDefault();\nClassPool child = new ClassPool(parent);\nchild.appendSystemPath();         // the same class path as the default one.\nchild.childFirstLookup = true;    // changes the behavior of the child.\n```\n\n## Changing a class name for defining a new class\nA new class can be defined as a copy of an existing class. The program below does that:\n\n一个新的class可以通过从已经存在的class的副本中制作出来. 例如L\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"Point\");\ncc.setName(\"Pair\");\n```\n\n上面的程序首先获得了Point对应的CtClass对象. 然后它调用setName()设置了一个新的名称Pair. setName()被调用之后, CtClass对象中的所有该class 名称都从Point转换成了Pair. 但是class 定义的其他部分并没有变.\n\nThis program first obtains the CtClass object for class Point. Then it calls setName() to give a new name Pair to that CtClass object. After this call, all occurrences of the class name in the class definition represented by that CtClass object are changed from Point to Pair. The other part of the class definition does not change.\n\n注意CtClass的setName()也会改变ClassPool中的记录. 从实现角度来说, 一个CLassPool对象就是CtClass对象的一个hash表. setName()也会将hash表中和CtClass对象关联的key也更改掉. key从原先的class名称换到了新的class名称.\nNote that setName() in CtClass changes a record in the ClassPool object. From the implementation viewpoint, a ClassPool object is a hash table of CtClass objects. setName() changes the key associated to the CtClass object in the hash table. The key is changed from the original class name to the new class name.\n\n因此, 如果再次调用ClassPool的get(\"Point\")方法, 再也不会返回cc所指向的CtClass对象. ClassPool会再次读取Point.class文件, 然后构建出一个新的Point的CtClass对象出来. 这厮因为和Point名称关联的CtClass对象已经不复存在了. 例如:\n\nTherefore, if get(\"Point\") is later called on the ClassPool object again, then it never returns the CtClass object that the variable cc refers to. The ClassPool object reads a class file Point.class again and it constructs a new CtClass object for class Point. This is because the CtClass object associated with the name Point does not exist any more. See the followings:\n\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"Point\");\nCtClass cc1 = pool.get(\"Point\");   // cc1 is identical to cc.\ncc.setName(\"Pair\");\nCtClass cc2 = pool.get(\"Pair\");    // cc2 is identical to cc.\nCtClass cc3 = pool.get(\"Point\");   // cc3 is not identical to cc.\n```\n\ncc1和cc2指向的是和cc指向的相同的对象, 而cc3则不是. 注意, cc.setName(\"Pair\") 方法执行之后, cc和cc1指向CtClass对象也代表着Pair class.\ncc1 and cc2 refer to the same instance of CtClass that cc does whereas cc3 does not. Note that, after cc.setName(\"Pair\") is executed, the CtClass object that cc and cc1 refer to represents the Pair class.\n\nClassPool对象被用来维持class和CtClass对象之间的一对一映射. 在同一个ClassPool中, Javassist从不允许俩个不同的CtClass对象代表同一个class. 对于程序转换来说, 这是一个非常有意义的特性.\n\nThe ClassPool object is used to maintain one-to-one mapping between classes and CtClass objects. Javassist never allows two distinct CtClass objects to represent the same class unless two independent ClassPool are created. This is a significant feature for consistent program transformation.\n\n如果你有俩个ClassPool对象, 那么你可以从每个ClassPool里面获得一个相同的class的CtClass对象. 你可以通过修改不同的CtClass对象生成不同版本的class.\n\nIf you have two ClassPool objects, then you can obtain, from each ClassPool, a distinct CtClass object representing the same class file. You can differently modify these CtClass objects to generate different versions of the class.\n\n## Renaming a frozen class for defining a new class\n\n一旦一个CtClass对象通过writeFile() or toBytecode()方法转换成一个class, Javassist就不允许CtClass对象再次修改了. 因此, 当代表Point的CtClass对象被转换成一个class之后, 你就不能再通过设置setName()的方式来获取一个Point的副本Pair了. 例如下面的代码, 是不合法的.\n\nOnce a CtClass object is converted into a class file by writeFile() or toBytecode(), Javassist rejects further modifications of that CtClass object. Hence, after the CtClass object representing Point class is converted into a class file, you cannot define Pair class as a copy of Point since executing setName() on Point is rejected. The following code snippet is wrong:\n\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"Point\");\ncc.writeFile();\ncc.setName(\"Pair\");    // wrong since writeFile() has been called.\n```\n\nTo avoid this restriction, you should call getAndRename() in ClassPool. For example,\n\n对于这种限制, 你应该调用ClassPool的getAndRename()方法, 例如:\n\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"Point\");\ncc.writeFile();\nCtClass cc2 = pool.getAndRename(\"Point\", \"Pair\");\n```\n\ngetAndRename()被调用之后, ClassPool首先读取Point.class, 然后创建出一个代表Point class的CtClass对象. 在存储ClassPool的hash表之前, 它将CtClass名称从Point重新命名为Pair. 因此, getAndRename() 可以再writeFile() or toBytecode()被调用之后 再次调用.\n\nIf getAndRename() is called, the ClassPool first reads Point.class for creating a new CtClass object representing Point class. However, it renames that CtClass object from Point to Pair before it records that CtClass object in a hash table. Thus getAndRename() can be executed after writeFile() or toBytecode() is called on the the CtClass object representing Point class.\n\n","source":"_posts/javassist/Javasist 2 ClassPool.md","raw":"---\ntitle: Javasist ClassPool\ndate: 2019-05-02 20:15:00\n---\n\nA ClassPool object is a container of CtClass objects. Once a CtClass object is created, it is recorded in a ClassPool for ever. This is because a compiler may need to access the CtClass object later when it compiles source code that refers to the class represented by that CtClass.\n\n`ClassPool`对象是CtClass对象的集合. 一旦CtClass对象被创建出来, 它就会被永远地保存在ClassPool中. 这是因为编译器在编译源码的时候可能还需要访问这些CtClass对象.\n\nFor example, suppose that a new method getter() is added to a CtClass object representing Point class. Later, the program attempts to compile source code including a method call to getter() in Point and use the compiled code as the body of a method, which will be added to another class Line. If the CtClass object representing Point is lost, the compiler cannot compile the method call to getter(). Note that the original class definition does not include getter(). Therefore, to correctly compile such a method call, the ClassPool must contain all the instances of CtClass all the time of program execution.\n\n例如, 向Point类的CtClass对象添加一个新的getter()方法. 然后程序将某段调用Point的getter()方法的源码片段进行编译, 然后将编译好的代码片段放到另外一个类里. 如果找不到代表Point的CtClass的话, 编译器就没办法编译对getter()方法的调用. 注意, 原先的class是不包含getter()方法的. 因此, 为了能正确进行编译, 在程序运行期间, ClassPool必须包含全部的CtClass实例.\n\n## Avoid out of memory\nThis specification of ClassPool may cause huge memory consumption if the number of CtClass objects becomes amazingly large (this rarely happens since Javassist tries to reduce memory consumption in various ways). To avoid this problem, you can explicitly remove an unnecessary CtClass object from the ClassPool. If you call detach() on a CtClass object, then that CtClass object is removed from the ClassPool. For example,\n\n按照上文描述的那样, 如果CtClass实例数量飞速增长的话, ClassPool就有可能会引起巨大的内存消耗(但是实际上这种情况很少发生, 因此Javassist会通过多种方式减少内存消耗). 为了解决这种问题, 你可以显式地从ClassPool里面删除不需要的CtClass实例. 如果你在CtClass对象上调用detach()方法的, 该对象就会从ClassPool里面移除. 例如: \n\n\n```java\nCtClass cc = ... ;\ncc.writeFile();\ncc.detach();\n```\n\n当 detach() 方法被调用之后, CtClass实例的其他方法就不再允许被调用. 但是你可以接着调用ClassPool的get()方法, 再获得一个相同class的新的CtClass实例. 如果你调用了`get()`方法, ClassPool会重新读取class 文件, 然后再创建一个新的CtClass对象.\n\nYou must not call any method on that CtClass object after detach() is called. However, you can call get() on ClassPool to make a new instance of CtClass representing the same class. If you call get(), the ClassPool reads a class file again and newly creates a CtClass object, which is returned by get().\n\n另一种思路是再重新创建一个ClassPool, 然后将旧的那个舍弃掉. 如果旧的ClassPool被gc掉了, 那么原先ClassPool里的CtClass对象也都被gc掉了. 如果要创建一个新的ClassPool实例, 执行下面的代码即可:\n\nAnother idea is to occasionally replace a ClassPool with a new one and discard the old one. If an old ClassPool is garbage collected, the CtClass objects included in that ClassPool are also garbage collected. To create a new instance of ClassPool, execute the following code snippet:\n\n```java\nClassPool cp = new ClassPool(true);\n// if needed, append an extra search path by appendClassPath()\n```\n\n刚才创建的ClassPool的行为和通过调用ClassPool.getDefault()返回的默认ClassPool是一样的. 注意ClassPool.getDefault()是出于便捷目的而存在的一个单例工厂方法. ClassPool.getDefault() 会像上面那样创建一个ClassPool 对象, 然后作为单例存在, 一直复用它. 通过getDefault()返回的ClassPool并没有特殊的规则. getDefault() 只是一个快捷方法.\n\nThis creates a ClassPool object that behaves as the default ClassPool returned by ClassPool.getDefault() does. Note that ClassPool.getDefault() is a singleton factory method provided for convenience. It creates a ClassPool object in the same way shown above although it keeps a single instance of ClassPool and reuses it. A ClassPool object returned by getDefault() does not have a special role. getDefault() is a convenience method.\n\n注意 new ClassPool(true) 是一个快捷构造器,  它只是构建了一个ClassPool对象, 然后将系统搜索路径添加到这上面. 该构造器方法和下面方法等同.\nNote that new ClassPool(true) is a convenient constructor, which constructs a ClassPool object and appends the system search path to it. Calling that constructor is equivalent to the following code:\n\n```java\nClassPool cp = new ClassPool();\ncp.appendSystemPath();  // or append another path by appendClassPath()\n```\n\n## Cascaded ClassPools\n\n如果应用程序是运行在一个web 服务器上, 那么就有可能需要创建多个ClassPool实例. 每个class Loader都需要创建一个ClassPool实例. 在这种背景下, 就需要通过ClassPool的构造器创建ClassPool实例, 而不能再通过getDefault()方法获得了.\n\nIf a program is running on a web application server, creating multiple instances of ClassPool might be necessary; an instance of ClassPool should be created for each class loader (i.e. container). The program should create a ClassPool object by not calling getDefault() but a constructor of ClassPool.\n\nMultiple ClassPool objects can be cascaded like java.lang.ClassLoader. For example,\n\n多个ClassPool对象可以像java.lang.ClassLoader那样呗级联起来. 例如:\n\n```java\nClassPool parent = ClassPool.getDefault();\nClassPool child = new ClassPool(parent);\nchild.insertClassPath(\"./classes\");\n```\n\n如果child.get()方法被调用, child ClassPool首先将该请求委托给上一级ClassPool. 如果上一级ClassPool没有找到目标class文件, 那么child ClassPool就会尝试在./classes目录里查找class文件.\n\nIf child.get() is called, the child ClassPool first delegates to the parent ClassPool. If the parent ClassPool fails to find a class file, then the child ClassPool attempts to find a class file under the ./classes directory.\n\n如果 child.childFirstLookup 被设置为true的话, child ClassPool就会首先尝试尝试查找class文件, 找不到再去上一级ClassPool中查找. 例如:\n\nIf child.childFirstLookup is true, the child ClassPool attempts to find a class file before delegating to the parent ClassPool. For example,\n\n```java\nClassPool parent = ClassPool.getDefault();\nClassPool child = new ClassPool(parent);\nchild.appendSystemPath();         // the same class path as the default one.\nchild.childFirstLookup = true;    // changes the behavior of the child.\n```\n\n## Changing a class name for defining a new class\nA new class can be defined as a copy of an existing class. The program below does that:\n\n一个新的class可以通过从已经存在的class的副本中制作出来. 例如L\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"Point\");\ncc.setName(\"Pair\");\n```\n\n上面的程序首先获得了Point对应的CtClass对象. 然后它调用setName()设置了一个新的名称Pair. setName()被调用之后, CtClass对象中的所有该class 名称都从Point转换成了Pair. 但是class 定义的其他部分并没有变.\n\nThis program first obtains the CtClass object for class Point. Then it calls setName() to give a new name Pair to that CtClass object. After this call, all occurrences of the class name in the class definition represented by that CtClass object are changed from Point to Pair. The other part of the class definition does not change.\n\n注意CtClass的setName()也会改变ClassPool中的记录. 从实现角度来说, 一个CLassPool对象就是CtClass对象的一个hash表. setName()也会将hash表中和CtClass对象关联的key也更改掉. key从原先的class名称换到了新的class名称.\nNote that setName() in CtClass changes a record in the ClassPool object. From the implementation viewpoint, a ClassPool object is a hash table of CtClass objects. setName() changes the key associated to the CtClass object in the hash table. The key is changed from the original class name to the new class name.\n\n因此, 如果再次调用ClassPool的get(\"Point\")方法, 再也不会返回cc所指向的CtClass对象. ClassPool会再次读取Point.class文件, 然后构建出一个新的Point的CtClass对象出来. 这厮因为和Point名称关联的CtClass对象已经不复存在了. 例如:\n\nTherefore, if get(\"Point\") is later called on the ClassPool object again, then it never returns the CtClass object that the variable cc refers to. The ClassPool object reads a class file Point.class again and it constructs a new CtClass object for class Point. This is because the CtClass object associated with the name Point does not exist any more. See the followings:\n\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"Point\");\nCtClass cc1 = pool.get(\"Point\");   // cc1 is identical to cc.\ncc.setName(\"Pair\");\nCtClass cc2 = pool.get(\"Pair\");    // cc2 is identical to cc.\nCtClass cc3 = pool.get(\"Point\");   // cc3 is not identical to cc.\n```\n\ncc1和cc2指向的是和cc指向的相同的对象, 而cc3则不是. 注意, cc.setName(\"Pair\") 方法执行之后, cc和cc1指向CtClass对象也代表着Pair class.\ncc1 and cc2 refer to the same instance of CtClass that cc does whereas cc3 does not. Note that, after cc.setName(\"Pair\") is executed, the CtClass object that cc and cc1 refer to represents the Pair class.\n\nClassPool对象被用来维持class和CtClass对象之间的一对一映射. 在同一个ClassPool中, Javassist从不允许俩个不同的CtClass对象代表同一个class. 对于程序转换来说, 这是一个非常有意义的特性.\n\nThe ClassPool object is used to maintain one-to-one mapping between classes and CtClass objects. Javassist never allows two distinct CtClass objects to represent the same class unless two independent ClassPool are created. This is a significant feature for consistent program transformation.\n\n如果你有俩个ClassPool对象, 那么你可以从每个ClassPool里面获得一个相同的class的CtClass对象. 你可以通过修改不同的CtClass对象生成不同版本的class.\n\nIf you have two ClassPool objects, then you can obtain, from each ClassPool, a distinct CtClass object representing the same class file. You can differently modify these CtClass objects to generate different versions of the class.\n\n## Renaming a frozen class for defining a new class\n\n一旦一个CtClass对象通过writeFile() or toBytecode()方法转换成一个class, Javassist就不允许CtClass对象再次修改了. 因此, 当代表Point的CtClass对象被转换成一个class之后, 你就不能再通过设置setName()的方式来获取一个Point的副本Pair了. 例如下面的代码, 是不合法的.\n\nOnce a CtClass object is converted into a class file by writeFile() or toBytecode(), Javassist rejects further modifications of that CtClass object. Hence, after the CtClass object representing Point class is converted into a class file, you cannot define Pair class as a copy of Point since executing setName() on Point is rejected. The following code snippet is wrong:\n\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"Point\");\ncc.writeFile();\ncc.setName(\"Pair\");    // wrong since writeFile() has been called.\n```\n\nTo avoid this restriction, you should call getAndRename() in ClassPool. For example,\n\n对于这种限制, 你应该调用ClassPool的getAndRename()方法, 例如:\n\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"Point\");\ncc.writeFile();\nCtClass cc2 = pool.getAndRename(\"Point\", \"Pair\");\n```\n\ngetAndRename()被调用之后, ClassPool首先读取Point.class, 然后创建出一个代表Point class的CtClass对象. 在存储ClassPool的hash表之前, 它将CtClass名称从Point重新命名为Pair. 因此, getAndRename() 可以再writeFile() or toBytecode()被调用之后 再次调用.\n\nIf getAndRename() is called, the ClassPool first reads Point.class for creating a new CtClass object representing Point class. However, it renames that CtClass object from Point to Pair before it records that CtClass object in a hash table. Thus getAndRename() can be executed after writeFile() or toBytecode() is called on the the CtClass object representing Point class.\n\n","slug":"javassist/Javasist 2 ClassPool","published":1,"updated":"2019-11-04T05:49:02.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2k1g07e00065c3789l0dzyn","content":"<p>A ClassPool object is a container of CtClass objects. Once a CtClass object is created, it is recorded in a ClassPool for ever. This is because a compiler may need to access the CtClass object later when it compiles source code that refers to the class represented by that CtClass.</p>\n<p><code>ClassPool</code>对象是CtClass对象的集合. 一旦CtClass对象被创建出来, 它就会被永远地保存在ClassPool中. 这是因为编译器在编译源码的时候可能还需要访问这些CtClass对象.</p>\n<p>For example, suppose that a new method getter() is added to a CtClass object representing Point class. Later, the program attempts to compile source code including a method call to getter() in Point and use the compiled code as the body of a method, which will be added to another class Line. If the CtClass object representing Point is lost, the compiler cannot compile the method call to getter(). Note that the original class definition does not include getter(). Therefore, to correctly compile such a method call, the ClassPool must contain all the instances of CtClass all the time of program execution.</p>\n<p>例如, 向Point类的CtClass对象添加一个新的getter()方法. 然后程序将某段调用Point的getter()方法的源码片段进行编译, 然后将编译好的代码片段放到另外一个类里. 如果找不到代表Point的CtClass的话, 编译器就没办法编译对getter()方法的调用. 注意, 原先的class是不包含getter()方法的. 因此, 为了能正确进行编译, 在程序运行期间, ClassPool必须包含全部的CtClass实例.</p>\n<h2 id=\"Avoid-out-of-memory\"><a href=\"#Avoid-out-of-memory\" class=\"headerlink\" title=\"Avoid out of memory\"></a>Avoid out of memory</h2><p>This specification of ClassPool may cause huge memory consumption if the number of CtClass objects becomes amazingly large (this rarely happens since Javassist tries to reduce memory consumption in various ways). To avoid this problem, you can explicitly remove an unnecessary CtClass object from the ClassPool. If you call detach() on a CtClass object, then that CtClass object is removed from the ClassPool. For example,</p>\n<p>按照上文描述的那样, 如果CtClass实例数量飞速增长的话, ClassPool就有可能会引起巨大的内存消耗(但是实际上这种情况很少发生, 因此Javassist会通过多种方式减少内存消耗). 为了解决这种问题, 你可以显式地从ClassPool里面删除不需要的CtClass实例. 如果你在CtClass对象上调用detach()方法的, 该对象就会从ClassPool里面移除. 例如: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass cc = ... ;</span><br><span class=\"line\">cc.writeFile();</span><br><span class=\"line\">cc.detach();</span><br></pre></td></tr></table></figure>\n\n<p>当 detach() 方法被调用之后, CtClass实例的其他方法就不再允许被调用. 但是你可以接着调用ClassPool的get()方法, 再获得一个相同class的新的CtClass实例. 如果你调用了<code>get()</code>方法, ClassPool会重新读取class 文件, 然后再创建一个新的CtClass对象.</p>\n<p>You must not call any method on that CtClass object after detach() is called. However, you can call get() on ClassPool to make a new instance of CtClass representing the same class. If you call get(), the ClassPool reads a class file again and newly creates a CtClass object, which is returned by get().</p>\n<p>另一种思路是再重新创建一个ClassPool, 然后将旧的那个舍弃掉. 如果旧的ClassPool被gc掉了, 那么原先ClassPool里的CtClass对象也都被gc掉了. 如果要创建一个新的ClassPool实例, 执行下面的代码即可:</p>\n<p>Another idea is to occasionally replace a ClassPool with a new one and discard the old one. If an old ClassPool is garbage collected, the CtClass objects included in that ClassPool are also garbage collected. To create a new instance of ClassPool, execute the following code snippet:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool cp = <span class=\"keyword\">new</span> ClassPool(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// if needed, append an extra search path by appendClassPath()</span></span><br></pre></td></tr></table></figure>\n\n<p>刚才创建的ClassPool的行为和通过调用ClassPool.getDefault()返回的默认ClassPool是一样的. 注意ClassPool.getDefault()是出于便捷目的而存在的一个单例工厂方法. ClassPool.getDefault() 会像上面那样创建一个ClassPool 对象, 然后作为单例存在, 一直复用它. 通过getDefault()返回的ClassPool并没有特殊的规则. getDefault() 只是一个快捷方法.</p>\n<p>This creates a ClassPool object that behaves as the default ClassPool returned by ClassPool.getDefault() does. Note that ClassPool.getDefault() is a singleton factory method provided for convenience. It creates a ClassPool object in the same way shown above although it keeps a single instance of ClassPool and reuses it. A ClassPool object returned by getDefault() does not have a special role. getDefault() is a convenience method.</p>\n<p>注意 new ClassPool(true) 是一个快捷构造器,  它只是构建了一个ClassPool对象, 然后将系统搜索路径添加到这上面. 该构造器方法和下面方法等同.<br>Note that new ClassPool(true) is a convenient constructor, which constructs a ClassPool object and appends the system search path to it. Calling that constructor is equivalent to the following code:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool cp = <span class=\"keyword\">new</span> ClassPool();</span><br><span class=\"line\">cp.appendSystemPath();  <span class=\"comment\">// or append another path by appendClassPath()</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Cascaded-ClassPools\"><a href=\"#Cascaded-ClassPools\" class=\"headerlink\" title=\"Cascaded ClassPools\"></a>Cascaded ClassPools</h2><p>如果应用程序是运行在一个web 服务器上, 那么就有可能需要创建多个ClassPool实例. 每个class Loader都需要创建一个ClassPool实例. 在这种背景下, 就需要通过ClassPool的构造器创建ClassPool实例, 而不能再通过getDefault()方法获得了.</p>\n<p>If a program is running on a web application server, creating multiple instances of ClassPool might be necessary; an instance of ClassPool should be created for each class loader (i.e. container). The program should create a ClassPool object by not calling getDefault() but a constructor of ClassPool.</p>\n<p>Multiple ClassPool objects can be cascaded like java.lang.ClassLoader. For example,</p>\n<p>多个ClassPool对象可以像java.lang.ClassLoader那样呗级联起来. 例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool parent = ClassPool.getDefault();</span><br><span class=\"line\">ClassPool child = <span class=\"keyword\">new</span> ClassPool(parent);</span><br><span class=\"line\">child.insertClassPath(<span class=\"string\">\"./classes\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果child.get()方法被调用, child ClassPool首先将该请求委托给上一级ClassPool. 如果上一级ClassPool没有找到目标class文件, 那么child ClassPool就会尝试在./classes目录里查找class文件.</p>\n<p>If child.get() is called, the child ClassPool first delegates to the parent ClassPool. If the parent ClassPool fails to find a class file, then the child ClassPool attempts to find a class file under the ./classes directory.</p>\n<p>如果 child.childFirstLookup 被设置为true的话, child ClassPool就会首先尝试尝试查找class文件, 找不到再去上一级ClassPool中查找. 例如:</p>\n<p>If child.childFirstLookup is true, the child ClassPool attempts to find a class file before delegating to the parent ClassPool. For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool parent = ClassPool.getDefault();</span><br><span class=\"line\">ClassPool child = <span class=\"keyword\">new</span> ClassPool(parent);</span><br><span class=\"line\">child.appendSystemPath();         <span class=\"comment\">// the same class path as the default one.</span></span><br><span class=\"line\">child.childFirstLookup = <span class=\"keyword\">true</span>;    <span class=\"comment\">// changes the behavior of the child.</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Changing-a-class-name-for-defining-a-new-class\"><a href=\"#Changing-a-class-name-for-defining-a-new-class\" class=\"headerlink\" title=\"Changing a class name for defining a new class\"></a>Changing a class name for defining a new class</h2><p>A new class can be defined as a copy of an existing class. The program below does that:</p>\n<p>一个新的class可以通过从已经存在的class的副本中制作出来. 例如L</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">cc.setName(<span class=\"string\">\"Pair\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面的程序首先获得了Point对应的CtClass对象. 然后它调用setName()设置了一个新的名称Pair. setName()被调用之后, CtClass对象中的所有该class 名称都从Point转换成了Pair. 但是class 定义的其他部分并没有变.</p>\n<p>This program first obtains the CtClass object for class Point. Then it calls setName() to give a new name Pair to that CtClass object. After this call, all occurrences of the class name in the class definition represented by that CtClass object are changed from Point to Pair. The other part of the class definition does not change.</p>\n<p>注意CtClass的setName()也会改变ClassPool中的记录. 从实现角度来说, 一个CLassPool对象就是CtClass对象的一个hash表. setName()也会将hash表中和CtClass对象关联的key也更改掉. key从原先的class名称换到了新的class名称.<br>Note that setName() in CtClass changes a record in the ClassPool object. From the implementation viewpoint, a ClassPool object is a hash table of CtClass objects. setName() changes the key associated to the CtClass object in the hash table. The key is changed from the original class name to the new class name.</p>\n<p>因此, 如果再次调用ClassPool的get(“Point”)方法, 再也不会返回cc所指向的CtClass对象. ClassPool会再次读取Point.class文件, 然后构建出一个新的Point的CtClass对象出来. 这厮因为和Point名称关联的CtClass对象已经不复存在了. 例如:</p>\n<p>Therefore, if get(“Point”) is later called on the ClassPool object again, then it never returns the CtClass object that the variable cc refers to. The ClassPool object reads a class file Point.class again and it constructs a new CtClass object for class Point. This is because the CtClass object associated with the name Point does not exist any more. See the followings:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtClass cc1 = pool.get(<span class=\"string\">\"Point\"</span>);   <span class=\"comment\">// cc1 is identical to cc.</span></span><br><span class=\"line\">cc.setName(<span class=\"string\">\"Pair\"</span>);</span><br><span class=\"line\">CtClass cc2 = pool.get(<span class=\"string\">\"Pair\"</span>);    <span class=\"comment\">// cc2 is identical to cc.</span></span><br><span class=\"line\">CtClass cc3 = pool.get(<span class=\"string\">\"Point\"</span>);   <span class=\"comment\">// cc3 is not identical to cc.</span></span><br></pre></td></tr></table></figure>\n\n<p>cc1和cc2指向的是和cc指向的相同的对象, 而cc3则不是. 注意, cc.setName(“Pair”) 方法执行之后, cc和cc1指向CtClass对象也代表着Pair class.<br>cc1 and cc2 refer to the same instance of CtClass that cc does whereas cc3 does not. Note that, after cc.setName(“Pair”) is executed, the CtClass object that cc and cc1 refer to represents the Pair class.</p>\n<p>ClassPool对象被用来维持class和CtClass对象之间的一对一映射. 在同一个ClassPool中, Javassist从不允许俩个不同的CtClass对象代表同一个class. 对于程序转换来说, 这是一个非常有意义的特性.</p>\n<p>The ClassPool object is used to maintain one-to-one mapping between classes and CtClass objects. Javassist never allows two distinct CtClass objects to represent the same class unless two independent ClassPool are created. This is a significant feature for consistent program transformation.</p>\n<p>如果你有俩个ClassPool对象, 那么你可以从每个ClassPool里面获得一个相同的class的CtClass对象. 你可以通过修改不同的CtClass对象生成不同版本的class.</p>\n<p>If you have two ClassPool objects, then you can obtain, from each ClassPool, a distinct CtClass object representing the same class file. You can differently modify these CtClass objects to generate different versions of the class.</p>\n<h2 id=\"Renaming-a-frozen-class-for-defining-a-new-class\"><a href=\"#Renaming-a-frozen-class-for-defining-a-new-class\" class=\"headerlink\" title=\"Renaming a frozen class for defining a new class\"></a>Renaming a frozen class for defining a new class</h2><p>一旦一个CtClass对象通过writeFile() or toBytecode()方法转换成一个class, Javassist就不允许CtClass对象再次修改了. 因此, 当代表Point的CtClass对象被转换成一个class之后, 你就不能再通过设置setName()的方式来获取一个Point的副本Pair了. 例如下面的代码, 是不合法的.</p>\n<p>Once a CtClass object is converted into a class file by writeFile() or toBytecode(), Javassist rejects further modifications of that CtClass object. Hence, after the CtClass object representing Point class is converted into a class file, you cannot define Pair class as a copy of Point since executing setName() on Point is rejected. The following code snippet is wrong:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">cc.writeFile();</span><br><span class=\"line\">cc.setName(<span class=\"string\">\"Pair\"</span>);    <span class=\"comment\">// wrong since writeFile() has been called.</span></span><br></pre></td></tr></table></figure>\n\n<p>To avoid this restriction, you should call getAndRename() in ClassPool. For example,</p>\n<p>对于这种限制, 你应该调用ClassPool的getAndRename()方法, 例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">cc.writeFile();</span><br><span class=\"line\">CtClass cc2 = pool.getAndRename(<span class=\"string\">\"Point\"</span>, <span class=\"string\">\"Pair\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>getAndRename()被调用之后, ClassPool首先读取Point.class, 然后创建出一个代表Point class的CtClass对象. 在存储ClassPool的hash表之前, 它将CtClass名称从Point重新命名为Pair. 因此, getAndRename() 可以再writeFile() or toBytecode()被调用之后 再次调用.</p>\n<p>If getAndRename() is called, the ClassPool first reads Point.class for creating a new CtClass object representing Point class. However, it renames that CtClass object from Point to Pair before it records that CtClass object in a hash table. Thus getAndRename() can be executed after writeFile() or toBytecode() is called on the the CtClass object representing Point class.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>A ClassPool object is a container of CtClass objects. Once a CtClass object is created, it is recorded in a ClassPool for ever. This is because a compiler may need to access the CtClass object later when it compiles source code that refers to the class represented by that CtClass.</p>\n<p><code>ClassPool</code>对象是CtClass对象的集合. 一旦CtClass对象被创建出来, 它就会被永远地保存在ClassPool中. 这是因为编译器在编译源码的时候可能还需要访问这些CtClass对象.</p>\n<p>For example, suppose that a new method getter() is added to a CtClass object representing Point class. Later, the program attempts to compile source code including a method call to getter() in Point and use the compiled code as the body of a method, which will be added to another class Line. If the CtClass object representing Point is lost, the compiler cannot compile the method call to getter(). Note that the original class definition does not include getter(). Therefore, to correctly compile such a method call, the ClassPool must contain all the instances of CtClass all the time of program execution.</p>\n<p>例如, 向Point类的CtClass对象添加一个新的getter()方法. 然后程序将某段调用Point的getter()方法的源码片段进行编译, 然后将编译好的代码片段放到另外一个类里. 如果找不到代表Point的CtClass的话, 编译器就没办法编译对getter()方法的调用. 注意, 原先的class是不包含getter()方法的. 因此, 为了能正确进行编译, 在程序运行期间, ClassPool必须包含全部的CtClass实例.</p>\n<h2 id=\"Avoid-out-of-memory\"><a href=\"#Avoid-out-of-memory\" class=\"headerlink\" title=\"Avoid out of memory\"></a>Avoid out of memory</h2><p>This specification of ClassPool may cause huge memory consumption if the number of CtClass objects becomes amazingly large (this rarely happens since Javassist tries to reduce memory consumption in various ways). To avoid this problem, you can explicitly remove an unnecessary CtClass object from the ClassPool. If you call detach() on a CtClass object, then that CtClass object is removed from the ClassPool. For example,</p>\n<p>按照上文描述的那样, 如果CtClass实例数量飞速增长的话, ClassPool就有可能会引起巨大的内存消耗(但是实际上这种情况很少发生, 因此Javassist会通过多种方式减少内存消耗). 为了解决这种问题, 你可以显式地从ClassPool里面删除不需要的CtClass实例. 如果你在CtClass对象上调用detach()方法的, 该对象就会从ClassPool里面移除. 例如: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass cc = ... ;</span><br><span class=\"line\">cc.writeFile();</span><br><span class=\"line\">cc.detach();</span><br></pre></td></tr></table></figure>\n\n<p>当 detach() 方法被调用之后, CtClass实例的其他方法就不再允许被调用. 但是你可以接着调用ClassPool的get()方法, 再获得一个相同class的新的CtClass实例. 如果你调用了<code>get()</code>方法, ClassPool会重新读取class 文件, 然后再创建一个新的CtClass对象.</p>\n<p>You must not call any method on that CtClass object after detach() is called. However, you can call get() on ClassPool to make a new instance of CtClass representing the same class. If you call get(), the ClassPool reads a class file again and newly creates a CtClass object, which is returned by get().</p>\n<p>另一种思路是再重新创建一个ClassPool, 然后将旧的那个舍弃掉. 如果旧的ClassPool被gc掉了, 那么原先ClassPool里的CtClass对象也都被gc掉了. 如果要创建一个新的ClassPool实例, 执行下面的代码即可:</p>\n<p>Another idea is to occasionally replace a ClassPool with a new one and discard the old one. If an old ClassPool is garbage collected, the CtClass objects included in that ClassPool are also garbage collected. To create a new instance of ClassPool, execute the following code snippet:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool cp = <span class=\"keyword\">new</span> ClassPool(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// if needed, append an extra search path by appendClassPath()</span></span><br></pre></td></tr></table></figure>\n\n<p>刚才创建的ClassPool的行为和通过调用ClassPool.getDefault()返回的默认ClassPool是一样的. 注意ClassPool.getDefault()是出于便捷目的而存在的一个单例工厂方法. ClassPool.getDefault() 会像上面那样创建一个ClassPool 对象, 然后作为单例存在, 一直复用它. 通过getDefault()返回的ClassPool并没有特殊的规则. getDefault() 只是一个快捷方法.</p>\n<p>This creates a ClassPool object that behaves as the default ClassPool returned by ClassPool.getDefault() does. Note that ClassPool.getDefault() is a singleton factory method provided for convenience. It creates a ClassPool object in the same way shown above although it keeps a single instance of ClassPool and reuses it. A ClassPool object returned by getDefault() does not have a special role. getDefault() is a convenience method.</p>\n<p>注意 new ClassPool(true) 是一个快捷构造器,  它只是构建了一个ClassPool对象, 然后将系统搜索路径添加到这上面. 该构造器方法和下面方法等同.<br>Note that new ClassPool(true) is a convenient constructor, which constructs a ClassPool object and appends the system search path to it. Calling that constructor is equivalent to the following code:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool cp = <span class=\"keyword\">new</span> ClassPool();</span><br><span class=\"line\">cp.appendSystemPath();  <span class=\"comment\">// or append another path by appendClassPath()</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Cascaded-ClassPools\"><a href=\"#Cascaded-ClassPools\" class=\"headerlink\" title=\"Cascaded ClassPools\"></a>Cascaded ClassPools</h2><p>如果应用程序是运行在一个web 服务器上, 那么就有可能需要创建多个ClassPool实例. 每个class Loader都需要创建一个ClassPool实例. 在这种背景下, 就需要通过ClassPool的构造器创建ClassPool实例, 而不能再通过getDefault()方法获得了.</p>\n<p>If a program is running on a web application server, creating multiple instances of ClassPool might be necessary; an instance of ClassPool should be created for each class loader (i.e. container). The program should create a ClassPool object by not calling getDefault() but a constructor of ClassPool.</p>\n<p>Multiple ClassPool objects can be cascaded like java.lang.ClassLoader. For example,</p>\n<p>多个ClassPool对象可以像java.lang.ClassLoader那样呗级联起来. 例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool parent = ClassPool.getDefault();</span><br><span class=\"line\">ClassPool child = <span class=\"keyword\">new</span> ClassPool(parent);</span><br><span class=\"line\">child.insertClassPath(<span class=\"string\">\"./classes\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果child.get()方法被调用, child ClassPool首先将该请求委托给上一级ClassPool. 如果上一级ClassPool没有找到目标class文件, 那么child ClassPool就会尝试在./classes目录里查找class文件.</p>\n<p>If child.get() is called, the child ClassPool first delegates to the parent ClassPool. If the parent ClassPool fails to find a class file, then the child ClassPool attempts to find a class file under the ./classes directory.</p>\n<p>如果 child.childFirstLookup 被设置为true的话, child ClassPool就会首先尝试尝试查找class文件, 找不到再去上一级ClassPool中查找. 例如:</p>\n<p>If child.childFirstLookup is true, the child ClassPool attempts to find a class file before delegating to the parent ClassPool. For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool parent = ClassPool.getDefault();</span><br><span class=\"line\">ClassPool child = <span class=\"keyword\">new</span> ClassPool(parent);</span><br><span class=\"line\">child.appendSystemPath();         <span class=\"comment\">// the same class path as the default one.</span></span><br><span class=\"line\">child.childFirstLookup = <span class=\"keyword\">true</span>;    <span class=\"comment\">// changes the behavior of the child.</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Changing-a-class-name-for-defining-a-new-class\"><a href=\"#Changing-a-class-name-for-defining-a-new-class\" class=\"headerlink\" title=\"Changing a class name for defining a new class\"></a>Changing a class name for defining a new class</h2><p>A new class can be defined as a copy of an existing class. The program below does that:</p>\n<p>一个新的class可以通过从已经存在的class的副本中制作出来. 例如L</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">cc.setName(<span class=\"string\">\"Pair\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面的程序首先获得了Point对应的CtClass对象. 然后它调用setName()设置了一个新的名称Pair. setName()被调用之后, CtClass对象中的所有该class 名称都从Point转换成了Pair. 但是class 定义的其他部分并没有变.</p>\n<p>This program first obtains the CtClass object for class Point. Then it calls setName() to give a new name Pair to that CtClass object. After this call, all occurrences of the class name in the class definition represented by that CtClass object are changed from Point to Pair. The other part of the class definition does not change.</p>\n<p>注意CtClass的setName()也会改变ClassPool中的记录. 从实现角度来说, 一个CLassPool对象就是CtClass对象的一个hash表. setName()也会将hash表中和CtClass对象关联的key也更改掉. key从原先的class名称换到了新的class名称.<br>Note that setName() in CtClass changes a record in the ClassPool object. From the implementation viewpoint, a ClassPool object is a hash table of CtClass objects. setName() changes the key associated to the CtClass object in the hash table. The key is changed from the original class name to the new class name.</p>\n<p>因此, 如果再次调用ClassPool的get(“Point”)方法, 再也不会返回cc所指向的CtClass对象. ClassPool会再次读取Point.class文件, 然后构建出一个新的Point的CtClass对象出来. 这厮因为和Point名称关联的CtClass对象已经不复存在了. 例如:</p>\n<p>Therefore, if get(“Point”) is later called on the ClassPool object again, then it never returns the CtClass object that the variable cc refers to. The ClassPool object reads a class file Point.class again and it constructs a new CtClass object for class Point. This is because the CtClass object associated with the name Point does not exist any more. See the followings:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtClass cc1 = pool.get(<span class=\"string\">\"Point\"</span>);   <span class=\"comment\">// cc1 is identical to cc.</span></span><br><span class=\"line\">cc.setName(<span class=\"string\">\"Pair\"</span>);</span><br><span class=\"line\">CtClass cc2 = pool.get(<span class=\"string\">\"Pair\"</span>);    <span class=\"comment\">// cc2 is identical to cc.</span></span><br><span class=\"line\">CtClass cc3 = pool.get(<span class=\"string\">\"Point\"</span>);   <span class=\"comment\">// cc3 is not identical to cc.</span></span><br></pre></td></tr></table></figure>\n\n<p>cc1和cc2指向的是和cc指向的相同的对象, 而cc3则不是. 注意, cc.setName(“Pair”) 方法执行之后, cc和cc1指向CtClass对象也代表着Pair class.<br>cc1 and cc2 refer to the same instance of CtClass that cc does whereas cc3 does not. Note that, after cc.setName(“Pair”) is executed, the CtClass object that cc and cc1 refer to represents the Pair class.</p>\n<p>ClassPool对象被用来维持class和CtClass对象之间的一对一映射. 在同一个ClassPool中, Javassist从不允许俩个不同的CtClass对象代表同一个class. 对于程序转换来说, 这是一个非常有意义的特性.</p>\n<p>The ClassPool object is used to maintain one-to-one mapping between classes and CtClass objects. Javassist never allows two distinct CtClass objects to represent the same class unless two independent ClassPool are created. This is a significant feature for consistent program transformation.</p>\n<p>如果你有俩个ClassPool对象, 那么你可以从每个ClassPool里面获得一个相同的class的CtClass对象. 你可以通过修改不同的CtClass对象生成不同版本的class.</p>\n<p>If you have two ClassPool objects, then you can obtain, from each ClassPool, a distinct CtClass object representing the same class file. You can differently modify these CtClass objects to generate different versions of the class.</p>\n<h2 id=\"Renaming-a-frozen-class-for-defining-a-new-class\"><a href=\"#Renaming-a-frozen-class-for-defining-a-new-class\" class=\"headerlink\" title=\"Renaming a frozen class for defining a new class\"></a>Renaming a frozen class for defining a new class</h2><p>一旦一个CtClass对象通过writeFile() or toBytecode()方法转换成一个class, Javassist就不允许CtClass对象再次修改了. 因此, 当代表Point的CtClass对象被转换成一个class之后, 你就不能再通过设置setName()的方式来获取一个Point的副本Pair了. 例如下面的代码, 是不合法的.</p>\n<p>Once a CtClass object is converted into a class file by writeFile() or toBytecode(), Javassist rejects further modifications of that CtClass object. Hence, after the CtClass object representing Point class is converted into a class file, you cannot define Pair class as a copy of Point since executing setName() on Point is rejected. The following code snippet is wrong:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">cc.writeFile();</span><br><span class=\"line\">cc.setName(<span class=\"string\">\"Pair\"</span>);    <span class=\"comment\">// wrong since writeFile() has been called.</span></span><br></pre></td></tr></table></figure>\n\n<p>To avoid this restriction, you should call getAndRename() in ClassPool. For example,</p>\n<p>对于这种限制, 你应该调用ClassPool的getAndRename()方法, 例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">cc.writeFile();</span><br><span class=\"line\">CtClass cc2 = pool.getAndRename(<span class=\"string\">\"Point\"</span>, <span class=\"string\">\"Pair\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>getAndRename()被调用之后, ClassPool首先读取Point.class, 然后创建出一个代表Point class的CtClass对象. 在存储ClassPool的hash表之前, 它将CtClass名称从Point重新命名为Pair. 因此, getAndRename() 可以再writeFile() or toBytecode()被调用之后 再次调用.</p>\n<p>If getAndRename() is called, the ClassPool first reads Point.class for creating a new CtClass object representing Point class. However, it renames that CtClass object from Point to Pair before it records that CtClass object in a hash table. Thus getAndRename() can be executed after writeFile() or toBytecode() is called on the the CtClass object representing Point class.</p>\n"},{"title":"Javasist Introspection and customization","date":"2019-05-04T12:15:00.000Z","_content":"\n`CtClass`提供了方法以便于自省. Javassist 的自省能力和Java的反射API很像. CtClass 提供了getName(), getSuperclass(), getMethods()等方法. CtClass仍然提供了修改一个类定义的方法.它允许添加新的字段/构造器/方法. 修改(Instrumenting)方法体也是可以的.\n\nCtClass provides methods for introspection. The introspective ability of Javassist is compatible with that of the Java reflection API. CtClass provides getName(), getSuperclass(), getMethods(), and so on. CtClass also provides methods for modifying a class definition. It allows to add a new field, constructor, and method. Instrumenting a method body is also possible.\n\nCtMethod实例表示方法. CtMethod提供了一些方法用来修改方法的定义. 注意, 如果一个方法是继承而来的, 那么子类和基类的这个方法是由同一个CtMethod对象表示. 一个CtMethod对象对应一个方法的声明.\n\nMethods are represented by CtMethod objects. CtMethod provides several methods for modifying the definition of the method. Note that if a method is inherited from a super class, then the same CtMethod object that represents the inherited method represents the method declared in that super class. A CtMethod object corresponds to every method declaration.\n\n例如, 如果类Point声明了一个方法`move()`, 它的子类`ColorPoint`没有重载`move()`方法, 在Point中声明的move()方法和在子类`ColorPoint`中继承过来的move()方法是由同一个CtMethod对象表示的. 如果CtMethod对象所表示的方法被修改了, 那么父类和子类的方法都会被修改. 如果你只想修改ColorPoint的`move()`方法, 你首席必须得把Point里的move()方法制作一个副本, 然后将这个副本添加到ColorPoint里. 可以通过调用CtNewMethod.copy()得到一个CtMethod对象的副本.\n\nFor example, if class Point declares method move() and a subclass ColorPoint of Point does not override move(), the two move() methods declared in Point and inherited in ColorPoint are represented by the identical CtMethod object. If the method definition represented by this CtMethod object is modified, the modification is reflected on both the methods. If you want to modify only the move() method in ColorPoint, you first have to add to ColorPoint a copy of the CtMethod object representing move() in Point. A copy of the the CtMethod object can be obtained by CtNewMethod.copy().\n\nJavassist不允许删除一个方法或者字段, 但是允许修改它的名字. 索引, 如果一个方法不再需要了, 应该调用CtMethod的setName()将其重命名以及setModifiers()修改它的访问级别到一个私有方法.\n\nJavassist does not allow to remove a method or field, but it allows to change the name. So if a method is not necessary any more, it should be renamed and changed to be a private method by calling setName() and setModifiers() declared in CtMethod.\n\nJavassist也不允许向一个已经存在的方法添加一个新的参数. 但是, 可以向相同的class里增加一个新的方法, 该方法在老的方法接口上增加新的参数. 例如, 如果你想要在一个方法上添加一个newZ参数:\n\nJavassist does not allow to add an extra parameter to an existing method, either. Instead of doing that, a new method receiving the extra parameter as well as the other parameters should be added to the same class. For example, if you want to add an extra int parameter newZ to a method:\n\n```java\nvoid move(int newX, int newY) { x = newX; y = newY; }\n```\nin a Point class, then you should add the following method to the Point class:\n\n在Point类中, 你应该添加一个新的方法:\n```java\nvoid move(int newX, int newY, int newZ) {\n    // do what you want with newZ.\n    move(newX, newY);\n}\n```\n\nJavassist也提供了一些底层API用于修改一个原始的类结构. 例如, CtClass中的getClassFile()返回了一个表示原始类结构的ClassFile对象.CtMethod 中的 getMethodInfo() 返回了一个MethodInfo对象, 该对象表示的类结构中的一个method_info结构. 底层API使用了Java Virtual Machine规范中的词汇. 使用者必须有class文件和字节码的知识. 更多的细节, 使用者应该参考`javassist.bytecode`包下的内容.\n\nJavassist also provides low-level API for directly editing a raw class file. For example, getClassFile() in CtClass returns a ClassFile object representing a raw class file. getMethodInfo() in CtMethod returns a MethodInfo object representing a method_info structure included in a class file. The low-level API uses the vocabulary from the Java Virtual machine specification. The users must have the knowledge about class files and bytecode. For more details, the users should see the javassist.bytecode package.\n\n\n\nThe class files modified by Javassist requires the javassist.runtime package for runtime support only if some special identifiers starting with $ are used. Those special identifiers are described below. The class files modified without those special identifiers do not need the javassist.runtime package or any other Javassist packages at runtime. For more details, see the API documentation of the javassist.runtime package.\n\n\n\n## 4.1 Inserting source text at the beginning/end of a method body\n\nCtMethod and CtConstructor 中提供了insertBefore(), insertAfter(), and addCatch() 这三个方法. 这些方法用于向一个已经存在的方法中添加代码片段. 这些代码片段可以试Java代码. Javassist包含了一个简单的Java编译器用来编译这些Java源码. 该编译器接受Java语言编写的源代码, 然后将其编译成Java字节码, 然后将其内联到一个方法体中. \n\nCtMethod and CtConstructor provide methods insertBefore(), insertAfter(), and addCatch(). They are used for inserting a code fragment into the body of an existing method. The users can specify those code fragments with source text written in Java. Javassist includes a simple Java compiler for processing source text. It receives source text written in Java and compiles it into Java bytecode, which will be inlined into a method body.\n\n如果class文件中包含了line number表的话, 可以在指定的line number中插入一个代码片段.\n\nInserting a code fragment at the position specified by a line number is also possible (if the line number table is contained in the class file). insertAt() in CtMethod and CtConstructor takes source text and a line number in the source file of the original class definition. It compiles the source text and inserts the compiled code at the line number.\n\nThe methods insertBefore(), insertAfter(), addCatch(), and insertAt() receive a String object representing a statement or a block. A statement is a single control structure like if and while or an expression ending with a semi colon (;). A block is a set of statements surrounded with braces {}. Hence each of the following lines is an example of valid statement or block:\n\n```java\nSystem.out.println(\"Hello\");\n{ System.out.println(\"Hello\"); }\nif (i < 0) { i = -i; }\n```\n\nThe statement and the block can refer to fields and methods. They can also refer to the parameters to the method that they are inserted into if that method was compiled with the -g option (to include a local variable attribute in the class file). Otherwise, they must access the method parameters through the special variables $0, $1, $2, ... described below. Accessing local variables declared in the method is not allowed although declaring a new local variable in the block is allowed. However, insertAt() allows the statement and the block to access local variables if these variables are available at the specified line number and the target method was compiled with the -g option.\nThe String object passed to the methods insertBefore(), insertAfter(), addCatch(), and insertAt() are compiled by the compiler included in Javassist. Since the compiler supports language extensions, several identifiers starting with $ have special meaning:\n\n* `$0, $1, $2, ...`    \tthis and actual parameters\n* `$args`\tAn array of parameters. The type of $args is Object[].\n* `$$`\tAll actual parameters. For example, m($$) is equivalent to m($1,$2,...)\n* `$cflow(...)`\tcflow variable\n* `$r`\tThe result type. It is used in a cast expression.\n* `$w`\tThe wrapper type. It is used in a cast expression.\n* `$_`\tThe resulting value\n* `$sig`\tAn array of java.lang.Class objects representing the formal parameter types.\n* `$type`\tA java.lang.Class object representing the formal result type.\n* `$class`\tA java.lang.Class object representing the class currently edited.\n\n#### $0, $1, $2, ...\nThe parameters passed to the target method are accessible with $1, $2, ... instead of the original parameter names. $1 represents the first parameter, $2 represents the second parameter, and so on. The types of those variables are identical to the parameter types. $0 is equivalent to this. If the method is static, $0 is not available.\n\nThese variables are used as following. Suppose that a class Point:\n```java\nclass Point {\n    int x, y;\n    void move(int dx, int dy) { x += dx; y += dy; }\n}\n```\nTo print the values of dx and dy whenever the method move() is called, execute this program:\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"Point\");\nCtMethod m = cc.getDeclaredMethod(\"move\");\nm.insertBefore(\"{ System.out.println($1); System.out.println($2); }\");\ncc.writeFile();\n```\nNote that the source text passed to insertBefore() is surrounded with braces {}. insertBefore() accepts only a single statement or a block surrounded with braces.\n\nThe definition of the class Point after the modification is like this:\n```java\nclass Point {\n    int x, y;\n    void move(int dx, int dy) {\n        { System.out.println(dx); System.out.println(dy); }\n        x += dx; y += dy;\n    }\n}\n```\n$1 and $2 are replaced with dx and dy, respectively.\n\n$1, $2, $3 ... are updatable. If a new value is assigend to one of those variables, then the value of the parameter represented by that variable is also updated.\n\n#### $args\nThe variable $args represents an array of all the parameters. The type of that variable is an array of class Object. If a parameter type is a primitive type such as int, then the parameter value is converted into a wrapper object such as java.lang.Integer to store in $args. Thus, $args[0] is equivalent to $1 unless the type of the first parameter is a primitive type. Note that $args[0] is not equivalent to $0; $0 represents this.\n\nIf an array of Object is assigned to $args, then each element of that array is assigned to each parameter. If a parameter type is a primitive type, the type of the corresponding element must be a wrapper type. The value is converted from the wrapper type to the primitive type before it is assigned to the parameter.\n\n#### $$\nThe variable $$ is abbreviation of a list of all the parameters separated by commas. For example, if the number of the parameters to method move() is three, then\n\n```java\nmove($$)\n```\nis equivalent to this:\n```java\nmove($1, $2, $3)\n```\nIf move() does not take any parameters, then move($$) is equivalent to move().\n\n$$ can be used with another method. If you write an expression:\n\n```java\nexMove($$, context)\n```\nthen this expression is equivalent to:\n\n```java\nexMove($1, $2, $3, context)\n```\nNote that $$ enables generic notation of method call with respect to the number of parameters. It is typically used with $proceed shown later.\n\n#### $cflow\n$cflow means \"control flow\". This read-only variable returns the depth of the recursive calls to a specific method.\n\nSuppose that the method shown below is represented by a CtMethod object cm:\n\n```java\nint fact(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return n * fact(n - 1);\n}\n```\n\nTo use $cflow, first declare that $cflow is used for monitoring calls to the method fact():\n\n```java\nCtMethod cm = ...;\ncm.useCflow(\"fact\");\n```\n\nThe parameter to useCflow() is the identifier of the declared $cflow variable. Any valid Java name can be used as the identifier. Since the identifier can also include . (dot), for example, \"my.Test.fact\" is a valid identifier.\n\nThen, $cflow(fact) represents the depth of the recursive calls to the method specified by cm. The value of $cflow(fact) is 0 (zero) when the method is first called whereas it is 1 when the method is recursively called within the method. For example,\n\n```java\ncm.insertBefore(\"if ($cflow(fact) == 0)\"\n              + \"    System.out.println(\\\"fact \\\" + $1);\");\n```\ntranslates the method fact() so that it shows the parameter. Since the value of $cflow(fact) is checked, the method fact() does not show the parameter if it is recursively called within fact().\n\nThe value of $cflow is the number of stack frames associated with the specified method cm under the current topmost stack frame for the current thread. $cflow is also accessible within a method different from the specified method cm.\n\n#### $r\n$r represents the result type (return type) of the method. It must be used as the cast type in a cast expression. For example, this is a typical use:\n\n```java\nObject result = ... ;\n$_ = ($r)result;\n```\n\nIf the result type is a primitive type, then ($r) follows special semantics. First, if the operand type of the cast expression is a primitive type, ($r) works as a normal cast operator to the result type. On the other hand, if the operand type is a wrapper type, ($r) converts from the wrapper type to the result type. For example, if the result type is int, then ($r) converts from java.lang.Integer to int.\n\nIf the result type is void, then ($r) does not convert a type; it does nothing. However, if the operand is a call to a void method, then ($r) results in null. For example, if the result type is void and foo() is a void method, then\n\n```java\n$_ = ($r)foo();\n```\nis a valid statement.\n\nThe cast operator ($r) is also useful in a return statement. Even if the result type is void, the following return statement is valid:\n\n```java\nreturn ($r)result;\n```\nHere, result is some local variable. Since ($r) is specified, the resulting value is discarded. This return statement is regarded as the equivalent of the return statement without a resulting value:\n```java\nreturn;\n```\n\n#### $w\n$w represents a wrapper type. It must be used as the cast type in a cast expression. ($w) converts from a primitive type to the corresponding wrapper type. The following code is an example:\n\n```java\nInteger i = ($w)5;\n```\nThe selected wrapper type depends on the type of the expression following ($w). If the type of the expression is double, then the wrapper type is java.lang.Double.\n\nIf the type of the expression following ($w) is not a primitive type, then ($w) does nothing.\n\n#### $_\ninsertAfter() in CtMethod and CtConstructor inserts the compiled code at the end of the method. In the statement given to insertAfter(), not only the variables shown above such as $0, $1, ... but also $_ is available.\n\nThe variable $_ represents the resulting value of the method. The type of that variable is the type of the result type (the return type) of the method. If the result type is void, then the type of $_ is Object and the value of $_ is null.\n\nAlthough the compiled code inserted by insertAfter() is executed just before the control normally returns from the method, it can be also executed when an exception is thrown from the method. To execute it when an exception is thrown, the second parameter asFinally to insertAfter() must be true.\n\nIf an exception is thrown, the compiled code inserted by insertAfter() is executed as a finally clause. The value of $_ is 0 or null in the compiled code. After the execution of the compiled code terminates, the exception originally thrown is re-thrown to the caller. Note that the value of $_ is never thrown to the caller; it is rather discarded.\n\n#### $sig\nThe value of $sig is an array of java.lang.Class objects that represent the formal parameter types in declaration order.\n\n#### $type\nThe value of $type is an java.lang.Class object representing the formal type of the result value. This variable refers to Void.class if this is a constructor.\n\n#### $class\nThe value of $class is an java.lang.Class object representing the class in which the edited method is declared. This represents the type of $0.\n\n#### addCatch()\naddCatch() inserts a code fragment into a method body so that the code fragment is executed when the method body throws an exception and the control returns to the caller. In the source text representing the inserted code fragment, the exception value is referred to with the special variable $e.\n\nFor example, this program:\n```java\nCtMethod m = ...;\nCtClass etype = ClassPool.getDefault().get(\"java.io.IOException\");\nm.addCatch(\"{ System.out.println($e); throw $e; }\", etype);\ntranslates the method body represented by m into something like this:\n\ntry {\n    the original method body\n}\ncatch (java.io.IOException e) {\n    System.out.println(e);\n    throw e;\n}\n```\nNote that the inserted code fragment must end with a throw or return statement.\n\n\n\n## 4.2 Altering a method body\nCtMethod and CtConstructor provide setBody() for substituting a whole method body. They compile the given source text into Java bytecode and substitutes it for the original method body. If the given source text is null, the substituted body includes only a return statement, which returns zero or null unless the result type is void.\n\nIn the source text given to setBody(), the identifiers starting with $ have special meaning\n\n* `$0, $1, $2, ...`    \tthis and actual parameters\n* `$args`\tAn array of parameters. The type of $args is Object[].\n* `$$`\tAll actual parameters.\n* `$cflow(...)`\tcflow variable\n* `$r`\tThe result type. It is used in a cast expression.\n* `$w`\tThe wrapper type. It is used in a cast expression.\n* `$sig`\tAn array of java.lang.Class objects representing the formal parameter types.\n* `$type`\tA java.lang.Class object representing the formal result type.\n* `$class`\tA java.lang.Class object representing the class that declares the method\ncurrently edited (the type of $0).\n \nNote that $_ is not available.\n\n### Substituting source text for an existing expression\nJavassist allows modifying only an expression included in a method body. javassist.expr.ExprEditor is a class for replacing an expression in a method body. The users can define a subclass of ExprEditor to specify how an expression is modified.\n\nTo run an ExprEditor object, the users must call instrument() in CtMethod or CtClass. For example,\n\n```java\nCtMethod cm = ... ;\ncm.instrument(\n    new ExprEditor() {\n        public void edit(MethodCall m)\n                      throws CannotCompileException\n        {\n            if (m.getClassName().equals(\"Point\")\n                          && m.getMethodName().equals(\"move\"))\n                m.replace(\"{ $1 = 0; $_ = $proceed($$); }\");\n        }\n    });\n```\n\nsearches the method body represented by cm and replaces all calls to move() in class Point with a block:\n\n```java\n{ $1 = 0; $_ = $proceed($$); }\n```\nso that the first parameter to move() is always 0. Note that the substituted code is not an expression but a statement or a block. It cannot be or contain a try-catch statement.\n\nThe method instrument() searches a method body. If it finds an expression such as a method call, field access, and object creation, then it calls edit() on the given ExprEditor object. The parameter to edit() is an object representing the found expression. The edit() method can inspect and replace the expression through that object.\n\nCalling replace() on the parameter to edit() substitutes the given statement or block for the expression. If the given block is an empty block, that is, if replace(\"{}\") is executed, then the expression is removed from the method body. If you want to insert a statement (or a block) before/after the expression, a block like the following should be passed to replace():\n\n```java\n{ before-statements;\n  $_ = $proceed($$);\n  after-statements; }\n```\nwhichever the expression is either a method call, field access, object creation, or others. The second statement could be:\n\n```java\n$_ = $proceed();\n```\nif the expression is read access, or\n\n```java\n$proceed($$);\n```\nif the expression is write access.\n\nLocal variables available in the target expression is also available in the source text passed to replace() if the method searched by instrument() was compiled with the -g option (the class file includes a local variable attribute).\n\n### javassist.expr.MethodCall\nA MethodCall object represents a method call. The method replace() in MethodCall substitutes a statement or a block for the method call. It receives source text representing the substitued statement or block, in which the identifiers starting with $ have special meaning as in the source text passed to insertBefore().\n\n$0\tThe target object of the method call.\nThis is not equivalent to this, which represents the caller-side this object.\n$0 is null if the method is static.\n \n \n$1, $2, ...    \tThe parameters of the method call.\n$_\tThe resulting value of the method call.\n$r\tThe result type of the method call.\n$class    \tA java.lang.Class object representing the class declaring the method.\n$sig    \tAn array of java.lang.Class objects representing the formal parameter types.\n$type    \tA java.lang.Class object representing the formal result type.\n$proceed    \tThe name of the method originally called in the expression.\nHere the method call means the one represented by the MethodCall object.\n\nThe other identifiers such as $w, $args and $$ are also available.\n\nUnless the result type of the method call is void, a value must be assigned to $_ in the source text and the type of $_ is the result type. If the result type is void, the type of $_ is Object and the value assigned to $_ is ignored.\n\n$proceed is not a String value but special syntax. It must be followed by an argument list surrounded by parentheses ( ).\n\n### javassist.expr.ConstructorCall\nA ConstructorCall object represents a constructor call such as this() and super included in a constructor body. The method replace() in ConstructorCall substitutes a statement or a block for the constructor call. It receives source text representing the substituted statement or block, in which the identifiers starting with $ have special meaning as in the source text passed to insertBefore().\n\n$0\tThe target object of the constructor call. This is equivalent to this.\n$1, $2, ...    \tThe parameters of the constructor call.\n$class    \tA java.lang.Class object representing the class declaring the constructor.\n$sig    \tAn array of java.lang.Class objects representing the formal parameter types.\n$proceed    \tThe name of the constructor originally called in the expression.\nHere the constructor call means the one represented by the ConstructorCall object.\n\nThe other identifiers such as $w, $args and $$ are also available.\n\nSince any constructor must call either a constructor of the super class or another constructor of the same class, the substituted statement must include a constructor call, normally a call to $proceed().\n\n$proceed is not a String value but special syntax. It must be followed by an argument list surrounded by parentheses ( ).\n\n### javassist.expr.FieldAccess\nA FieldAccess object represents field access. The method edit() in ExprEditor receives this object if field access is found. The method replace() in FieldAccess receives source text representing the substitued statement or block for the field access.\n\nIn the source text, the identifiers starting with $ have special meaning:\n\n$0\tThe object containing the field accessed by the expression. This is not equivalent to this.\nthis represents the object that the method including the expression is invoked on.\n$0 is null if the field is static.\n \n \n$1\tThe value that would be stored in the field if the expression is write access. \nOtherwise, $1 is not available.\n \n$_\tThe resulting value of the field access if the expression is read access. \nOtherwise, the value stored in $_ is discarded.\n \n$r\tThe type of the field if the expression is read access. \nOtherwise, $r is void.\n \n$class    \tA java.lang.Class object representing the class declaring the field.\n$type\tA java.lang.Class object representing the field type.\n$proceed    \tThe name of a virtual method executing the original field access. .\nThe other identifiers such as $w, $args and $$ are also available.\n\nIf the expression is read access, a value must be assigned to $_ in the source text. The type of $_ is the type of the field.\n\n### javassist.expr.NewExpr\nA NewExpr object represents object creation with the new operator (not including array creation). The method edit() in ExprEditor receives this object if object creation is found. The method replace() in NewExpr receives source text representing the substitued statement or block for the object creation.\n\nIn the source text, the identifiers starting with $ have special meaning:\n\n$0\tnull.\n$1, $2, ...    \tThe parameters to the constructor.\n$_\tThe resulting value of the object creation. \nA newly created object must be stored in this variable.\n \n$r\tThe type of the created object.\n$sig    \tAn array of java.lang.Class objects representing the formal parameter types.\n$type    \tA java.lang.Class object representing the class of the created object.\n$proceed    \tThe name of a virtual method executing the original object creation. .\nThe other identifiers such as $w, $args and $$ are also available.\n\n### javassist.expr.NewArray\nA NewArray object represents array creation with the new operator. The method edit() in ExprEditor receives this object if array creation is found. The method replace() in NewArray receives source text representing the substitued statement or block for the array creation.\n\nIn the source text, the identifiers starting with $ have special meaning:\n\n$0\tnull.\n$1, $2, ...    \tThe size of each dimension.\n$_\tThe resulting value of the array creation. \nA newly created array must be stored in this variable.\n \n$r\tThe type of the created array.\n$type    \tA java.lang.Class object representing the class of the created array.\n$proceed    \tThe name of a virtual method executing the original array creation. .\nThe other identifiers such as $w, $args and $$ are also available.\n\nFor example, if the array creation is the following expression,\n\n```java\nString[][] s = new String[3][4];\n```\nthen the value of $1 and $2 are 3 and 4, respectively. $3 is not available.\nIf the array creation is the following expression,\n\n```java\nString[][] s = new String[3][];\n```\nthen the value of $1 is 3 but $2 is not available.\n\n### javassist.expr.Instanceof\nA Instanceof object represents an instanceof expression. The method edit() in ExprEditor receives this object if an instanceof expression is found. The method replace() in Instanceof receives source text representing the substitued statement or block for the expression.\n\nIn the source text, the identifiers starting with $ have special meaning:\n\n$0\tnull.\n$1\tThe value on the left hand side of the original instanceof operator.\n$_\tThe resulting value of the expression. The type of $_ is boolean.\n$r\tThe type on the right hand side of the instanceof operator.\n$type\tA java.lang.Class object representing the type on the right hand side of the instanceof operator.\n$proceed    \tThe name of a virtual method executing the original instanceof expression. \nIt takes one parameter (the type is java.lang.Object) and returns true \nif the parameter value is an instance of the type on the right hand side of \nthe original instanceof operator. Otherwise, it returns false.\n \n \n \nThe other identifiers such as $w, $args and $$ are also available.\n\n### javassist.expr.Cast\nA Cast object represents an expression for explicit type casting. The method edit() in ExprEditor receives this object if explicit type casting is found. The method replace() in Cast receives source text representing the substitued statement or block for the expression.\n\nIn the source text, the identifiers starting with $ have special meaning:\n\n$0\tnull.\n$1\tThe value the type of which is explicitly cast.\n$_\tThe resulting value of the expression. The type of $_ is the same as the type \nafter the explicit casting, that is, the type surrounded by ( ).\n \n$r\tthe type after the explicit casting, or the type surrounded by ( ).\n$type\tA java.lang.Class object representing the same type as $r.\n$proceed    \tThe name of a virtual method executing the original type casting. \nIt takes one parameter of the type java.lang.Object and returns it after \nthe explicit type casting specified by the original expression.\n \n \nThe other identifiers such as $w, $args and $$ are also available.\n\n### javassist.expr.Handler\nA Handler object represents a catch clause of try-catch statement. The method edit() in ExprEditor receives this object if a catch is found. The method insertBefore() in Handler compiles the received source text and inserts it at the beginning of the catch clause.\n\nIn the source text, the identifiers starting with $ have meaning:\n\n$1\tThe exception object caught by the catch clause.\n$r\tthe type of the exception caught by the catch clause. It is used in a cast expression.\n$w\tThe wrapper type. It is used in a cast expression.\n$type    \tA java.lang.Class object representing \nthe type of the exception caught by the catch clause.\n \nIf a new exception object is assigned to $1, it is passed to the original catch clause as the caught exception.\n\n\n\n## 4.3 Adding a new method or field\n\n### Adding a method\nJavassist allows the users to create a new method and constructor from scratch. CtNewMethod and CtNewConstructor provide several factory methods, which are static methods for creating CtMethod or CtConstructor objects. Especially, make() creates a CtMethod or CtConstructor object from the given source text.\n\nFor example, this program:\n\n```java\nCtClass point = ClassPool.getDefault().get(\"Point\");\nCtMethod m = CtNewMethod.make(\n                 \"public int xmove(int dx) { x += dx; }\",\n                 point);\npoint.addMethod(m);\n```\nadds a public method xmove() to class Point. In this example, x is a int field in the class Point.\n\nThe source text passed to make() can include the identifiers starting with $ except $_ as in setBody(). It can also include $proceed if the target object and the target method name are also given to make(). For example,\n\n```java\nCtClass point = ClassPool.getDefault().get(\"Point\");\nCtMethod m = CtNewMethod.make(\n                 \"public int ymove(int dy) { $proceed(0, dy); }\",\n                 point, \"this\", \"move\");\n```\n\nthis program creates a method ymove() defined below:\n\npublic int ymove(int dy) { this.move(0, dy); }\nNote that $proceed has been replaced with this.move.\n\nJavassist provides another way to add a new method. You can first create an abstract method and later give it a method body:\n```java\nCtClass cc = ... ;\nCtMethod m = new CtMethod(CtClass.intType, \"move\",\n                          new CtClass[] { CtClass.intType }, cc);\ncc.addMethod(m);\nm.setBody(\"{ x += $1; }\");\ncc.setModifiers(cc.getModifiers() & ~Modifier.ABSTRACT);\n```\n\nSince Javassist makes a class abstract if an abstract method is added to the class, you have to explicitly change the class back to a non-abstract one after calling setBody().\n\n### Mutual recursive methods\nJavassist cannot compile a method if it calls another method that has not been added to a class. (Javassist can compile a method that calls itself recursively.) To add mutual recursive methods to a class, you need a trick shown below. Suppose that you want to add methods m() and n() to a class represented by cc:\n\n```java\nCtClass cc = ... ;\nCtMethod m = CtNewMethod.make(\"public abstract int m(int i);\", cc);\nCtMethod n = CtNewMethod.make(\"public abstract int n(int i);\", cc);\ncc.addMethod(m);\ncc.addMethod(n);\nm.setBody(\"{ return ($1 <= 0) ? 1 : (n($1 - 1) * $1); }\");\nn.setBody(\"{ return m($1); }\");\ncc.setModifiers(cc.getModifiers() & ~Modifier.ABSTRACT);\n```\n\nYou must first make two abstract methods and add them to the class. Then you can give the method bodies to these methods even if the method bodies include method calls to each other. Finally you must change the class to a not-abstract class since addMethod() automatically changes a class into an abstract one if an abstract method is added.\n\n### Adding a field\nJavassist also allows the users to create a new field.\n\n```java\nCtClass point = ClassPool.getDefault().get(\"Point\");\nCtField f = new CtField(CtClass.intType, \"z\", point);\npoint.addField(f);\n```\n\nThis program adds a field named z to class Point.\n\nIf the initial value of the added field must be specified, the program shown above must be modified into:\n\n```java\nCtClass point = ClassPool.getDefault().get(\"Point\");\nCtField f = new CtField(CtClass.intType, \"z\", point);\npoint.addField(f, \"0\");    // initial value is 0.\n```\n\nNow, the method addField() receives the second parameter, which is the source text representing an expression computing the initial value. This source text can be any Java expression if the result type of the expression matches the type of the field. Note that an expression does not end with a semi colon (;).\n\nFurthermore, the above code can be rewritten into the following simple code:\n\n```java\nCtClass point = ClassPool.getDefault().get(\"Point\");\nCtField f = CtField.make(\"public int z = 0;\", point);\npoint.addField(f);\n```\n\n### Removing a member\nTo remove a field or a method, call removeField() or removeMethod() in CtClass. A CtConstructor can be removed by removeConstructor() in CtClass.\n\n\n\n## 4.4 Annotations\nCtClass, CtMethod, CtField and CtConstructor provides a convenient method getAnnotations() for reading annotations. It returns an annotation-type object.\n\nFor example, suppose the following annotation:\n```java\npublic @interface Author {\n    String name();\n    int year();\n}\n```\nThis annotation is used as the following:\n```java\n@Author(name=\"Chiba\", year=2005)\npublic class Point {\n    int x, y;\n}\n```\nThen, the value of the annotation can be obtained by getAnnotations(). It returns an array containing annotation-type objects.\n```java\nCtClass cc = ClassPool.getDefault().get(\"Point\");\nObject[] all = cc.getAnnotations();\nAuthor a = (Author)all[0];\nString name = a.name();\nint year = a.year();\nSystem.out.println(\"name: \" + name + \", year: \" + year);\n```\nThis code snippet should print:\n```\nname: Chiba, year: 2005\n```\n\nSince the annoation of Point is only @Author, the length of the array all is one and all[0] is an Author object. The member values of the annotation can be obtained by calling name() and year() on the Author object.\n\nTo use getAnnotations(), annotation types such as Author must be included in the current class path. They must be also accessible from a ClassPool object. If the class file of an annotation type is not found, Javassist cannot obtain the default values of the members of that annotation type.\n\n\n\n## 4.5 Runtime support classes\nIn most cases, a class modified by Javassist does not require Javassist to run. However, some kinds of bytecode generated by the Javassist compiler need runtime support classes, which are in the javassist.runtime package (for details, please read the API reference of that package). Note that the javassist.runtime package is the only package that classes modified by Javassist may need for running. The other Javassist classes are never used at runtime of the modified classes.\n\n\n\n## 4.6 Import\nAll the class names in source code must be fully qualified (they must include package names). However, the java.lang package is an exception; for example, the Javassist compiler can resolve Object as well as java.lang.Object.\n\nTo tell the compiler to search other packages when resolving a class name, call importPackage() in ClassPool. For example,\n```java\nClassPool pool = ClassPool.getDefault();\npool.importPackage(\"java.awt\");\nCtClass cc = pool.makeClass(\"Test\");\nCtField f = CtField.make(\"public Point p;\", cc);\ncc.addField(f);\n```\nThe seconde line instructs the compiler to import the java.awt package. Thus, the third line will not throw an exception. The compiler can recognize Point as java.awt.Point.\n\nNote that importPackage() does not affect the get() method in ClassPool. Only the compiler considers the imported packages. The parameter to get() must be always a fully qualified name.\n\n\n\n## 4.7 Limitations\nIn the current implementation, the Java compiler included in Javassist has several limitations with respect to the language that the compiler can accept. Those limitations are:\n\nThe new syntax introduced by J2SE 5.0 (including enums and generics) has not been supported. Annotations are supported by the low level API of Javassist. See the javassist.bytecode.annotation package (and also getAnnotations() in CtClass and CtBehavior). Generics are also only partly supported. See the latter section for more details.\nArray initializers, a comma-separated list of expressions enclosed by braces { and }, are not available unless the array dimension is one.\nInner classes or anonymous classes are not supported. Note that this is a limitation of the compiler only. It cannot compile source code including an anonymous-class declaration. Javassist can read and modify a class file of inner/anonymous class.\nLabeled continue and break statements are not supported.\nThe compiler does not correctly implement the Java method dispatch algorithm. The compiler may confuse if methods defined in a class have the same name but take different parameter lists.\nFor example,\n```java\nclass A {} \nclass B extends A {} \nclass C extends B {} \n\nclass X { \n    void foo(A a) { .. } \n    void foo(B b) { .. } \n}\n```\nIf the compiled expression is x.foo(new C()), where x is an instance of X, the compiler may produce a call to foo(A) although the compiler can correctly compile foo((B)new C()).\n\nThe users are recommended to use # as the separator between a class name and a static method or field name. For example, in regular Java,\njavassist.CtClass.intType.getName()\ncalls a method getName() on the object indicated by the static field intType in javassist.CtClass. In Javassist, the users can write the expression shown above but they are recommended to write:\n```\njavassist.CtClass#intType.getName()\n```\nso that the compiler can quickly parse the expression.\n","source":"_posts/javassist/Javasist 4 Introspection and customization.md","raw":"---\ntitle: Javasist Introspection and customization\ndate: 2019-05-04 20:15:00\n---\n\n`CtClass`提供了方法以便于自省. Javassist 的自省能力和Java的反射API很像. CtClass 提供了getName(), getSuperclass(), getMethods()等方法. CtClass仍然提供了修改一个类定义的方法.它允许添加新的字段/构造器/方法. 修改(Instrumenting)方法体也是可以的.\n\nCtClass provides methods for introspection. The introspective ability of Javassist is compatible with that of the Java reflection API. CtClass provides getName(), getSuperclass(), getMethods(), and so on. CtClass also provides methods for modifying a class definition. It allows to add a new field, constructor, and method. Instrumenting a method body is also possible.\n\nCtMethod实例表示方法. CtMethod提供了一些方法用来修改方法的定义. 注意, 如果一个方法是继承而来的, 那么子类和基类的这个方法是由同一个CtMethod对象表示. 一个CtMethod对象对应一个方法的声明.\n\nMethods are represented by CtMethod objects. CtMethod provides several methods for modifying the definition of the method. Note that if a method is inherited from a super class, then the same CtMethod object that represents the inherited method represents the method declared in that super class. A CtMethod object corresponds to every method declaration.\n\n例如, 如果类Point声明了一个方法`move()`, 它的子类`ColorPoint`没有重载`move()`方法, 在Point中声明的move()方法和在子类`ColorPoint`中继承过来的move()方法是由同一个CtMethod对象表示的. 如果CtMethod对象所表示的方法被修改了, 那么父类和子类的方法都会被修改. 如果你只想修改ColorPoint的`move()`方法, 你首席必须得把Point里的move()方法制作一个副本, 然后将这个副本添加到ColorPoint里. 可以通过调用CtNewMethod.copy()得到一个CtMethod对象的副本.\n\nFor example, if class Point declares method move() and a subclass ColorPoint of Point does not override move(), the two move() methods declared in Point and inherited in ColorPoint are represented by the identical CtMethod object. If the method definition represented by this CtMethod object is modified, the modification is reflected on both the methods. If you want to modify only the move() method in ColorPoint, you first have to add to ColorPoint a copy of the CtMethod object representing move() in Point. A copy of the the CtMethod object can be obtained by CtNewMethod.copy().\n\nJavassist不允许删除一个方法或者字段, 但是允许修改它的名字. 索引, 如果一个方法不再需要了, 应该调用CtMethod的setName()将其重命名以及setModifiers()修改它的访问级别到一个私有方法.\n\nJavassist does not allow to remove a method or field, but it allows to change the name. So if a method is not necessary any more, it should be renamed and changed to be a private method by calling setName() and setModifiers() declared in CtMethod.\n\nJavassist也不允许向一个已经存在的方法添加一个新的参数. 但是, 可以向相同的class里增加一个新的方法, 该方法在老的方法接口上增加新的参数. 例如, 如果你想要在一个方法上添加一个newZ参数:\n\nJavassist does not allow to add an extra parameter to an existing method, either. Instead of doing that, a new method receiving the extra parameter as well as the other parameters should be added to the same class. For example, if you want to add an extra int parameter newZ to a method:\n\n```java\nvoid move(int newX, int newY) { x = newX; y = newY; }\n```\nin a Point class, then you should add the following method to the Point class:\n\n在Point类中, 你应该添加一个新的方法:\n```java\nvoid move(int newX, int newY, int newZ) {\n    // do what you want with newZ.\n    move(newX, newY);\n}\n```\n\nJavassist也提供了一些底层API用于修改一个原始的类结构. 例如, CtClass中的getClassFile()返回了一个表示原始类结构的ClassFile对象.CtMethod 中的 getMethodInfo() 返回了一个MethodInfo对象, 该对象表示的类结构中的一个method_info结构. 底层API使用了Java Virtual Machine规范中的词汇. 使用者必须有class文件和字节码的知识. 更多的细节, 使用者应该参考`javassist.bytecode`包下的内容.\n\nJavassist also provides low-level API for directly editing a raw class file. For example, getClassFile() in CtClass returns a ClassFile object representing a raw class file. getMethodInfo() in CtMethod returns a MethodInfo object representing a method_info structure included in a class file. The low-level API uses the vocabulary from the Java Virtual machine specification. The users must have the knowledge about class files and bytecode. For more details, the users should see the javassist.bytecode package.\n\n\n\nThe class files modified by Javassist requires the javassist.runtime package for runtime support only if some special identifiers starting with $ are used. Those special identifiers are described below. The class files modified without those special identifiers do not need the javassist.runtime package or any other Javassist packages at runtime. For more details, see the API documentation of the javassist.runtime package.\n\n\n\n## 4.1 Inserting source text at the beginning/end of a method body\n\nCtMethod and CtConstructor 中提供了insertBefore(), insertAfter(), and addCatch() 这三个方法. 这些方法用于向一个已经存在的方法中添加代码片段. 这些代码片段可以试Java代码. Javassist包含了一个简单的Java编译器用来编译这些Java源码. 该编译器接受Java语言编写的源代码, 然后将其编译成Java字节码, 然后将其内联到一个方法体中. \n\nCtMethod and CtConstructor provide methods insertBefore(), insertAfter(), and addCatch(). They are used for inserting a code fragment into the body of an existing method. The users can specify those code fragments with source text written in Java. Javassist includes a simple Java compiler for processing source text. It receives source text written in Java and compiles it into Java bytecode, which will be inlined into a method body.\n\n如果class文件中包含了line number表的话, 可以在指定的line number中插入一个代码片段.\n\nInserting a code fragment at the position specified by a line number is also possible (if the line number table is contained in the class file). insertAt() in CtMethod and CtConstructor takes source text and a line number in the source file of the original class definition. It compiles the source text and inserts the compiled code at the line number.\n\nThe methods insertBefore(), insertAfter(), addCatch(), and insertAt() receive a String object representing a statement or a block. A statement is a single control structure like if and while or an expression ending with a semi colon (;). A block is a set of statements surrounded with braces {}. Hence each of the following lines is an example of valid statement or block:\n\n```java\nSystem.out.println(\"Hello\");\n{ System.out.println(\"Hello\"); }\nif (i < 0) { i = -i; }\n```\n\nThe statement and the block can refer to fields and methods. They can also refer to the parameters to the method that they are inserted into if that method was compiled with the -g option (to include a local variable attribute in the class file). Otherwise, they must access the method parameters through the special variables $0, $1, $2, ... described below. Accessing local variables declared in the method is not allowed although declaring a new local variable in the block is allowed. However, insertAt() allows the statement and the block to access local variables if these variables are available at the specified line number and the target method was compiled with the -g option.\nThe String object passed to the methods insertBefore(), insertAfter(), addCatch(), and insertAt() are compiled by the compiler included in Javassist. Since the compiler supports language extensions, several identifiers starting with $ have special meaning:\n\n* `$0, $1, $2, ...`    \tthis and actual parameters\n* `$args`\tAn array of parameters. The type of $args is Object[].\n* `$$`\tAll actual parameters. For example, m($$) is equivalent to m($1,$2,...)\n* `$cflow(...)`\tcflow variable\n* `$r`\tThe result type. It is used in a cast expression.\n* `$w`\tThe wrapper type. It is used in a cast expression.\n* `$_`\tThe resulting value\n* `$sig`\tAn array of java.lang.Class objects representing the formal parameter types.\n* `$type`\tA java.lang.Class object representing the formal result type.\n* `$class`\tA java.lang.Class object representing the class currently edited.\n\n#### $0, $1, $2, ...\nThe parameters passed to the target method are accessible with $1, $2, ... instead of the original parameter names. $1 represents the first parameter, $2 represents the second parameter, and so on. The types of those variables are identical to the parameter types. $0 is equivalent to this. If the method is static, $0 is not available.\n\nThese variables are used as following. Suppose that a class Point:\n```java\nclass Point {\n    int x, y;\n    void move(int dx, int dy) { x += dx; y += dy; }\n}\n```\nTo print the values of dx and dy whenever the method move() is called, execute this program:\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"Point\");\nCtMethod m = cc.getDeclaredMethod(\"move\");\nm.insertBefore(\"{ System.out.println($1); System.out.println($2); }\");\ncc.writeFile();\n```\nNote that the source text passed to insertBefore() is surrounded with braces {}. insertBefore() accepts only a single statement or a block surrounded with braces.\n\nThe definition of the class Point after the modification is like this:\n```java\nclass Point {\n    int x, y;\n    void move(int dx, int dy) {\n        { System.out.println(dx); System.out.println(dy); }\n        x += dx; y += dy;\n    }\n}\n```\n$1 and $2 are replaced with dx and dy, respectively.\n\n$1, $2, $3 ... are updatable. If a new value is assigend to one of those variables, then the value of the parameter represented by that variable is also updated.\n\n#### $args\nThe variable $args represents an array of all the parameters. The type of that variable is an array of class Object. If a parameter type is a primitive type such as int, then the parameter value is converted into a wrapper object such as java.lang.Integer to store in $args. Thus, $args[0] is equivalent to $1 unless the type of the first parameter is a primitive type. Note that $args[0] is not equivalent to $0; $0 represents this.\n\nIf an array of Object is assigned to $args, then each element of that array is assigned to each parameter. If a parameter type is a primitive type, the type of the corresponding element must be a wrapper type. The value is converted from the wrapper type to the primitive type before it is assigned to the parameter.\n\n#### $$\nThe variable $$ is abbreviation of a list of all the parameters separated by commas. For example, if the number of the parameters to method move() is three, then\n\n```java\nmove($$)\n```\nis equivalent to this:\n```java\nmove($1, $2, $3)\n```\nIf move() does not take any parameters, then move($$) is equivalent to move().\n\n$$ can be used with another method. If you write an expression:\n\n```java\nexMove($$, context)\n```\nthen this expression is equivalent to:\n\n```java\nexMove($1, $2, $3, context)\n```\nNote that $$ enables generic notation of method call with respect to the number of parameters. It is typically used with $proceed shown later.\n\n#### $cflow\n$cflow means \"control flow\". This read-only variable returns the depth of the recursive calls to a specific method.\n\nSuppose that the method shown below is represented by a CtMethod object cm:\n\n```java\nint fact(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return n * fact(n - 1);\n}\n```\n\nTo use $cflow, first declare that $cflow is used for monitoring calls to the method fact():\n\n```java\nCtMethod cm = ...;\ncm.useCflow(\"fact\");\n```\n\nThe parameter to useCflow() is the identifier of the declared $cflow variable. Any valid Java name can be used as the identifier. Since the identifier can also include . (dot), for example, \"my.Test.fact\" is a valid identifier.\n\nThen, $cflow(fact) represents the depth of the recursive calls to the method specified by cm. The value of $cflow(fact) is 0 (zero) when the method is first called whereas it is 1 when the method is recursively called within the method. For example,\n\n```java\ncm.insertBefore(\"if ($cflow(fact) == 0)\"\n              + \"    System.out.println(\\\"fact \\\" + $1);\");\n```\ntranslates the method fact() so that it shows the parameter. Since the value of $cflow(fact) is checked, the method fact() does not show the parameter if it is recursively called within fact().\n\nThe value of $cflow is the number of stack frames associated with the specified method cm under the current topmost stack frame for the current thread. $cflow is also accessible within a method different from the specified method cm.\n\n#### $r\n$r represents the result type (return type) of the method. It must be used as the cast type in a cast expression. For example, this is a typical use:\n\n```java\nObject result = ... ;\n$_ = ($r)result;\n```\n\nIf the result type is a primitive type, then ($r) follows special semantics. First, if the operand type of the cast expression is a primitive type, ($r) works as a normal cast operator to the result type. On the other hand, if the operand type is a wrapper type, ($r) converts from the wrapper type to the result type. For example, if the result type is int, then ($r) converts from java.lang.Integer to int.\n\nIf the result type is void, then ($r) does not convert a type; it does nothing. However, if the operand is a call to a void method, then ($r) results in null. For example, if the result type is void and foo() is a void method, then\n\n```java\n$_ = ($r)foo();\n```\nis a valid statement.\n\nThe cast operator ($r) is also useful in a return statement. Even if the result type is void, the following return statement is valid:\n\n```java\nreturn ($r)result;\n```\nHere, result is some local variable. Since ($r) is specified, the resulting value is discarded. This return statement is regarded as the equivalent of the return statement without a resulting value:\n```java\nreturn;\n```\n\n#### $w\n$w represents a wrapper type. It must be used as the cast type in a cast expression. ($w) converts from a primitive type to the corresponding wrapper type. The following code is an example:\n\n```java\nInteger i = ($w)5;\n```\nThe selected wrapper type depends on the type of the expression following ($w). If the type of the expression is double, then the wrapper type is java.lang.Double.\n\nIf the type of the expression following ($w) is not a primitive type, then ($w) does nothing.\n\n#### $_\ninsertAfter() in CtMethod and CtConstructor inserts the compiled code at the end of the method. In the statement given to insertAfter(), not only the variables shown above such as $0, $1, ... but also $_ is available.\n\nThe variable $_ represents the resulting value of the method. The type of that variable is the type of the result type (the return type) of the method. If the result type is void, then the type of $_ is Object and the value of $_ is null.\n\nAlthough the compiled code inserted by insertAfter() is executed just before the control normally returns from the method, it can be also executed when an exception is thrown from the method. To execute it when an exception is thrown, the second parameter asFinally to insertAfter() must be true.\n\nIf an exception is thrown, the compiled code inserted by insertAfter() is executed as a finally clause. The value of $_ is 0 or null in the compiled code. After the execution of the compiled code terminates, the exception originally thrown is re-thrown to the caller. Note that the value of $_ is never thrown to the caller; it is rather discarded.\n\n#### $sig\nThe value of $sig is an array of java.lang.Class objects that represent the formal parameter types in declaration order.\n\n#### $type\nThe value of $type is an java.lang.Class object representing the formal type of the result value. This variable refers to Void.class if this is a constructor.\n\n#### $class\nThe value of $class is an java.lang.Class object representing the class in which the edited method is declared. This represents the type of $0.\n\n#### addCatch()\naddCatch() inserts a code fragment into a method body so that the code fragment is executed when the method body throws an exception and the control returns to the caller. In the source text representing the inserted code fragment, the exception value is referred to with the special variable $e.\n\nFor example, this program:\n```java\nCtMethod m = ...;\nCtClass etype = ClassPool.getDefault().get(\"java.io.IOException\");\nm.addCatch(\"{ System.out.println($e); throw $e; }\", etype);\ntranslates the method body represented by m into something like this:\n\ntry {\n    the original method body\n}\ncatch (java.io.IOException e) {\n    System.out.println(e);\n    throw e;\n}\n```\nNote that the inserted code fragment must end with a throw or return statement.\n\n\n\n## 4.2 Altering a method body\nCtMethod and CtConstructor provide setBody() for substituting a whole method body. They compile the given source text into Java bytecode and substitutes it for the original method body. If the given source text is null, the substituted body includes only a return statement, which returns zero or null unless the result type is void.\n\nIn the source text given to setBody(), the identifiers starting with $ have special meaning\n\n* `$0, $1, $2, ...`    \tthis and actual parameters\n* `$args`\tAn array of parameters. The type of $args is Object[].\n* `$$`\tAll actual parameters.\n* `$cflow(...)`\tcflow variable\n* `$r`\tThe result type. It is used in a cast expression.\n* `$w`\tThe wrapper type. It is used in a cast expression.\n* `$sig`\tAn array of java.lang.Class objects representing the formal parameter types.\n* `$type`\tA java.lang.Class object representing the formal result type.\n* `$class`\tA java.lang.Class object representing the class that declares the method\ncurrently edited (the type of $0).\n \nNote that $_ is not available.\n\n### Substituting source text for an existing expression\nJavassist allows modifying only an expression included in a method body. javassist.expr.ExprEditor is a class for replacing an expression in a method body. The users can define a subclass of ExprEditor to specify how an expression is modified.\n\nTo run an ExprEditor object, the users must call instrument() in CtMethod or CtClass. For example,\n\n```java\nCtMethod cm = ... ;\ncm.instrument(\n    new ExprEditor() {\n        public void edit(MethodCall m)\n                      throws CannotCompileException\n        {\n            if (m.getClassName().equals(\"Point\")\n                          && m.getMethodName().equals(\"move\"))\n                m.replace(\"{ $1 = 0; $_ = $proceed($$); }\");\n        }\n    });\n```\n\nsearches the method body represented by cm and replaces all calls to move() in class Point with a block:\n\n```java\n{ $1 = 0; $_ = $proceed($$); }\n```\nso that the first parameter to move() is always 0. Note that the substituted code is not an expression but a statement or a block. It cannot be or contain a try-catch statement.\n\nThe method instrument() searches a method body. If it finds an expression such as a method call, field access, and object creation, then it calls edit() on the given ExprEditor object. The parameter to edit() is an object representing the found expression. The edit() method can inspect and replace the expression through that object.\n\nCalling replace() on the parameter to edit() substitutes the given statement or block for the expression. If the given block is an empty block, that is, if replace(\"{}\") is executed, then the expression is removed from the method body. If you want to insert a statement (or a block) before/after the expression, a block like the following should be passed to replace():\n\n```java\n{ before-statements;\n  $_ = $proceed($$);\n  after-statements; }\n```\nwhichever the expression is either a method call, field access, object creation, or others. The second statement could be:\n\n```java\n$_ = $proceed();\n```\nif the expression is read access, or\n\n```java\n$proceed($$);\n```\nif the expression is write access.\n\nLocal variables available in the target expression is also available in the source text passed to replace() if the method searched by instrument() was compiled with the -g option (the class file includes a local variable attribute).\n\n### javassist.expr.MethodCall\nA MethodCall object represents a method call. The method replace() in MethodCall substitutes a statement or a block for the method call. It receives source text representing the substitued statement or block, in which the identifiers starting with $ have special meaning as in the source text passed to insertBefore().\n\n$0\tThe target object of the method call.\nThis is not equivalent to this, which represents the caller-side this object.\n$0 is null if the method is static.\n \n \n$1, $2, ...    \tThe parameters of the method call.\n$_\tThe resulting value of the method call.\n$r\tThe result type of the method call.\n$class    \tA java.lang.Class object representing the class declaring the method.\n$sig    \tAn array of java.lang.Class objects representing the formal parameter types.\n$type    \tA java.lang.Class object representing the formal result type.\n$proceed    \tThe name of the method originally called in the expression.\nHere the method call means the one represented by the MethodCall object.\n\nThe other identifiers such as $w, $args and $$ are also available.\n\nUnless the result type of the method call is void, a value must be assigned to $_ in the source text and the type of $_ is the result type. If the result type is void, the type of $_ is Object and the value assigned to $_ is ignored.\n\n$proceed is not a String value but special syntax. It must be followed by an argument list surrounded by parentheses ( ).\n\n### javassist.expr.ConstructorCall\nA ConstructorCall object represents a constructor call such as this() and super included in a constructor body. The method replace() in ConstructorCall substitutes a statement or a block for the constructor call. It receives source text representing the substituted statement or block, in which the identifiers starting with $ have special meaning as in the source text passed to insertBefore().\n\n$0\tThe target object of the constructor call. This is equivalent to this.\n$1, $2, ...    \tThe parameters of the constructor call.\n$class    \tA java.lang.Class object representing the class declaring the constructor.\n$sig    \tAn array of java.lang.Class objects representing the formal parameter types.\n$proceed    \tThe name of the constructor originally called in the expression.\nHere the constructor call means the one represented by the ConstructorCall object.\n\nThe other identifiers such as $w, $args and $$ are also available.\n\nSince any constructor must call either a constructor of the super class or another constructor of the same class, the substituted statement must include a constructor call, normally a call to $proceed().\n\n$proceed is not a String value but special syntax. It must be followed by an argument list surrounded by parentheses ( ).\n\n### javassist.expr.FieldAccess\nA FieldAccess object represents field access. The method edit() in ExprEditor receives this object if field access is found. The method replace() in FieldAccess receives source text representing the substitued statement or block for the field access.\n\nIn the source text, the identifiers starting with $ have special meaning:\n\n$0\tThe object containing the field accessed by the expression. This is not equivalent to this.\nthis represents the object that the method including the expression is invoked on.\n$0 is null if the field is static.\n \n \n$1\tThe value that would be stored in the field if the expression is write access. \nOtherwise, $1 is not available.\n \n$_\tThe resulting value of the field access if the expression is read access. \nOtherwise, the value stored in $_ is discarded.\n \n$r\tThe type of the field if the expression is read access. \nOtherwise, $r is void.\n \n$class    \tA java.lang.Class object representing the class declaring the field.\n$type\tA java.lang.Class object representing the field type.\n$proceed    \tThe name of a virtual method executing the original field access. .\nThe other identifiers such as $w, $args and $$ are also available.\n\nIf the expression is read access, a value must be assigned to $_ in the source text. The type of $_ is the type of the field.\n\n### javassist.expr.NewExpr\nA NewExpr object represents object creation with the new operator (not including array creation). The method edit() in ExprEditor receives this object if object creation is found. The method replace() in NewExpr receives source text representing the substitued statement or block for the object creation.\n\nIn the source text, the identifiers starting with $ have special meaning:\n\n$0\tnull.\n$1, $2, ...    \tThe parameters to the constructor.\n$_\tThe resulting value of the object creation. \nA newly created object must be stored in this variable.\n \n$r\tThe type of the created object.\n$sig    \tAn array of java.lang.Class objects representing the formal parameter types.\n$type    \tA java.lang.Class object representing the class of the created object.\n$proceed    \tThe name of a virtual method executing the original object creation. .\nThe other identifiers such as $w, $args and $$ are also available.\n\n### javassist.expr.NewArray\nA NewArray object represents array creation with the new operator. The method edit() in ExprEditor receives this object if array creation is found. The method replace() in NewArray receives source text representing the substitued statement or block for the array creation.\n\nIn the source text, the identifiers starting with $ have special meaning:\n\n$0\tnull.\n$1, $2, ...    \tThe size of each dimension.\n$_\tThe resulting value of the array creation. \nA newly created array must be stored in this variable.\n \n$r\tThe type of the created array.\n$type    \tA java.lang.Class object representing the class of the created array.\n$proceed    \tThe name of a virtual method executing the original array creation. .\nThe other identifiers such as $w, $args and $$ are also available.\n\nFor example, if the array creation is the following expression,\n\n```java\nString[][] s = new String[3][4];\n```\nthen the value of $1 and $2 are 3 and 4, respectively. $3 is not available.\nIf the array creation is the following expression,\n\n```java\nString[][] s = new String[3][];\n```\nthen the value of $1 is 3 but $2 is not available.\n\n### javassist.expr.Instanceof\nA Instanceof object represents an instanceof expression. The method edit() in ExprEditor receives this object if an instanceof expression is found. The method replace() in Instanceof receives source text representing the substitued statement or block for the expression.\n\nIn the source text, the identifiers starting with $ have special meaning:\n\n$0\tnull.\n$1\tThe value on the left hand side of the original instanceof operator.\n$_\tThe resulting value of the expression. The type of $_ is boolean.\n$r\tThe type on the right hand side of the instanceof operator.\n$type\tA java.lang.Class object representing the type on the right hand side of the instanceof operator.\n$proceed    \tThe name of a virtual method executing the original instanceof expression. \nIt takes one parameter (the type is java.lang.Object) and returns true \nif the parameter value is an instance of the type on the right hand side of \nthe original instanceof operator. Otherwise, it returns false.\n \n \n \nThe other identifiers such as $w, $args and $$ are also available.\n\n### javassist.expr.Cast\nA Cast object represents an expression for explicit type casting. The method edit() in ExprEditor receives this object if explicit type casting is found. The method replace() in Cast receives source text representing the substitued statement or block for the expression.\n\nIn the source text, the identifiers starting with $ have special meaning:\n\n$0\tnull.\n$1\tThe value the type of which is explicitly cast.\n$_\tThe resulting value of the expression. The type of $_ is the same as the type \nafter the explicit casting, that is, the type surrounded by ( ).\n \n$r\tthe type after the explicit casting, or the type surrounded by ( ).\n$type\tA java.lang.Class object representing the same type as $r.\n$proceed    \tThe name of a virtual method executing the original type casting. \nIt takes one parameter of the type java.lang.Object and returns it after \nthe explicit type casting specified by the original expression.\n \n \nThe other identifiers such as $w, $args and $$ are also available.\n\n### javassist.expr.Handler\nA Handler object represents a catch clause of try-catch statement. The method edit() in ExprEditor receives this object if a catch is found. The method insertBefore() in Handler compiles the received source text and inserts it at the beginning of the catch clause.\n\nIn the source text, the identifiers starting with $ have meaning:\n\n$1\tThe exception object caught by the catch clause.\n$r\tthe type of the exception caught by the catch clause. It is used in a cast expression.\n$w\tThe wrapper type. It is used in a cast expression.\n$type    \tA java.lang.Class object representing \nthe type of the exception caught by the catch clause.\n \nIf a new exception object is assigned to $1, it is passed to the original catch clause as the caught exception.\n\n\n\n## 4.3 Adding a new method or field\n\n### Adding a method\nJavassist allows the users to create a new method and constructor from scratch. CtNewMethod and CtNewConstructor provide several factory methods, which are static methods for creating CtMethod or CtConstructor objects. Especially, make() creates a CtMethod or CtConstructor object from the given source text.\n\nFor example, this program:\n\n```java\nCtClass point = ClassPool.getDefault().get(\"Point\");\nCtMethod m = CtNewMethod.make(\n                 \"public int xmove(int dx) { x += dx; }\",\n                 point);\npoint.addMethod(m);\n```\nadds a public method xmove() to class Point. In this example, x is a int field in the class Point.\n\nThe source text passed to make() can include the identifiers starting with $ except $_ as in setBody(). It can also include $proceed if the target object and the target method name are also given to make(). For example,\n\n```java\nCtClass point = ClassPool.getDefault().get(\"Point\");\nCtMethod m = CtNewMethod.make(\n                 \"public int ymove(int dy) { $proceed(0, dy); }\",\n                 point, \"this\", \"move\");\n```\n\nthis program creates a method ymove() defined below:\n\npublic int ymove(int dy) { this.move(0, dy); }\nNote that $proceed has been replaced with this.move.\n\nJavassist provides another way to add a new method. You can first create an abstract method and later give it a method body:\n```java\nCtClass cc = ... ;\nCtMethod m = new CtMethod(CtClass.intType, \"move\",\n                          new CtClass[] { CtClass.intType }, cc);\ncc.addMethod(m);\nm.setBody(\"{ x += $1; }\");\ncc.setModifiers(cc.getModifiers() & ~Modifier.ABSTRACT);\n```\n\nSince Javassist makes a class abstract if an abstract method is added to the class, you have to explicitly change the class back to a non-abstract one after calling setBody().\n\n### Mutual recursive methods\nJavassist cannot compile a method if it calls another method that has not been added to a class. (Javassist can compile a method that calls itself recursively.) To add mutual recursive methods to a class, you need a trick shown below. Suppose that you want to add methods m() and n() to a class represented by cc:\n\n```java\nCtClass cc = ... ;\nCtMethod m = CtNewMethod.make(\"public abstract int m(int i);\", cc);\nCtMethod n = CtNewMethod.make(\"public abstract int n(int i);\", cc);\ncc.addMethod(m);\ncc.addMethod(n);\nm.setBody(\"{ return ($1 <= 0) ? 1 : (n($1 - 1) * $1); }\");\nn.setBody(\"{ return m($1); }\");\ncc.setModifiers(cc.getModifiers() & ~Modifier.ABSTRACT);\n```\n\nYou must first make two abstract methods and add them to the class. Then you can give the method bodies to these methods even if the method bodies include method calls to each other. Finally you must change the class to a not-abstract class since addMethod() automatically changes a class into an abstract one if an abstract method is added.\n\n### Adding a field\nJavassist also allows the users to create a new field.\n\n```java\nCtClass point = ClassPool.getDefault().get(\"Point\");\nCtField f = new CtField(CtClass.intType, \"z\", point);\npoint.addField(f);\n```\n\nThis program adds a field named z to class Point.\n\nIf the initial value of the added field must be specified, the program shown above must be modified into:\n\n```java\nCtClass point = ClassPool.getDefault().get(\"Point\");\nCtField f = new CtField(CtClass.intType, \"z\", point);\npoint.addField(f, \"0\");    // initial value is 0.\n```\n\nNow, the method addField() receives the second parameter, which is the source text representing an expression computing the initial value. This source text can be any Java expression if the result type of the expression matches the type of the field. Note that an expression does not end with a semi colon (;).\n\nFurthermore, the above code can be rewritten into the following simple code:\n\n```java\nCtClass point = ClassPool.getDefault().get(\"Point\");\nCtField f = CtField.make(\"public int z = 0;\", point);\npoint.addField(f);\n```\n\n### Removing a member\nTo remove a field or a method, call removeField() or removeMethod() in CtClass. A CtConstructor can be removed by removeConstructor() in CtClass.\n\n\n\n## 4.4 Annotations\nCtClass, CtMethod, CtField and CtConstructor provides a convenient method getAnnotations() for reading annotations. It returns an annotation-type object.\n\nFor example, suppose the following annotation:\n```java\npublic @interface Author {\n    String name();\n    int year();\n}\n```\nThis annotation is used as the following:\n```java\n@Author(name=\"Chiba\", year=2005)\npublic class Point {\n    int x, y;\n}\n```\nThen, the value of the annotation can be obtained by getAnnotations(). It returns an array containing annotation-type objects.\n```java\nCtClass cc = ClassPool.getDefault().get(\"Point\");\nObject[] all = cc.getAnnotations();\nAuthor a = (Author)all[0];\nString name = a.name();\nint year = a.year();\nSystem.out.println(\"name: \" + name + \", year: \" + year);\n```\nThis code snippet should print:\n```\nname: Chiba, year: 2005\n```\n\nSince the annoation of Point is only @Author, the length of the array all is one and all[0] is an Author object. The member values of the annotation can be obtained by calling name() and year() on the Author object.\n\nTo use getAnnotations(), annotation types such as Author must be included in the current class path. They must be also accessible from a ClassPool object. If the class file of an annotation type is not found, Javassist cannot obtain the default values of the members of that annotation type.\n\n\n\n## 4.5 Runtime support classes\nIn most cases, a class modified by Javassist does not require Javassist to run. However, some kinds of bytecode generated by the Javassist compiler need runtime support classes, which are in the javassist.runtime package (for details, please read the API reference of that package). Note that the javassist.runtime package is the only package that classes modified by Javassist may need for running. The other Javassist classes are never used at runtime of the modified classes.\n\n\n\n## 4.6 Import\nAll the class names in source code must be fully qualified (they must include package names). However, the java.lang package is an exception; for example, the Javassist compiler can resolve Object as well as java.lang.Object.\n\nTo tell the compiler to search other packages when resolving a class name, call importPackage() in ClassPool. For example,\n```java\nClassPool pool = ClassPool.getDefault();\npool.importPackage(\"java.awt\");\nCtClass cc = pool.makeClass(\"Test\");\nCtField f = CtField.make(\"public Point p;\", cc);\ncc.addField(f);\n```\nThe seconde line instructs the compiler to import the java.awt package. Thus, the third line will not throw an exception. The compiler can recognize Point as java.awt.Point.\n\nNote that importPackage() does not affect the get() method in ClassPool. Only the compiler considers the imported packages. The parameter to get() must be always a fully qualified name.\n\n\n\n## 4.7 Limitations\nIn the current implementation, the Java compiler included in Javassist has several limitations with respect to the language that the compiler can accept. Those limitations are:\n\nThe new syntax introduced by J2SE 5.0 (including enums and generics) has not been supported. Annotations are supported by the low level API of Javassist. See the javassist.bytecode.annotation package (and also getAnnotations() in CtClass and CtBehavior). Generics are also only partly supported. See the latter section for more details.\nArray initializers, a comma-separated list of expressions enclosed by braces { and }, are not available unless the array dimension is one.\nInner classes or anonymous classes are not supported. Note that this is a limitation of the compiler only. It cannot compile source code including an anonymous-class declaration. Javassist can read and modify a class file of inner/anonymous class.\nLabeled continue and break statements are not supported.\nThe compiler does not correctly implement the Java method dispatch algorithm. The compiler may confuse if methods defined in a class have the same name but take different parameter lists.\nFor example,\n```java\nclass A {} \nclass B extends A {} \nclass C extends B {} \n\nclass X { \n    void foo(A a) { .. } \n    void foo(B b) { .. } \n}\n```\nIf the compiled expression is x.foo(new C()), where x is an instance of X, the compiler may produce a call to foo(A) although the compiler can correctly compile foo((B)new C()).\n\nThe users are recommended to use # as the separator between a class name and a static method or field name. For example, in regular Java,\njavassist.CtClass.intType.getName()\ncalls a method getName() on the object indicated by the static field intType in javassist.CtClass. In Javassist, the users can write the expression shown above but they are recommended to write:\n```\njavassist.CtClass#intType.getName()\n```\nso that the compiler can quickly parse the expression.\n","slug":"javassist/Javasist 4 Introspection and customization","published":1,"updated":"2019-11-04T05:49:02.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2k1g07f00075c377e7a9qt8","content":"<p><code>CtClass</code>提供了方法以便于自省. Javassist 的自省能力和Java的反射API很像. CtClass 提供了getName(), getSuperclass(), getMethods()等方法. CtClass仍然提供了修改一个类定义的方法.它允许添加新的字段/构造器/方法. 修改(Instrumenting)方法体也是可以的.</p>\n<p>CtClass provides methods for introspection. The introspective ability of Javassist is compatible with that of the Java reflection API. CtClass provides getName(), getSuperclass(), getMethods(), and so on. CtClass also provides methods for modifying a class definition. It allows to add a new field, constructor, and method. Instrumenting a method body is also possible.</p>\n<p>CtMethod实例表示方法. CtMethod提供了一些方法用来修改方法的定义. 注意, 如果一个方法是继承而来的, 那么子类和基类的这个方法是由同一个CtMethod对象表示. 一个CtMethod对象对应一个方法的声明.</p>\n<p>Methods are represented by CtMethod objects. CtMethod provides several methods for modifying the definition of the method. Note that if a method is inherited from a super class, then the same CtMethod object that represents the inherited method represents the method declared in that super class. A CtMethod object corresponds to every method declaration.</p>\n<p>例如, 如果类Point声明了一个方法<code>move()</code>, 它的子类<code>ColorPoint</code>没有重载<code>move()</code>方法, 在Point中声明的move()方法和在子类<code>ColorPoint</code>中继承过来的move()方法是由同一个CtMethod对象表示的. 如果CtMethod对象所表示的方法被修改了, 那么父类和子类的方法都会被修改. 如果你只想修改ColorPoint的<code>move()</code>方法, 你首席必须得把Point里的move()方法制作一个副本, 然后将这个副本添加到ColorPoint里. 可以通过调用CtNewMethod.copy()得到一个CtMethod对象的副本.</p>\n<p>For example, if class Point declares method move() and a subclass ColorPoint of Point does not override move(), the two move() methods declared in Point and inherited in ColorPoint are represented by the identical CtMethod object. If the method definition represented by this CtMethod object is modified, the modification is reflected on both the methods. If you want to modify only the move() method in ColorPoint, you first have to add to ColorPoint a copy of the CtMethod object representing move() in Point. A copy of the the CtMethod object can be obtained by CtNewMethod.copy().</p>\n<p>Javassist不允许删除一个方法或者字段, 但是允许修改它的名字. 索引, 如果一个方法不再需要了, 应该调用CtMethod的setName()将其重命名以及setModifiers()修改它的访问级别到一个私有方法.</p>\n<p>Javassist does not allow to remove a method or field, but it allows to change the name. So if a method is not necessary any more, it should be renamed and changed to be a private method by calling setName() and setModifiers() declared in CtMethod.</p>\n<p>Javassist也不允许向一个已经存在的方法添加一个新的参数. 但是, 可以向相同的class里增加一个新的方法, 该方法在老的方法接口上增加新的参数. 例如, 如果你想要在一个方法上添加一个newZ参数:</p>\n<p>Javassist does not allow to add an extra parameter to an existing method, either. Instead of doing that, a new method receiving the extra parameter as well as the other parameters should be added to the same class. For example, if you want to add an extra int parameter newZ to a method:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> newX, <span class=\"keyword\">int</span> newY)</span> </span>&#123; x = newX; y = newY; &#125;</span><br></pre></td></tr></table></figure>\n<p>in a Point class, then you should add the following method to the Point class:</p>\n<p>在Point类中, 你应该添加一个新的方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> newX, <span class=\"keyword\">int</span> newY, <span class=\"keyword\">int</span> newZ)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do what you want with newZ.</span></span><br><span class=\"line\">    move(newX, newY);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Javassist也提供了一些底层API用于修改一个原始的类结构. 例如, CtClass中的getClassFile()返回了一个表示原始类结构的ClassFile对象.CtMethod 中的 getMethodInfo() 返回了一个MethodInfo对象, 该对象表示的类结构中的一个method_info结构. 底层API使用了Java Virtual Machine规范中的词汇. 使用者必须有class文件和字节码的知识. 更多的细节, 使用者应该参考<code>javassist.bytecode</code>包下的内容.</p>\n<p>Javassist also provides low-level API for directly editing a raw class file. For example, getClassFile() in CtClass returns a ClassFile object representing a raw class file. getMethodInfo() in CtMethod returns a MethodInfo object representing a method_info structure included in a class file. The low-level API uses the vocabulary from the Java Virtual machine specification. The users must have the knowledge about class files and bytecode. For more details, the users should see the javassist.bytecode package.</p>\n<p>The class files modified by Javassist requires the javassist.runtime package for runtime support only if some special identifiers starting with $ are used. Those special identifiers are described below. The class files modified without those special identifiers do not need the javassist.runtime package or any other Javassist packages at runtime. For more details, see the API documentation of the javassist.runtime package.</p>\n<h2 id=\"4-1-Inserting-source-text-at-the-beginning-end-of-a-method-body\"><a href=\"#4-1-Inserting-source-text-at-the-beginning-end-of-a-method-body\" class=\"headerlink\" title=\"4.1 Inserting source text at the beginning/end of a method body\"></a>4.1 Inserting source text at the beginning/end of a method body</h2><p>CtMethod and CtConstructor 中提供了insertBefore(), insertAfter(), and addCatch() 这三个方法. 这些方法用于向一个已经存在的方法中添加代码片段. 这些代码片段可以试Java代码. Javassist包含了一个简单的Java编译器用来编译这些Java源码. 该编译器接受Java语言编写的源代码, 然后将其编译成Java字节码, 然后将其内联到一个方法体中. </p>\n<p>CtMethod and CtConstructor provide methods insertBefore(), insertAfter(), and addCatch(). They are used for inserting a code fragment into the body of an existing method. The users can specify those code fragments with source text written in Java. Javassist includes a simple Java compiler for processing source text. It receives source text written in Java and compiles it into Java bytecode, which will be inlined into a method body.</p>\n<p>如果class文件中包含了line number表的话, 可以在指定的line number中插入一个代码片段.</p>\n<p>Inserting a code fragment at the position specified by a line number is also possible (if the line number table is contained in the class file). insertAt() in CtMethod and CtConstructor takes source text and a line number in the source file of the original class definition. It compiles the source text and inserts the compiled code at the line number.</p>\n<p>The methods insertBefore(), insertAfter(), addCatch(), and insertAt() receive a String object representing a statement or a block. A statement is a single control structure like if and while or an expression ending with a semi colon (;). A block is a set of statements surrounded with braces {}. Hence each of the following lines is an example of valid statement or block:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">&#123; System.out.println(<span class=\"string\">\"Hello\"</span>); &#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span>) &#123; i = -i; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>The statement and the block can refer to fields and methods. They can also refer to the parameters to the method that they are inserted into if that method was compiled with the -g option (to include a local variable attribute in the class file). Otherwise, they must access the method parameters through the special variables $0, $1, $2, … described below. Accessing local variables declared in the method is not allowed although declaring a new local variable in the block is allowed. However, insertAt() allows the statement and the block to access local variables if these variables are available at the specified line number and the target method was compiled with the -g option.<br>The String object passed to the methods insertBefore(), insertAfter(), addCatch(), and insertAt() are compiled by the compiler included in Javassist. Since the compiler supports language extensions, several identifiers starting with $ have special meaning:</p>\n<ul>\n<li><code>$0, $1, $2, ...</code>        this and actual parameters</li>\n<li><code>$args</code>    An array of parameters. The type of $args is Object[].</li>\n<li><code>$$</code>    All actual parameters. For example, m($$) is equivalent to m($1,$2,…)</li>\n<li><code>$cflow(...)</code>    cflow variable</li>\n<li><code>$r</code>    The result type. It is used in a cast expression.</li>\n<li><code>$w</code>    The wrapper type. It is used in a cast expression.</li>\n<li><code>$_</code>    The resulting value</li>\n<li><code>$sig</code>    An array of java.lang.Class objects representing the formal parameter types.</li>\n<li><code>$type</code>    A java.lang.Class object representing the formal result type.</li>\n<li><code>$class</code>    A java.lang.Class object representing the class currently edited.</li>\n</ul>\n<h4 id=\"0-1-2-…\"><a href=\"#0-1-2-…\" class=\"headerlink\" title=\"$0, $1, $2, …\"></a>$0, $1, $2, …</h4><p>The parameters passed to the target method are accessible with $1, $2, … instead of the original parameter names. $1 represents the first parameter, $2 represents the second parameter, and so on. The types of those variables are identical to the parameter types. $0 is equivalent to this. If the method is static, $0 is not available.</p>\n<p>These variables are used as following. Suppose that a class Point:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy)</span> </span>&#123; x += dx; y += dy; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>To print the values of dx and dy whenever the method move() is called, execute this program:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtMethod m = cc.getDeclaredMethod(<span class=\"string\">\"move\"</span>);</span><br><span class=\"line\">m.insertBefore(<span class=\"string\">\"&#123; System.out.println($1); System.out.println($2); &#125;\"</span>);</span><br><span class=\"line\">cc.writeFile();</span><br></pre></td></tr></table></figure>\n<p>Note that the source text passed to insertBefore() is surrounded with braces {}. insertBefore() accepts only a single statement or a block surrounded with braces.</p>\n<p>The definition of the class Point after the modification is like this:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">        &#123; System.out.println(dx); System.out.println(dy); &#125;</span><br><span class=\"line\">        x += dx; y += dy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>$1 and $2 are replaced with dx and dy, respectively.</p>\n<p>$1, $2, $3 … are updatable. If a new value is assigend to one of those variables, then the value of the parameter represented by that variable is also updated.</p>\n<h4 id=\"args\"><a href=\"#args\" class=\"headerlink\" title=\"$args\"></a>$args</h4><p>The variable $args represents an array of all the parameters. The type of that variable is an array of class Object. If a parameter type is a primitive type such as int, then the parameter value is converted into a wrapper object such as java.lang.Integer to store in $args. Thus, $args[0] is equivalent to $1 unless the type of the first parameter is a primitive type. Note that $args[0] is not equivalent to $0; $0 represents this.</p>\n<p>If an array of Object is assigned to $args, then each element of that array is assigned to each parameter. If a parameter type is a primitive type, the type of the corresponding element must be a wrapper type. The value is converted from the wrapper type to the primitive type before it is assigned to the parameter.</p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"$$\"></a>$$</h4><p>The variable $$ is abbreviation of a list of all the parameters separated by commas. For example, if the number of the parameters to method move() is three, then</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">move($$)</span><br></pre></td></tr></table></figure>\n<p>is equivalent to this:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">move($<span class=\"number\">1</span>, $<span class=\"number\">2</span>, $<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>If move() does not take any parameters, then move($$) is equivalent to move().</p>\n<p>$$ can be used with another method. If you write an expression:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exMove($$, context)</span><br></pre></td></tr></table></figure>\n<p>then this expression is equivalent to:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exMove($<span class=\"number\">1</span>, $<span class=\"number\">2</span>, $<span class=\"number\">3</span>, context)</span><br></pre></td></tr></table></figure>\n<p>Note that $$ enables generic notation of method call with respect to the number of parameters. It is typically used with $proceed shown later.</p>\n<h4 id=\"cflow\"><a href=\"#cflow\" class=\"headerlink\" title=\"$cflow\"></a>$cflow</h4><p>$cflow means “control flow”. This read-only variable returns the depth of the recursive calls to a specific method.</p>\n<p>Suppose that the method shown below is represented by a CtMethod object cm:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * fact(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>To use $cflow, first declare that $cflow is used for monitoring calls to the method fact():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtMethod cm = ...;</span><br><span class=\"line\">cm.useCflow(<span class=\"string\">\"fact\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>The parameter to useCflow() is the identifier of the declared $cflow variable. Any valid Java name can be used as the identifier. Since the identifier can also include . (dot), for example, “my.Test.fact” is a valid identifier.</p>\n<p>Then, $cflow(fact) represents the depth of the recursive calls to the method specified by cm. The value of $cflow(fact) is 0 (zero) when the method is first called whereas it is 1 when the method is recursively called within the method. For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cm.insertBefore(<span class=\"string\">\"if ($cflow(fact) == 0)\"</span></span><br><span class=\"line\">              + <span class=\"string\">\"    System.out.println(\\\"fact \\\" + $1);\"</span>);</span><br></pre></td></tr></table></figure>\n<p>translates the method fact() so that it shows the parameter. Since the value of $cflow(fact) is checked, the method fact() does not show the parameter if it is recursively called within fact().</p>\n<p>The value of $cflow is the number of stack frames associated with the specified method cm under the current topmost stack frame for the current thread. $cflow is also accessible within a method different from the specified method cm.</p>\n<h4 id=\"r\"><a href=\"#r\" class=\"headerlink\" title=\"$r\"></a>$r</h4><p>$r represents the result type (return type) of the method. It must be used as the cast type in a cast expression. For example, this is a typical use:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object result = ... ;</span><br><span class=\"line\">$_ = ($r)result;</span><br></pre></td></tr></table></figure>\n\n<p>If the result type is a primitive type, then ($r) follows special semantics. First, if the operand type of the cast expression is a primitive type, ($r) works as a normal cast operator to the result type. On the other hand, if the operand type is a wrapper type, ($r) converts from the wrapper type to the result type. For example, if the result type is int, then ($r) converts from java.lang.Integer to int.</p>\n<p>If the result type is void, then ($r) does not convert a type; it does nothing. However, if the operand is a call to a void method, then ($r) results in null. For example, if the result type is void and foo() is a void method, then</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$_ = ($r)foo();</span><br></pre></td></tr></table></figure>\n<p>is a valid statement.</p>\n<p>The cast operator ($r) is also useful in a return statement. Even if the result type is void, the following return statement is valid:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> ($r)result;</span><br></pre></td></tr></table></figure>\n<p>Here, result is some local variable. Since ($r) is specified, the resulting value is discarded. This return statement is regarded as the equivalent of the return statement without a resulting value:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"w\"><a href=\"#w\" class=\"headerlink\" title=\"$w\"></a>$w</h4><p>$w represents a wrapper type. It must be used as the cast type in a cast expression. ($w) converts from a primitive type to the corresponding wrapper type. The following code is an example:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = ($w)<span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p>The selected wrapper type depends on the type of the expression following ($w). If the type of the expression is double, then the wrapper type is java.lang.Double.</p>\n<p>If the type of the expression following ($w) is not a primitive type, then ($w) does nothing.</p>\n<h4 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"$_\"></a>$_</h4><p>insertAfter() in CtMethod and CtConstructor inserts the compiled code at the end of the method. In the statement given to insertAfter(), not only the variables shown above such as $0, $1, … but also $_ is available.</p>\n<p>The variable $_ represents the resulting value of the method. The type of that variable is the type of the result type (the return type) of the method. If the result type is void, then the type of $_ is Object and the value of $_ is null.</p>\n<p>Although the compiled code inserted by insertAfter() is executed just before the control normally returns from the method, it can be also executed when an exception is thrown from the method. To execute it when an exception is thrown, the second parameter asFinally to insertAfter() must be true.</p>\n<p>If an exception is thrown, the compiled code inserted by insertAfter() is executed as a finally clause. The value of $_ is 0 or null in the compiled code. After the execution of the compiled code terminates, the exception originally thrown is re-thrown to the caller. Note that the value of $_ is never thrown to the caller; it is rather discarded.</p>\n<h4 id=\"sig\"><a href=\"#sig\" class=\"headerlink\" title=\"$sig\"></a>$sig</h4><p>The value of $sig is an array of java.lang.Class objects that represent the formal parameter types in declaration order.</p>\n<h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"$type\"></a>$type</h4><p>The value of $type is an java.lang.Class object representing the formal type of the result value. This variable refers to Void.class if this is a constructor.</p>\n<h4 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"$class\"></a>$class</h4><p>The value of $class is an java.lang.Class object representing the class in which the edited method is declared. This represents the type of $0.</p>\n<h4 id=\"addCatch\"><a href=\"#addCatch\" class=\"headerlink\" title=\"addCatch()\"></a>addCatch()</h4><p>addCatch() inserts a code fragment into a method body so that the code fragment is executed when the method body throws an exception and the control returns to the caller. In the source text representing the inserted code fragment, the exception value is referred to with the special variable $e.</p>\n<p>For example, this program:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtMethod m = ...;</span><br><span class=\"line\">CtClass etype = ClassPool.getDefault().get(<span class=\"string\">\"java.io.IOException\"</span>);</span><br><span class=\"line\">m.addCatch(<span class=\"string\">\"&#123; System.out.println($e); throw $e; &#125;\"</span>, etype);</span><br><span class=\"line\">translates the method body represented by m into something like <span class=\"keyword\">this</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    the original method body</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (java.io.IOException e) &#123;</span><br><span class=\"line\">    System.out.println(e);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Note that the inserted code fragment must end with a throw or return statement.</p>\n<h2 id=\"4-2-Altering-a-method-body\"><a href=\"#4-2-Altering-a-method-body\" class=\"headerlink\" title=\"4.2 Altering a method body\"></a>4.2 Altering a method body</h2><p>CtMethod and CtConstructor provide setBody() for substituting a whole method body. They compile the given source text into Java bytecode and substitutes it for the original method body. If the given source text is null, the substituted body includes only a return statement, which returns zero or null unless the result type is void.</p>\n<p>In the source text given to setBody(), the identifiers starting with $ have special meaning</p>\n<ul>\n<li><code>$0, $1, $2, ...</code>        this and actual parameters</li>\n<li><code>$args</code>    An array of parameters. The type of $args is Object[].</li>\n<li><code>$$</code>    All actual parameters.</li>\n<li><code>$cflow(...)</code>    cflow variable</li>\n<li><code>$r</code>    The result type. It is used in a cast expression.</li>\n<li><code>$w</code>    The wrapper type. It is used in a cast expression.</li>\n<li><code>$sig</code>    An array of java.lang.Class objects representing the formal parameter types.</li>\n<li><code>$type</code>    A java.lang.Class object representing the formal result type.</li>\n<li><code>$class</code>    A java.lang.Class object representing the class that declares the method<br>currently edited (the type of $0).</li>\n</ul>\n<p>Note that $_ is not available.</p>\n<h3 id=\"Substituting-source-text-for-an-existing-expression\"><a href=\"#Substituting-source-text-for-an-existing-expression\" class=\"headerlink\" title=\"Substituting source text for an existing expression\"></a>Substituting source text for an existing expression</h3><p>Javassist allows modifying only an expression included in a method body. javassist.expr.ExprEditor is a class for replacing an expression in a method body. The users can define a subclass of ExprEditor to specify how an expression is modified.</p>\n<p>To run an ExprEditor object, the users must call instrument() in CtMethod or CtClass. For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtMethod cm = ... ;</span><br><span class=\"line\">cm.instrument(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExprEditor() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">edit</span><span class=\"params\">(MethodCall m)</span></span></span><br><span class=\"line\"><span class=\"function\">                      <span class=\"keyword\">throws</span> CannotCompileException</span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.getClassName().equals(<span class=\"string\">\"Point\"</span>)</span><br><span class=\"line\">                          &amp;&amp; m.getMethodName().equals(<span class=\"string\">\"move\"</span>))</span><br><span class=\"line\">                m.replace(<span class=\"string\">\"&#123; $1 = 0; $_ = $proceed($$); &#125;\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>searches the method body represented by cm and replaces all calls to move() in class Point with a block:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; $<span class=\"number\">1</span> = <span class=\"number\">0</span>; $_ = $proceed($$); &#125;</span><br></pre></td></tr></table></figure>\n<p>so that the first parameter to move() is always 0. Note that the substituted code is not an expression but a statement or a block. It cannot be or contain a try-catch statement.</p>\n<p>The method instrument() searches a method body. If it finds an expression such as a method call, field access, and object creation, then it calls edit() on the given ExprEditor object. The parameter to edit() is an object representing the found expression. The edit() method can inspect and replace the expression through that object.</p>\n<p>Calling replace() on the parameter to edit() substitutes the given statement or block for the expression. If the given block is an empty block, that is, if replace(“{}”) is executed, then the expression is removed from the method body. If you want to insert a statement (or a block) before/after the expression, a block like the following should be passed to replace():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; before-statements;</span><br><span class=\"line\">  $_ = $proceed($$);</span><br><span class=\"line\">  after-statements; &#125;</span><br></pre></td></tr></table></figure>\n<p>whichever the expression is either a method call, field access, object creation, or others. The second statement could be:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$_ = $proceed();</span><br></pre></td></tr></table></figure>\n<p>if the expression is read access, or</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$proceed($$);</span><br></pre></td></tr></table></figure>\n<p>if the expression is write access.</p>\n<p>Local variables available in the target expression is also available in the source text passed to replace() if the method searched by instrument() was compiled with the -g option (the class file includes a local variable attribute).</p>\n<h3 id=\"javassist-expr-MethodCall\"><a href=\"#javassist-expr-MethodCall\" class=\"headerlink\" title=\"javassist.expr.MethodCall\"></a>javassist.expr.MethodCall</h3><p>A MethodCall object represents a method call. The method replace() in MethodCall substitutes a statement or a block for the method call. It receives source text representing the substitued statement or block, in which the identifiers starting with $ have special meaning as in the source text passed to insertBefore().</p>\n<p>$0    The target object of the method call.<br>This is not equivalent to this, which represents the caller-side this object.<br>$0 is null if the method is static.</p>\n<p>$1, $2, …        The parameters of the method call.<br>$_    The resulting value of the method call.<br>$r    The result type of the method call.<br>$class        A java.lang.Class object representing the class declaring the method.<br>$sig        An array of java.lang.Class objects representing the formal parameter types.<br>$type        A java.lang.Class object representing the formal result type.<br>$proceed        The name of the method originally called in the expression.<br>Here the method call means the one represented by the MethodCall object.</p>\n<p>The other identifiers such as $w, $args and $$ are also available.</p>\n<p>Unless the result type of the method call is void, a value must be assigned to $_ in the source text and the type of $_ is the result type. If the result type is void, the type of $_ is Object and the value assigned to $_ is ignored.</p>\n<p>$proceed is not a String value but special syntax. It must be followed by an argument list surrounded by parentheses ( ).</p>\n<h3 id=\"javassist-expr-ConstructorCall\"><a href=\"#javassist-expr-ConstructorCall\" class=\"headerlink\" title=\"javassist.expr.ConstructorCall\"></a>javassist.expr.ConstructorCall</h3><p>A ConstructorCall object represents a constructor call such as this() and super included in a constructor body. The method replace() in ConstructorCall substitutes a statement or a block for the constructor call. It receives source text representing the substituted statement or block, in which the identifiers starting with $ have special meaning as in the source text passed to insertBefore().</p>\n<p>$0    The target object of the constructor call. This is equivalent to this.<br>$1, $2, …        The parameters of the constructor call.<br>$class        A java.lang.Class object representing the class declaring the constructor.<br>$sig        An array of java.lang.Class objects representing the formal parameter types.<br>$proceed        The name of the constructor originally called in the expression.<br>Here the constructor call means the one represented by the ConstructorCall object.</p>\n<p>The other identifiers such as $w, $args and $$ are also available.</p>\n<p>Since any constructor must call either a constructor of the super class or another constructor of the same class, the substituted statement must include a constructor call, normally a call to $proceed().</p>\n<p>$proceed is not a String value but special syntax. It must be followed by an argument list surrounded by parentheses ( ).</p>\n<h3 id=\"javassist-expr-FieldAccess\"><a href=\"#javassist-expr-FieldAccess\" class=\"headerlink\" title=\"javassist.expr.FieldAccess\"></a>javassist.expr.FieldAccess</h3><p>A FieldAccess object represents field access. The method edit() in ExprEditor receives this object if field access is found. The method replace() in FieldAccess receives source text representing the substitued statement or block for the field access.</p>\n<p>In the source text, the identifiers starting with $ have special meaning:</p>\n<p>$0    The object containing the field accessed by the expression. This is not equivalent to this.<br>this represents the object that the method including the expression is invoked on.<br>$0 is null if the field is static.</p>\n<p>$1    The value that would be stored in the field if the expression is write access.<br>Otherwise, $1 is not available.</p>\n<p>$_    The resulting value of the field access if the expression is read access.<br>Otherwise, the value stored in $_ is discarded.</p>\n<p>$r    The type of the field if the expression is read access.<br>Otherwise, $r is void.</p>\n<p>$class        A java.lang.Class object representing the class declaring the field.<br>$type    A java.lang.Class object representing the field type.<br>$proceed        The name of a virtual method executing the original field access. .<br>The other identifiers such as $w, $args and $$ are also available.</p>\n<p>If the expression is read access, a value must be assigned to $_ in the source text. The type of $_ is the type of the field.</p>\n<h3 id=\"javassist-expr-NewExpr\"><a href=\"#javassist-expr-NewExpr\" class=\"headerlink\" title=\"javassist.expr.NewExpr\"></a>javassist.expr.NewExpr</h3><p>A NewExpr object represents object creation with the new operator (not including array creation). The method edit() in ExprEditor receives this object if object creation is found. The method replace() in NewExpr receives source text representing the substitued statement or block for the object creation.</p>\n<p>In the source text, the identifiers starting with $ have special meaning:</p>\n<p>$0    null.<br>$1, $2, …        The parameters to the constructor.<br>$_    The resulting value of the object creation.<br>A newly created object must be stored in this variable.</p>\n<p>$r    The type of the created object.<br>$sig        An array of java.lang.Class objects representing the formal parameter types.<br>$type        A java.lang.Class object representing the class of the created object.<br>$proceed        The name of a virtual method executing the original object creation. .<br>The other identifiers such as $w, $args and $$ are also available.</p>\n<h3 id=\"javassist-expr-NewArray\"><a href=\"#javassist-expr-NewArray\" class=\"headerlink\" title=\"javassist.expr.NewArray\"></a>javassist.expr.NewArray</h3><p>A NewArray object represents array creation with the new operator. The method edit() in ExprEditor receives this object if array creation is found. The method replace() in NewArray receives source text representing the substitued statement or block for the array creation.</p>\n<p>In the source text, the identifiers starting with $ have special meaning:</p>\n<p>$0    null.<br>$1, $2, …        The size of each dimension.<br>$_    The resulting value of the array creation.<br>A newly created array must be stored in this variable.</p>\n<p>$r    The type of the created array.<br>$type        A java.lang.Class object representing the class of the created array.<br>$proceed        The name of a virtual method executing the original array creation. .<br>The other identifiers such as $w, $args and $$ are also available.</p>\n<p>For example, if the array creation is the following expression,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[][] s = <span class=\"keyword\">new</span> String[<span class=\"number\">3</span>][<span class=\"number\">4</span>];</span><br></pre></td></tr></table></figure>\n<p>then the value of $1 and $2 are 3 and 4, respectively. $3 is not available.<br>If the array creation is the following expression,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[][] s = <span class=\"keyword\">new</span> String[<span class=\"number\">3</span>][];</span><br></pre></td></tr></table></figure>\n<p>then the value of $1 is 3 but $2 is not available.</p>\n<h3 id=\"javassist-expr-Instanceof\"><a href=\"#javassist-expr-Instanceof\" class=\"headerlink\" title=\"javassist.expr.Instanceof\"></a>javassist.expr.Instanceof</h3><p>A Instanceof object represents an instanceof expression. The method edit() in ExprEditor receives this object if an instanceof expression is found. The method replace() in Instanceof receives source text representing the substitued statement or block for the expression.</p>\n<p>In the source text, the identifiers starting with $ have special meaning:</p>\n<p>$0    null.<br>$1    The value on the left hand side of the original instanceof operator.<br>$_    The resulting value of the expression. The type of $_ is boolean.<br>$r    The type on the right hand side of the instanceof operator.<br>$type    A java.lang.Class object representing the type on the right hand side of the instanceof operator.<br>$proceed        The name of a virtual method executing the original instanceof expression.<br>It takes one parameter (the type is java.lang.Object) and returns true<br>if the parameter value is an instance of the type on the right hand side of<br>the original instanceof operator. Otherwise, it returns false.</p>\n<p>The other identifiers such as $w, $args and $$ are also available.</p>\n<h3 id=\"javassist-expr-Cast\"><a href=\"#javassist-expr-Cast\" class=\"headerlink\" title=\"javassist.expr.Cast\"></a>javassist.expr.Cast</h3><p>A Cast object represents an expression for explicit type casting. The method edit() in ExprEditor receives this object if explicit type casting is found. The method replace() in Cast receives source text representing the substitued statement or block for the expression.</p>\n<p>In the source text, the identifiers starting with $ have special meaning:</p>\n<p>$0    null.<br>$1    The value the type of which is explicitly cast.<br>$_    The resulting value of the expression. The type of $_ is the same as the type<br>after the explicit casting, that is, the type surrounded by ( ).</p>\n<p>$r    the type after the explicit casting, or the type surrounded by ( ).<br>$type    A java.lang.Class object representing the same type as $r.<br>$proceed        The name of a virtual method executing the original type casting.<br>It takes one parameter of the type java.lang.Object and returns it after<br>the explicit type casting specified by the original expression.</p>\n<p>The other identifiers such as $w, $args and $$ are also available.</p>\n<h3 id=\"javassist-expr-Handler\"><a href=\"#javassist-expr-Handler\" class=\"headerlink\" title=\"javassist.expr.Handler\"></a>javassist.expr.Handler</h3><p>A Handler object represents a catch clause of try-catch statement. The method edit() in ExprEditor receives this object if a catch is found. The method insertBefore() in Handler compiles the received source text and inserts it at the beginning of the catch clause.</p>\n<p>In the source text, the identifiers starting with $ have meaning:</p>\n<p>$1    The exception object caught by the catch clause.<br>$r    the type of the exception caught by the catch clause. It is used in a cast expression.<br>$w    The wrapper type. It is used in a cast expression.<br>$type        A java.lang.Class object representing<br>the type of the exception caught by the catch clause.</p>\n<p>If a new exception object is assigned to $1, it is passed to the original catch clause as the caught exception.</p>\n<h2 id=\"4-3-Adding-a-new-method-or-field\"><a href=\"#4-3-Adding-a-new-method-or-field\" class=\"headerlink\" title=\"4.3 Adding a new method or field\"></a>4.3 Adding a new method or field</h2><h3 id=\"Adding-a-method\"><a href=\"#Adding-a-method\" class=\"headerlink\" title=\"Adding a method\"></a>Adding a method</h3><p>Javassist allows the users to create a new method and constructor from scratch. CtNewMethod and CtNewConstructor provide several factory methods, which are static methods for creating CtMethod or CtConstructor objects. Especially, make() creates a CtMethod or CtConstructor object from the given source text.</p>\n<p>For example, this program:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass point = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtMethod m = CtNewMethod.make(</span><br><span class=\"line\">                 <span class=\"string\">\"public int xmove(int dx) &#123; x += dx; &#125;\"</span>,</span><br><span class=\"line\">                 point);</span><br><span class=\"line\">point.addMethod(m);</span><br></pre></td></tr></table></figure>\n<p>adds a public method xmove() to class Point. In this example, x is a int field in the class Point.</p>\n<p>The source text passed to make() can include the identifiers starting with $ except $_ as in setBody(). It can also include $proceed if the target object and the target method name are also given to make(). For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass point = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtMethod m = CtNewMethod.make(</span><br><span class=\"line\">                 <span class=\"string\">\"public int ymove(int dy) &#123; $proceed(0, dy); &#125;\"</span>,</span><br><span class=\"line\">                 point, <span class=\"string\">\"this\"</span>, <span class=\"string\">\"move\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>this program creates a method ymove() defined below:</p>\n<p>public int ymove(int dy) { this.move(0, dy); }<br>Note that $proceed has been replaced with this.move.</p>\n<p>Javassist provides another way to add a new method. You can first create an abstract method and later give it a method body:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass cc = ... ;</span><br><span class=\"line\">CtMethod m = <span class=\"keyword\">new</span> CtMethod(CtClass.intType, <span class=\"string\">\"move\"</span>,</span><br><span class=\"line\">                          <span class=\"keyword\">new</span> CtClass[] &#123; CtClass.intType &#125;, cc);</span><br><span class=\"line\">cc.addMethod(m);</span><br><span class=\"line\">m.setBody(<span class=\"string\">\"&#123; x += $1; &#125;\"</span>);</span><br><span class=\"line\">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure>\n\n<p>Since Javassist makes a class abstract if an abstract method is added to the class, you have to explicitly change the class back to a non-abstract one after calling setBody().</p>\n<h3 id=\"Mutual-recursive-methods\"><a href=\"#Mutual-recursive-methods\" class=\"headerlink\" title=\"Mutual recursive methods\"></a>Mutual recursive methods</h3><p>Javassist cannot compile a method if it calls another method that has not been added to a class. (Javassist can compile a method that calls itself recursively.) To add mutual recursive methods to a class, you need a trick shown below. Suppose that you want to add methods m() and n() to a class represented by cc:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass cc = ... ;</span><br><span class=\"line\">CtMethod m = CtNewMethod.make(<span class=\"string\">\"public abstract int m(int i);\"</span>, cc);</span><br><span class=\"line\">CtMethod n = CtNewMethod.make(<span class=\"string\">\"public abstract int n(int i);\"</span>, cc);</span><br><span class=\"line\">cc.addMethod(m);</span><br><span class=\"line\">cc.addMethod(n);</span><br><span class=\"line\">m.setBody(<span class=\"string\">\"&#123; return ($1 &lt;= 0) ? 1 : (n($1 - 1) * $1); &#125;\"</span>);</span><br><span class=\"line\">n.setBody(<span class=\"string\">\"&#123; return m($1); &#125;\"</span>);</span><br><span class=\"line\">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure>\n\n<p>You must first make two abstract methods and add them to the class. Then you can give the method bodies to these methods even if the method bodies include method calls to each other. Finally you must change the class to a not-abstract class since addMethod() automatically changes a class into an abstract one if an abstract method is added.</p>\n<h3 id=\"Adding-a-field\"><a href=\"#Adding-a-field\" class=\"headerlink\" title=\"Adding a field\"></a>Adding a field</h3><p>Javassist also allows the users to create a new field.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass point = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtField f = <span class=\"keyword\">new</span> CtField(CtClass.intType, <span class=\"string\">\"z\"</span>, point);</span><br><span class=\"line\">point.addField(f);</span><br></pre></td></tr></table></figure>\n\n<p>This program adds a field named z to class Point.</p>\n<p>If the initial value of the added field must be specified, the program shown above must be modified into:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass point = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtField f = <span class=\"keyword\">new</span> CtField(CtClass.intType, <span class=\"string\">\"z\"</span>, point);</span><br><span class=\"line\">point.addField(f, <span class=\"string\">\"0\"</span>);    <span class=\"comment\">// initial value is 0.</span></span><br></pre></td></tr></table></figure>\n\n<p>Now, the method addField() receives the second parameter, which is the source text representing an expression computing the initial value. This source text can be any Java expression if the result type of the expression matches the type of the field. Note that an expression does not end with a semi colon (;).</p>\n<p>Furthermore, the above code can be rewritten into the following simple code:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass point = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtField f = CtField.make(<span class=\"string\">\"public int z = 0;\"</span>, point);</span><br><span class=\"line\">point.addField(f);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Removing-a-member\"><a href=\"#Removing-a-member\" class=\"headerlink\" title=\"Removing a member\"></a>Removing a member</h3><p>To remove a field or a method, call removeField() or removeMethod() in CtClass. A CtConstructor can be removed by removeConstructor() in CtClass.</p>\n<h2 id=\"4-4-Annotations\"><a href=\"#4-4-Annotations\" class=\"headerlink\" title=\"4.4 Annotations\"></a>4.4 Annotations</h2><p>CtClass, CtMethod, CtField and CtConstructor provides a convenient method getAnnotations() for reading annotations. It returns an annotation-type object.</p>\n<p>For example, suppose the following annotation:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Author &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">year</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>This annotation is used as the following:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Author</span>(name=<span class=\"string\">\"Chiba\"</span>, year=<span class=\"number\">2005</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Then, the value of the annotation can be obtained by getAnnotations(). It returns an array containing annotation-type objects.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass cc = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">Object[] all = cc.getAnnotations();</span><br><span class=\"line\">Author a = (Author)all[<span class=\"number\">0</span>];</span><br><span class=\"line\">String name = a.name();</span><br><span class=\"line\"><span class=\"keyword\">int</span> year = a.year();</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"name: \"</span> + name + <span class=\"string\">\", year: \"</span> + year);</span><br></pre></td></tr></table></figure>\n<p>This code snippet should print:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: Chiba, year: 2005</span><br></pre></td></tr></table></figure>\n\n<p>Since the annoation of Point is only @Author, the length of the array all is one and all[0] is an Author object. The member values of the annotation can be obtained by calling name() and year() on the Author object.</p>\n<p>To use getAnnotations(), annotation types such as Author must be included in the current class path. They must be also accessible from a ClassPool object. If the class file of an annotation type is not found, Javassist cannot obtain the default values of the members of that annotation type.</p>\n<h2 id=\"4-5-Runtime-support-classes\"><a href=\"#4-5-Runtime-support-classes\" class=\"headerlink\" title=\"4.5 Runtime support classes\"></a>4.5 Runtime support classes</h2><p>In most cases, a class modified by Javassist does not require Javassist to run. However, some kinds of bytecode generated by the Javassist compiler need runtime support classes, which are in the javassist.runtime package (for details, please read the API reference of that package). Note that the javassist.runtime package is the only package that classes modified by Javassist may need for running. The other Javassist classes are never used at runtime of the modified classes.</p>\n<h2 id=\"4-6-Import\"><a href=\"#4-6-Import\" class=\"headerlink\" title=\"4.6 Import\"></a>4.6 Import</h2><p>All the class names in source code must be fully qualified (they must include package names). However, the java.lang package is an exception; for example, the Javassist compiler can resolve Object as well as java.lang.Object.</p>\n<p>To tell the compiler to search other packages when resolving a class name, call importPackage() in ClassPool. For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">pool.importPackage(<span class=\"string\">\"java.awt\"</span>);</span><br><span class=\"line\">CtClass cc = pool.makeClass(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\">CtField f = CtField.make(<span class=\"string\">\"public Point p;\"</span>, cc);</span><br><span class=\"line\">cc.addField(f);</span><br></pre></td></tr></table></figure>\n<p>The seconde line instructs the compiler to import the java.awt package. Thus, the third line will not throw an exception. The compiler can recognize Point as java.awt.Point.</p>\n<p>Note that importPackage() does not affect the get() method in ClassPool. Only the compiler considers the imported packages. The parameter to get() must be always a fully qualified name.</p>\n<h2 id=\"4-7-Limitations\"><a href=\"#4-7-Limitations\" class=\"headerlink\" title=\"4.7 Limitations\"></a>4.7 Limitations</h2><p>In the current implementation, the Java compiler included in Javassist has several limitations with respect to the language that the compiler can accept. Those limitations are:</p>\n<p>The new syntax introduced by J2SE 5.0 (including enums and generics) has not been supported. Annotations are supported by the low level API of Javassist. See the javassist.bytecode.annotation package (and also getAnnotations() in CtClass and CtBehavior). Generics are also only partly supported. See the latter section for more details.<br>Array initializers, a comma-separated list of expressions enclosed by braces { and }, are not available unless the array dimension is one.<br>Inner classes or anonymous classes are not supported. Note that this is a limitation of the compiler only. It cannot compile source code including an anonymous-class declaration. Javassist can read and modify a class file of inner/anonymous class.<br>Labeled continue and break statements are not supported.<br>The compiler does not correctly implement the Java method dispatch algorithm. The compiler may confuse if methods defined in a class have the same name but take different parameter lists.<br>For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;&#125; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span> </span>&#123;&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(A a)</span> </span>&#123; .. &#125; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(B b)</span> </span>&#123; .. &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>If the compiled expression is x.foo(new C()), where x is an instance of X, the compiler may produce a call to foo(A) although the compiler can correctly compile foo((B)new C()).</p>\n<p>The users are recommended to use # as the separator between a class name and a static method or field name. For example, in regular Java,<br>javassist.CtClass.intType.getName()<br>calls a method getName() on the object indicated by the static field intType in javassist.CtClass. In Javassist, the users can write the expression shown above but they are recommended to write:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javassist.CtClass#intType.getName()</span><br></pre></td></tr></table></figure>\n<p>so that the compiler can quickly parse the expression.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>CtClass</code>提供了方法以便于自省. Javassist 的自省能力和Java的反射API很像. CtClass 提供了getName(), getSuperclass(), getMethods()等方法. CtClass仍然提供了修改一个类定义的方法.它允许添加新的字段/构造器/方法. 修改(Instrumenting)方法体也是可以的.</p>\n<p>CtClass provides methods for introspection. The introspective ability of Javassist is compatible with that of the Java reflection API. CtClass provides getName(), getSuperclass(), getMethods(), and so on. CtClass also provides methods for modifying a class definition. It allows to add a new field, constructor, and method. Instrumenting a method body is also possible.</p>\n<p>CtMethod实例表示方法. CtMethod提供了一些方法用来修改方法的定义. 注意, 如果一个方法是继承而来的, 那么子类和基类的这个方法是由同一个CtMethod对象表示. 一个CtMethod对象对应一个方法的声明.</p>\n<p>Methods are represented by CtMethod objects. CtMethod provides several methods for modifying the definition of the method. Note that if a method is inherited from a super class, then the same CtMethod object that represents the inherited method represents the method declared in that super class. A CtMethod object corresponds to every method declaration.</p>\n<p>例如, 如果类Point声明了一个方法<code>move()</code>, 它的子类<code>ColorPoint</code>没有重载<code>move()</code>方法, 在Point中声明的move()方法和在子类<code>ColorPoint</code>中继承过来的move()方法是由同一个CtMethod对象表示的. 如果CtMethod对象所表示的方法被修改了, 那么父类和子类的方法都会被修改. 如果你只想修改ColorPoint的<code>move()</code>方法, 你首席必须得把Point里的move()方法制作一个副本, 然后将这个副本添加到ColorPoint里. 可以通过调用CtNewMethod.copy()得到一个CtMethod对象的副本.</p>\n<p>For example, if class Point declares method move() and a subclass ColorPoint of Point does not override move(), the two move() methods declared in Point and inherited in ColorPoint are represented by the identical CtMethod object. If the method definition represented by this CtMethod object is modified, the modification is reflected on both the methods. If you want to modify only the move() method in ColorPoint, you first have to add to ColorPoint a copy of the CtMethod object representing move() in Point. A copy of the the CtMethod object can be obtained by CtNewMethod.copy().</p>\n<p>Javassist不允许删除一个方法或者字段, 但是允许修改它的名字. 索引, 如果一个方法不再需要了, 应该调用CtMethod的setName()将其重命名以及setModifiers()修改它的访问级别到一个私有方法.</p>\n<p>Javassist does not allow to remove a method or field, but it allows to change the name. So if a method is not necessary any more, it should be renamed and changed to be a private method by calling setName() and setModifiers() declared in CtMethod.</p>\n<p>Javassist也不允许向一个已经存在的方法添加一个新的参数. 但是, 可以向相同的class里增加一个新的方法, 该方法在老的方法接口上增加新的参数. 例如, 如果你想要在一个方法上添加一个newZ参数:</p>\n<p>Javassist does not allow to add an extra parameter to an existing method, either. Instead of doing that, a new method receiving the extra parameter as well as the other parameters should be added to the same class. For example, if you want to add an extra int parameter newZ to a method:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> newX, <span class=\"keyword\">int</span> newY)</span> </span>&#123; x = newX; y = newY; &#125;</span><br></pre></td></tr></table></figure>\n<p>in a Point class, then you should add the following method to the Point class:</p>\n<p>在Point类中, 你应该添加一个新的方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> newX, <span class=\"keyword\">int</span> newY, <span class=\"keyword\">int</span> newZ)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do what you want with newZ.</span></span><br><span class=\"line\">    move(newX, newY);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Javassist也提供了一些底层API用于修改一个原始的类结构. 例如, CtClass中的getClassFile()返回了一个表示原始类结构的ClassFile对象.CtMethod 中的 getMethodInfo() 返回了一个MethodInfo对象, 该对象表示的类结构中的一个method_info结构. 底层API使用了Java Virtual Machine规范中的词汇. 使用者必须有class文件和字节码的知识. 更多的细节, 使用者应该参考<code>javassist.bytecode</code>包下的内容.</p>\n<p>Javassist also provides low-level API for directly editing a raw class file. For example, getClassFile() in CtClass returns a ClassFile object representing a raw class file. getMethodInfo() in CtMethod returns a MethodInfo object representing a method_info structure included in a class file. The low-level API uses the vocabulary from the Java Virtual machine specification. The users must have the knowledge about class files and bytecode. For more details, the users should see the javassist.bytecode package.</p>\n<p>The class files modified by Javassist requires the javassist.runtime package for runtime support only if some special identifiers starting with $ are used. Those special identifiers are described below. The class files modified without those special identifiers do not need the javassist.runtime package or any other Javassist packages at runtime. For more details, see the API documentation of the javassist.runtime package.</p>\n<h2 id=\"4-1-Inserting-source-text-at-the-beginning-end-of-a-method-body\"><a href=\"#4-1-Inserting-source-text-at-the-beginning-end-of-a-method-body\" class=\"headerlink\" title=\"4.1 Inserting source text at the beginning/end of a method body\"></a>4.1 Inserting source text at the beginning/end of a method body</h2><p>CtMethod and CtConstructor 中提供了insertBefore(), insertAfter(), and addCatch() 这三个方法. 这些方法用于向一个已经存在的方法中添加代码片段. 这些代码片段可以试Java代码. Javassist包含了一个简单的Java编译器用来编译这些Java源码. 该编译器接受Java语言编写的源代码, 然后将其编译成Java字节码, 然后将其内联到一个方法体中. </p>\n<p>CtMethod and CtConstructor provide methods insertBefore(), insertAfter(), and addCatch(). They are used for inserting a code fragment into the body of an existing method. The users can specify those code fragments with source text written in Java. Javassist includes a simple Java compiler for processing source text. It receives source text written in Java and compiles it into Java bytecode, which will be inlined into a method body.</p>\n<p>如果class文件中包含了line number表的话, 可以在指定的line number中插入一个代码片段.</p>\n<p>Inserting a code fragment at the position specified by a line number is also possible (if the line number table is contained in the class file). insertAt() in CtMethod and CtConstructor takes source text and a line number in the source file of the original class definition. It compiles the source text and inserts the compiled code at the line number.</p>\n<p>The methods insertBefore(), insertAfter(), addCatch(), and insertAt() receive a String object representing a statement or a block. A statement is a single control structure like if and while or an expression ending with a semi colon (;). A block is a set of statements surrounded with braces {}. Hence each of the following lines is an example of valid statement or block:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">&#123; System.out.println(<span class=\"string\">\"Hello\"</span>); &#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span>) &#123; i = -i; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>The statement and the block can refer to fields and methods. They can also refer to the parameters to the method that they are inserted into if that method was compiled with the -g option (to include a local variable attribute in the class file). Otherwise, they must access the method parameters through the special variables $0, $1, $2, … described below. Accessing local variables declared in the method is not allowed although declaring a new local variable in the block is allowed. However, insertAt() allows the statement and the block to access local variables if these variables are available at the specified line number and the target method was compiled with the -g option.<br>The String object passed to the methods insertBefore(), insertAfter(), addCatch(), and insertAt() are compiled by the compiler included in Javassist. Since the compiler supports language extensions, several identifiers starting with $ have special meaning:</p>\n<ul>\n<li><code>$0, $1, $2, ...</code>        this and actual parameters</li>\n<li><code>$args</code>    An array of parameters. The type of $args is Object[].</li>\n<li><code>$$</code>    All actual parameters. For example, m($$) is equivalent to m($1,$2,…)</li>\n<li><code>$cflow(...)</code>    cflow variable</li>\n<li><code>$r</code>    The result type. It is used in a cast expression.</li>\n<li><code>$w</code>    The wrapper type. It is used in a cast expression.</li>\n<li><code>$_</code>    The resulting value</li>\n<li><code>$sig</code>    An array of java.lang.Class objects representing the formal parameter types.</li>\n<li><code>$type</code>    A java.lang.Class object representing the formal result type.</li>\n<li><code>$class</code>    A java.lang.Class object representing the class currently edited.</li>\n</ul>\n<h4 id=\"0-1-2-…\"><a href=\"#0-1-2-…\" class=\"headerlink\" title=\"$0, $1, $2, …\"></a>$0, $1, $2, …</h4><p>The parameters passed to the target method are accessible with $1, $2, … instead of the original parameter names. $1 represents the first parameter, $2 represents the second parameter, and so on. The types of those variables are identical to the parameter types. $0 is equivalent to this. If the method is static, $0 is not available.</p>\n<p>These variables are used as following. Suppose that a class Point:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy)</span> </span>&#123; x += dx; y += dy; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>To print the values of dx and dy whenever the method move() is called, execute this program:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtMethod m = cc.getDeclaredMethod(<span class=\"string\">\"move\"</span>);</span><br><span class=\"line\">m.insertBefore(<span class=\"string\">\"&#123; System.out.println($1); System.out.println($2); &#125;\"</span>);</span><br><span class=\"line\">cc.writeFile();</span><br></pre></td></tr></table></figure>\n<p>Note that the source text passed to insertBefore() is surrounded with braces {}. insertBefore() accepts only a single statement or a block surrounded with braces.</p>\n<p>The definition of the class Point after the modification is like this:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">        &#123; System.out.println(dx); System.out.println(dy); &#125;</span><br><span class=\"line\">        x += dx; y += dy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>$1 and $2 are replaced with dx and dy, respectively.</p>\n<p>$1, $2, $3 … are updatable. If a new value is assigend to one of those variables, then the value of the parameter represented by that variable is also updated.</p>\n<h4 id=\"args\"><a href=\"#args\" class=\"headerlink\" title=\"$args\"></a>$args</h4><p>The variable $args represents an array of all the parameters. The type of that variable is an array of class Object. If a parameter type is a primitive type such as int, then the parameter value is converted into a wrapper object such as java.lang.Integer to store in $args. Thus, $args[0] is equivalent to $1 unless the type of the first parameter is a primitive type. Note that $args[0] is not equivalent to $0; $0 represents this.</p>\n<p>If an array of Object is assigned to $args, then each element of that array is assigned to each parameter. If a parameter type is a primitive type, the type of the corresponding element must be a wrapper type. The value is converted from the wrapper type to the primitive type before it is assigned to the parameter.</p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"$$\"></a>$$</h4><p>The variable $$ is abbreviation of a list of all the parameters separated by commas. For example, if the number of the parameters to method move() is three, then</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">move($$)</span><br></pre></td></tr></table></figure>\n<p>is equivalent to this:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">move($<span class=\"number\">1</span>, $<span class=\"number\">2</span>, $<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>If move() does not take any parameters, then move($$) is equivalent to move().</p>\n<p>$$ can be used with another method. If you write an expression:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exMove($$, context)</span><br></pre></td></tr></table></figure>\n<p>then this expression is equivalent to:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exMove($<span class=\"number\">1</span>, $<span class=\"number\">2</span>, $<span class=\"number\">3</span>, context)</span><br></pre></td></tr></table></figure>\n<p>Note that $$ enables generic notation of method call with respect to the number of parameters. It is typically used with $proceed shown later.</p>\n<h4 id=\"cflow\"><a href=\"#cflow\" class=\"headerlink\" title=\"$cflow\"></a>$cflow</h4><p>$cflow means “control flow”. This read-only variable returns the depth of the recursive calls to a specific method.</p>\n<p>Suppose that the method shown below is represented by a CtMethod object cm:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * fact(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>To use $cflow, first declare that $cflow is used for monitoring calls to the method fact():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtMethod cm = ...;</span><br><span class=\"line\">cm.useCflow(<span class=\"string\">\"fact\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>The parameter to useCflow() is the identifier of the declared $cflow variable. Any valid Java name can be used as the identifier. Since the identifier can also include . (dot), for example, “my.Test.fact” is a valid identifier.</p>\n<p>Then, $cflow(fact) represents the depth of the recursive calls to the method specified by cm. The value of $cflow(fact) is 0 (zero) when the method is first called whereas it is 1 when the method is recursively called within the method. For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cm.insertBefore(<span class=\"string\">\"if ($cflow(fact) == 0)\"</span></span><br><span class=\"line\">              + <span class=\"string\">\"    System.out.println(\\\"fact \\\" + $1);\"</span>);</span><br></pre></td></tr></table></figure>\n<p>translates the method fact() so that it shows the parameter. Since the value of $cflow(fact) is checked, the method fact() does not show the parameter if it is recursively called within fact().</p>\n<p>The value of $cflow is the number of stack frames associated with the specified method cm under the current topmost stack frame for the current thread. $cflow is also accessible within a method different from the specified method cm.</p>\n<h4 id=\"r\"><a href=\"#r\" class=\"headerlink\" title=\"$r\"></a>$r</h4><p>$r represents the result type (return type) of the method. It must be used as the cast type in a cast expression. For example, this is a typical use:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object result = ... ;</span><br><span class=\"line\">$_ = ($r)result;</span><br></pre></td></tr></table></figure>\n\n<p>If the result type is a primitive type, then ($r) follows special semantics. First, if the operand type of the cast expression is a primitive type, ($r) works as a normal cast operator to the result type. On the other hand, if the operand type is a wrapper type, ($r) converts from the wrapper type to the result type. For example, if the result type is int, then ($r) converts from java.lang.Integer to int.</p>\n<p>If the result type is void, then ($r) does not convert a type; it does nothing. However, if the operand is a call to a void method, then ($r) results in null. For example, if the result type is void and foo() is a void method, then</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$_ = ($r)foo();</span><br></pre></td></tr></table></figure>\n<p>is a valid statement.</p>\n<p>The cast operator ($r) is also useful in a return statement. Even if the result type is void, the following return statement is valid:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> ($r)result;</span><br></pre></td></tr></table></figure>\n<p>Here, result is some local variable. Since ($r) is specified, the resulting value is discarded. This return statement is regarded as the equivalent of the return statement without a resulting value:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"w\"><a href=\"#w\" class=\"headerlink\" title=\"$w\"></a>$w</h4><p>$w represents a wrapper type. It must be used as the cast type in a cast expression. ($w) converts from a primitive type to the corresponding wrapper type. The following code is an example:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = ($w)<span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p>The selected wrapper type depends on the type of the expression following ($w). If the type of the expression is double, then the wrapper type is java.lang.Double.</p>\n<p>If the type of the expression following ($w) is not a primitive type, then ($w) does nothing.</p>\n<h4 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"$_\"></a>$_</h4><p>insertAfter() in CtMethod and CtConstructor inserts the compiled code at the end of the method. In the statement given to insertAfter(), not only the variables shown above such as $0, $1, … but also $_ is available.</p>\n<p>The variable $_ represents the resulting value of the method. The type of that variable is the type of the result type (the return type) of the method. If the result type is void, then the type of $_ is Object and the value of $_ is null.</p>\n<p>Although the compiled code inserted by insertAfter() is executed just before the control normally returns from the method, it can be also executed when an exception is thrown from the method. To execute it when an exception is thrown, the second parameter asFinally to insertAfter() must be true.</p>\n<p>If an exception is thrown, the compiled code inserted by insertAfter() is executed as a finally clause. The value of $_ is 0 or null in the compiled code. After the execution of the compiled code terminates, the exception originally thrown is re-thrown to the caller. Note that the value of $_ is never thrown to the caller; it is rather discarded.</p>\n<h4 id=\"sig\"><a href=\"#sig\" class=\"headerlink\" title=\"$sig\"></a>$sig</h4><p>The value of $sig is an array of java.lang.Class objects that represent the formal parameter types in declaration order.</p>\n<h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"$type\"></a>$type</h4><p>The value of $type is an java.lang.Class object representing the formal type of the result value. This variable refers to Void.class if this is a constructor.</p>\n<h4 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"$class\"></a>$class</h4><p>The value of $class is an java.lang.Class object representing the class in which the edited method is declared. This represents the type of $0.</p>\n<h4 id=\"addCatch\"><a href=\"#addCatch\" class=\"headerlink\" title=\"addCatch()\"></a>addCatch()</h4><p>addCatch() inserts a code fragment into a method body so that the code fragment is executed when the method body throws an exception and the control returns to the caller. In the source text representing the inserted code fragment, the exception value is referred to with the special variable $e.</p>\n<p>For example, this program:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtMethod m = ...;</span><br><span class=\"line\">CtClass etype = ClassPool.getDefault().get(<span class=\"string\">\"java.io.IOException\"</span>);</span><br><span class=\"line\">m.addCatch(<span class=\"string\">\"&#123; System.out.println($e); throw $e; &#125;\"</span>, etype);</span><br><span class=\"line\">translates the method body represented by m into something like <span class=\"keyword\">this</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    the original method body</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (java.io.IOException e) &#123;</span><br><span class=\"line\">    System.out.println(e);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Note that the inserted code fragment must end with a throw or return statement.</p>\n<h2 id=\"4-2-Altering-a-method-body\"><a href=\"#4-2-Altering-a-method-body\" class=\"headerlink\" title=\"4.2 Altering a method body\"></a>4.2 Altering a method body</h2><p>CtMethod and CtConstructor provide setBody() for substituting a whole method body. They compile the given source text into Java bytecode and substitutes it for the original method body. If the given source text is null, the substituted body includes only a return statement, which returns zero or null unless the result type is void.</p>\n<p>In the source text given to setBody(), the identifiers starting with $ have special meaning</p>\n<ul>\n<li><code>$0, $1, $2, ...</code>        this and actual parameters</li>\n<li><code>$args</code>    An array of parameters. The type of $args is Object[].</li>\n<li><code>$$</code>    All actual parameters.</li>\n<li><code>$cflow(...)</code>    cflow variable</li>\n<li><code>$r</code>    The result type. It is used in a cast expression.</li>\n<li><code>$w</code>    The wrapper type. It is used in a cast expression.</li>\n<li><code>$sig</code>    An array of java.lang.Class objects representing the formal parameter types.</li>\n<li><code>$type</code>    A java.lang.Class object representing the formal result type.</li>\n<li><code>$class</code>    A java.lang.Class object representing the class that declares the method<br>currently edited (the type of $0).</li>\n</ul>\n<p>Note that $_ is not available.</p>\n<h3 id=\"Substituting-source-text-for-an-existing-expression\"><a href=\"#Substituting-source-text-for-an-existing-expression\" class=\"headerlink\" title=\"Substituting source text for an existing expression\"></a>Substituting source text for an existing expression</h3><p>Javassist allows modifying only an expression included in a method body. javassist.expr.ExprEditor is a class for replacing an expression in a method body. The users can define a subclass of ExprEditor to specify how an expression is modified.</p>\n<p>To run an ExprEditor object, the users must call instrument() in CtMethod or CtClass. For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtMethod cm = ... ;</span><br><span class=\"line\">cm.instrument(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExprEditor() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">edit</span><span class=\"params\">(MethodCall m)</span></span></span><br><span class=\"line\"><span class=\"function\">                      <span class=\"keyword\">throws</span> CannotCompileException</span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.getClassName().equals(<span class=\"string\">\"Point\"</span>)</span><br><span class=\"line\">                          &amp;&amp; m.getMethodName().equals(<span class=\"string\">\"move\"</span>))</span><br><span class=\"line\">                m.replace(<span class=\"string\">\"&#123; $1 = 0; $_ = $proceed($$); &#125;\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>searches the method body represented by cm and replaces all calls to move() in class Point with a block:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; $<span class=\"number\">1</span> = <span class=\"number\">0</span>; $_ = $proceed($$); &#125;</span><br></pre></td></tr></table></figure>\n<p>so that the first parameter to move() is always 0. Note that the substituted code is not an expression but a statement or a block. It cannot be or contain a try-catch statement.</p>\n<p>The method instrument() searches a method body. If it finds an expression such as a method call, field access, and object creation, then it calls edit() on the given ExprEditor object. The parameter to edit() is an object representing the found expression. The edit() method can inspect and replace the expression through that object.</p>\n<p>Calling replace() on the parameter to edit() substitutes the given statement or block for the expression. If the given block is an empty block, that is, if replace(“{}”) is executed, then the expression is removed from the method body. If you want to insert a statement (or a block) before/after the expression, a block like the following should be passed to replace():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; before-statements;</span><br><span class=\"line\">  $_ = $proceed($$);</span><br><span class=\"line\">  after-statements; &#125;</span><br></pre></td></tr></table></figure>\n<p>whichever the expression is either a method call, field access, object creation, or others. The second statement could be:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$_ = $proceed();</span><br></pre></td></tr></table></figure>\n<p>if the expression is read access, or</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$proceed($$);</span><br></pre></td></tr></table></figure>\n<p>if the expression is write access.</p>\n<p>Local variables available in the target expression is also available in the source text passed to replace() if the method searched by instrument() was compiled with the -g option (the class file includes a local variable attribute).</p>\n<h3 id=\"javassist-expr-MethodCall\"><a href=\"#javassist-expr-MethodCall\" class=\"headerlink\" title=\"javassist.expr.MethodCall\"></a>javassist.expr.MethodCall</h3><p>A MethodCall object represents a method call. The method replace() in MethodCall substitutes a statement or a block for the method call. It receives source text representing the substitued statement or block, in which the identifiers starting with $ have special meaning as in the source text passed to insertBefore().</p>\n<p>$0    The target object of the method call.<br>This is not equivalent to this, which represents the caller-side this object.<br>$0 is null if the method is static.</p>\n<p>$1, $2, …        The parameters of the method call.<br>$_    The resulting value of the method call.<br>$r    The result type of the method call.<br>$class        A java.lang.Class object representing the class declaring the method.<br>$sig        An array of java.lang.Class objects representing the formal parameter types.<br>$type        A java.lang.Class object representing the formal result type.<br>$proceed        The name of the method originally called in the expression.<br>Here the method call means the one represented by the MethodCall object.</p>\n<p>The other identifiers such as $w, $args and $$ are also available.</p>\n<p>Unless the result type of the method call is void, a value must be assigned to $_ in the source text and the type of $_ is the result type. If the result type is void, the type of $_ is Object and the value assigned to $_ is ignored.</p>\n<p>$proceed is not a String value but special syntax. It must be followed by an argument list surrounded by parentheses ( ).</p>\n<h3 id=\"javassist-expr-ConstructorCall\"><a href=\"#javassist-expr-ConstructorCall\" class=\"headerlink\" title=\"javassist.expr.ConstructorCall\"></a>javassist.expr.ConstructorCall</h3><p>A ConstructorCall object represents a constructor call such as this() and super included in a constructor body. The method replace() in ConstructorCall substitutes a statement or a block for the constructor call. It receives source text representing the substituted statement or block, in which the identifiers starting with $ have special meaning as in the source text passed to insertBefore().</p>\n<p>$0    The target object of the constructor call. This is equivalent to this.<br>$1, $2, …        The parameters of the constructor call.<br>$class        A java.lang.Class object representing the class declaring the constructor.<br>$sig        An array of java.lang.Class objects representing the formal parameter types.<br>$proceed        The name of the constructor originally called in the expression.<br>Here the constructor call means the one represented by the ConstructorCall object.</p>\n<p>The other identifiers such as $w, $args and $$ are also available.</p>\n<p>Since any constructor must call either a constructor of the super class or another constructor of the same class, the substituted statement must include a constructor call, normally a call to $proceed().</p>\n<p>$proceed is not a String value but special syntax. It must be followed by an argument list surrounded by parentheses ( ).</p>\n<h3 id=\"javassist-expr-FieldAccess\"><a href=\"#javassist-expr-FieldAccess\" class=\"headerlink\" title=\"javassist.expr.FieldAccess\"></a>javassist.expr.FieldAccess</h3><p>A FieldAccess object represents field access. The method edit() in ExprEditor receives this object if field access is found. The method replace() in FieldAccess receives source text representing the substitued statement or block for the field access.</p>\n<p>In the source text, the identifiers starting with $ have special meaning:</p>\n<p>$0    The object containing the field accessed by the expression. This is not equivalent to this.<br>this represents the object that the method including the expression is invoked on.<br>$0 is null if the field is static.</p>\n<p>$1    The value that would be stored in the field if the expression is write access.<br>Otherwise, $1 is not available.</p>\n<p>$_    The resulting value of the field access if the expression is read access.<br>Otherwise, the value stored in $_ is discarded.</p>\n<p>$r    The type of the field if the expression is read access.<br>Otherwise, $r is void.</p>\n<p>$class        A java.lang.Class object representing the class declaring the field.<br>$type    A java.lang.Class object representing the field type.<br>$proceed        The name of a virtual method executing the original field access. .<br>The other identifiers such as $w, $args and $$ are also available.</p>\n<p>If the expression is read access, a value must be assigned to $_ in the source text. The type of $_ is the type of the field.</p>\n<h3 id=\"javassist-expr-NewExpr\"><a href=\"#javassist-expr-NewExpr\" class=\"headerlink\" title=\"javassist.expr.NewExpr\"></a>javassist.expr.NewExpr</h3><p>A NewExpr object represents object creation with the new operator (not including array creation). The method edit() in ExprEditor receives this object if object creation is found. The method replace() in NewExpr receives source text representing the substitued statement or block for the object creation.</p>\n<p>In the source text, the identifiers starting with $ have special meaning:</p>\n<p>$0    null.<br>$1, $2, …        The parameters to the constructor.<br>$_    The resulting value of the object creation.<br>A newly created object must be stored in this variable.</p>\n<p>$r    The type of the created object.<br>$sig        An array of java.lang.Class objects representing the formal parameter types.<br>$type        A java.lang.Class object representing the class of the created object.<br>$proceed        The name of a virtual method executing the original object creation. .<br>The other identifiers such as $w, $args and $$ are also available.</p>\n<h3 id=\"javassist-expr-NewArray\"><a href=\"#javassist-expr-NewArray\" class=\"headerlink\" title=\"javassist.expr.NewArray\"></a>javassist.expr.NewArray</h3><p>A NewArray object represents array creation with the new operator. The method edit() in ExprEditor receives this object if array creation is found. The method replace() in NewArray receives source text representing the substitued statement or block for the array creation.</p>\n<p>In the source text, the identifiers starting with $ have special meaning:</p>\n<p>$0    null.<br>$1, $2, …        The size of each dimension.<br>$_    The resulting value of the array creation.<br>A newly created array must be stored in this variable.</p>\n<p>$r    The type of the created array.<br>$type        A java.lang.Class object representing the class of the created array.<br>$proceed        The name of a virtual method executing the original array creation. .<br>The other identifiers such as $w, $args and $$ are also available.</p>\n<p>For example, if the array creation is the following expression,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[][] s = <span class=\"keyword\">new</span> String[<span class=\"number\">3</span>][<span class=\"number\">4</span>];</span><br></pre></td></tr></table></figure>\n<p>then the value of $1 and $2 are 3 and 4, respectively. $3 is not available.<br>If the array creation is the following expression,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[][] s = <span class=\"keyword\">new</span> String[<span class=\"number\">3</span>][];</span><br></pre></td></tr></table></figure>\n<p>then the value of $1 is 3 but $2 is not available.</p>\n<h3 id=\"javassist-expr-Instanceof\"><a href=\"#javassist-expr-Instanceof\" class=\"headerlink\" title=\"javassist.expr.Instanceof\"></a>javassist.expr.Instanceof</h3><p>A Instanceof object represents an instanceof expression. The method edit() in ExprEditor receives this object if an instanceof expression is found. The method replace() in Instanceof receives source text representing the substitued statement or block for the expression.</p>\n<p>In the source text, the identifiers starting with $ have special meaning:</p>\n<p>$0    null.<br>$1    The value on the left hand side of the original instanceof operator.<br>$_    The resulting value of the expression. The type of $_ is boolean.<br>$r    The type on the right hand side of the instanceof operator.<br>$type    A java.lang.Class object representing the type on the right hand side of the instanceof operator.<br>$proceed        The name of a virtual method executing the original instanceof expression.<br>It takes one parameter (the type is java.lang.Object) and returns true<br>if the parameter value is an instance of the type on the right hand side of<br>the original instanceof operator. Otherwise, it returns false.</p>\n<p>The other identifiers such as $w, $args and $$ are also available.</p>\n<h3 id=\"javassist-expr-Cast\"><a href=\"#javassist-expr-Cast\" class=\"headerlink\" title=\"javassist.expr.Cast\"></a>javassist.expr.Cast</h3><p>A Cast object represents an expression for explicit type casting. The method edit() in ExprEditor receives this object if explicit type casting is found. The method replace() in Cast receives source text representing the substitued statement or block for the expression.</p>\n<p>In the source text, the identifiers starting with $ have special meaning:</p>\n<p>$0    null.<br>$1    The value the type of which is explicitly cast.<br>$_    The resulting value of the expression. The type of $_ is the same as the type<br>after the explicit casting, that is, the type surrounded by ( ).</p>\n<p>$r    the type after the explicit casting, or the type surrounded by ( ).<br>$type    A java.lang.Class object representing the same type as $r.<br>$proceed        The name of a virtual method executing the original type casting.<br>It takes one parameter of the type java.lang.Object and returns it after<br>the explicit type casting specified by the original expression.</p>\n<p>The other identifiers such as $w, $args and $$ are also available.</p>\n<h3 id=\"javassist-expr-Handler\"><a href=\"#javassist-expr-Handler\" class=\"headerlink\" title=\"javassist.expr.Handler\"></a>javassist.expr.Handler</h3><p>A Handler object represents a catch clause of try-catch statement. The method edit() in ExprEditor receives this object if a catch is found. The method insertBefore() in Handler compiles the received source text and inserts it at the beginning of the catch clause.</p>\n<p>In the source text, the identifiers starting with $ have meaning:</p>\n<p>$1    The exception object caught by the catch clause.<br>$r    the type of the exception caught by the catch clause. It is used in a cast expression.<br>$w    The wrapper type. It is used in a cast expression.<br>$type        A java.lang.Class object representing<br>the type of the exception caught by the catch clause.</p>\n<p>If a new exception object is assigned to $1, it is passed to the original catch clause as the caught exception.</p>\n<h2 id=\"4-3-Adding-a-new-method-or-field\"><a href=\"#4-3-Adding-a-new-method-or-field\" class=\"headerlink\" title=\"4.3 Adding a new method or field\"></a>4.3 Adding a new method or field</h2><h3 id=\"Adding-a-method\"><a href=\"#Adding-a-method\" class=\"headerlink\" title=\"Adding a method\"></a>Adding a method</h3><p>Javassist allows the users to create a new method and constructor from scratch. CtNewMethod and CtNewConstructor provide several factory methods, which are static methods for creating CtMethod or CtConstructor objects. Especially, make() creates a CtMethod or CtConstructor object from the given source text.</p>\n<p>For example, this program:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass point = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtMethod m = CtNewMethod.make(</span><br><span class=\"line\">                 <span class=\"string\">\"public int xmove(int dx) &#123; x += dx; &#125;\"</span>,</span><br><span class=\"line\">                 point);</span><br><span class=\"line\">point.addMethod(m);</span><br></pre></td></tr></table></figure>\n<p>adds a public method xmove() to class Point. In this example, x is a int field in the class Point.</p>\n<p>The source text passed to make() can include the identifiers starting with $ except $_ as in setBody(). It can also include $proceed if the target object and the target method name are also given to make(). For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass point = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtMethod m = CtNewMethod.make(</span><br><span class=\"line\">                 <span class=\"string\">\"public int ymove(int dy) &#123; $proceed(0, dy); &#125;\"</span>,</span><br><span class=\"line\">                 point, <span class=\"string\">\"this\"</span>, <span class=\"string\">\"move\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>this program creates a method ymove() defined below:</p>\n<p>public int ymove(int dy) { this.move(0, dy); }<br>Note that $proceed has been replaced with this.move.</p>\n<p>Javassist provides another way to add a new method. You can first create an abstract method and later give it a method body:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass cc = ... ;</span><br><span class=\"line\">CtMethod m = <span class=\"keyword\">new</span> CtMethod(CtClass.intType, <span class=\"string\">\"move\"</span>,</span><br><span class=\"line\">                          <span class=\"keyword\">new</span> CtClass[] &#123; CtClass.intType &#125;, cc);</span><br><span class=\"line\">cc.addMethod(m);</span><br><span class=\"line\">m.setBody(<span class=\"string\">\"&#123; x += $1; &#125;\"</span>);</span><br><span class=\"line\">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure>\n\n<p>Since Javassist makes a class abstract if an abstract method is added to the class, you have to explicitly change the class back to a non-abstract one after calling setBody().</p>\n<h3 id=\"Mutual-recursive-methods\"><a href=\"#Mutual-recursive-methods\" class=\"headerlink\" title=\"Mutual recursive methods\"></a>Mutual recursive methods</h3><p>Javassist cannot compile a method if it calls another method that has not been added to a class. (Javassist can compile a method that calls itself recursively.) To add mutual recursive methods to a class, you need a trick shown below. Suppose that you want to add methods m() and n() to a class represented by cc:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass cc = ... ;</span><br><span class=\"line\">CtMethod m = CtNewMethod.make(<span class=\"string\">\"public abstract int m(int i);\"</span>, cc);</span><br><span class=\"line\">CtMethod n = CtNewMethod.make(<span class=\"string\">\"public abstract int n(int i);\"</span>, cc);</span><br><span class=\"line\">cc.addMethod(m);</span><br><span class=\"line\">cc.addMethod(n);</span><br><span class=\"line\">m.setBody(<span class=\"string\">\"&#123; return ($1 &lt;= 0) ? 1 : (n($1 - 1) * $1); &#125;\"</span>);</span><br><span class=\"line\">n.setBody(<span class=\"string\">\"&#123; return m($1); &#125;\"</span>);</span><br><span class=\"line\">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure>\n\n<p>You must first make two abstract methods and add them to the class. Then you can give the method bodies to these methods even if the method bodies include method calls to each other. Finally you must change the class to a not-abstract class since addMethod() automatically changes a class into an abstract one if an abstract method is added.</p>\n<h3 id=\"Adding-a-field\"><a href=\"#Adding-a-field\" class=\"headerlink\" title=\"Adding a field\"></a>Adding a field</h3><p>Javassist also allows the users to create a new field.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass point = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtField f = <span class=\"keyword\">new</span> CtField(CtClass.intType, <span class=\"string\">\"z\"</span>, point);</span><br><span class=\"line\">point.addField(f);</span><br></pre></td></tr></table></figure>\n\n<p>This program adds a field named z to class Point.</p>\n<p>If the initial value of the added field must be specified, the program shown above must be modified into:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass point = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtField f = <span class=\"keyword\">new</span> CtField(CtClass.intType, <span class=\"string\">\"z\"</span>, point);</span><br><span class=\"line\">point.addField(f, <span class=\"string\">\"0\"</span>);    <span class=\"comment\">// initial value is 0.</span></span><br></pre></td></tr></table></figure>\n\n<p>Now, the method addField() receives the second parameter, which is the source text representing an expression computing the initial value. This source text can be any Java expression if the result type of the expression matches the type of the field. Note that an expression does not end with a semi colon (;).</p>\n<p>Furthermore, the above code can be rewritten into the following simple code:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass point = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">CtField f = CtField.make(<span class=\"string\">\"public int z = 0;\"</span>, point);</span><br><span class=\"line\">point.addField(f);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Removing-a-member\"><a href=\"#Removing-a-member\" class=\"headerlink\" title=\"Removing a member\"></a>Removing a member</h3><p>To remove a field or a method, call removeField() or removeMethod() in CtClass. A CtConstructor can be removed by removeConstructor() in CtClass.</p>\n<h2 id=\"4-4-Annotations\"><a href=\"#4-4-Annotations\" class=\"headerlink\" title=\"4.4 Annotations\"></a>4.4 Annotations</h2><p>CtClass, CtMethod, CtField and CtConstructor provides a convenient method getAnnotations() for reading annotations. It returns an annotation-type object.</p>\n<p>For example, suppose the following annotation:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Author &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">year</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>This annotation is used as the following:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Author</span>(name=<span class=\"string\">\"Chiba\"</span>, year=<span class=\"number\">2005</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Then, the value of the annotation can be obtained by getAnnotations(). It returns an array containing annotation-type objects.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass cc = ClassPool.getDefault().get(<span class=\"string\">\"Point\"</span>);</span><br><span class=\"line\">Object[] all = cc.getAnnotations();</span><br><span class=\"line\">Author a = (Author)all[<span class=\"number\">0</span>];</span><br><span class=\"line\">String name = a.name();</span><br><span class=\"line\"><span class=\"keyword\">int</span> year = a.year();</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"name: \"</span> + name + <span class=\"string\">\", year: \"</span> + year);</span><br></pre></td></tr></table></figure>\n<p>This code snippet should print:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: Chiba, year: 2005</span><br></pre></td></tr></table></figure>\n\n<p>Since the annoation of Point is only @Author, the length of the array all is one and all[0] is an Author object. The member values of the annotation can be obtained by calling name() and year() on the Author object.</p>\n<p>To use getAnnotations(), annotation types such as Author must be included in the current class path. They must be also accessible from a ClassPool object. If the class file of an annotation type is not found, Javassist cannot obtain the default values of the members of that annotation type.</p>\n<h2 id=\"4-5-Runtime-support-classes\"><a href=\"#4-5-Runtime-support-classes\" class=\"headerlink\" title=\"4.5 Runtime support classes\"></a>4.5 Runtime support classes</h2><p>In most cases, a class modified by Javassist does not require Javassist to run. However, some kinds of bytecode generated by the Javassist compiler need runtime support classes, which are in the javassist.runtime package (for details, please read the API reference of that package). Note that the javassist.runtime package is the only package that classes modified by Javassist may need for running. The other Javassist classes are never used at runtime of the modified classes.</p>\n<h2 id=\"4-6-Import\"><a href=\"#4-6-Import\" class=\"headerlink\" title=\"4.6 Import\"></a>4.6 Import</h2><p>All the class names in source code must be fully qualified (they must include package names). However, the java.lang package is an exception; for example, the Javassist compiler can resolve Object as well as java.lang.Object.</p>\n<p>To tell the compiler to search other packages when resolving a class name, call importPackage() in ClassPool. For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">pool.importPackage(<span class=\"string\">\"java.awt\"</span>);</span><br><span class=\"line\">CtClass cc = pool.makeClass(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\">CtField f = CtField.make(<span class=\"string\">\"public Point p;\"</span>, cc);</span><br><span class=\"line\">cc.addField(f);</span><br></pre></td></tr></table></figure>\n<p>The seconde line instructs the compiler to import the java.awt package. Thus, the third line will not throw an exception. The compiler can recognize Point as java.awt.Point.</p>\n<p>Note that importPackage() does not affect the get() method in ClassPool. Only the compiler considers the imported packages. The parameter to get() must be always a fully qualified name.</p>\n<h2 id=\"4-7-Limitations\"><a href=\"#4-7-Limitations\" class=\"headerlink\" title=\"4.7 Limitations\"></a>4.7 Limitations</h2><p>In the current implementation, the Java compiler included in Javassist has several limitations with respect to the language that the compiler can accept. Those limitations are:</p>\n<p>The new syntax introduced by J2SE 5.0 (including enums and generics) has not been supported. Annotations are supported by the low level API of Javassist. See the javassist.bytecode.annotation package (and also getAnnotations() in CtClass and CtBehavior). Generics are also only partly supported. See the latter section for more details.<br>Array initializers, a comma-separated list of expressions enclosed by braces { and }, are not available unless the array dimension is one.<br>Inner classes or anonymous classes are not supported. Note that this is a limitation of the compiler only. It cannot compile source code including an anonymous-class declaration. Javassist can read and modify a class file of inner/anonymous class.<br>Labeled continue and break statements are not supported.<br>The compiler does not correctly implement the Java method dispatch algorithm. The compiler may confuse if methods defined in a class have the same name but take different parameter lists.<br>For example,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;&#125; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span> </span>&#123;&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(A a)</span> </span>&#123; .. &#125; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(B b)</span> </span>&#123; .. &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>If the compiled expression is x.foo(new C()), where x is an instance of X, the compiler may produce a call to foo(A) although the compiler can correctly compile foo((B)new C()).</p>\n<p>The users are recommended to use # as the separator between a class name and a static method or field name. For example, in regular Java,<br>javassist.CtClass.intType.getName()<br>calls a method getName() on the object indicated by the static field intType in javassist.CtClass. In Javassist, the users can write the expression shown above but they are recommended to write:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javassist.CtClass#intType.getName()</span><br></pre></td></tr></table></figure>\n<p>so that the compiler can quickly parse the expression.</p>\n"},{"title":"Javasist Class Loader","date":"2019-05-03T12:15:00.000Z","_content":"\nIf what classes must be modified is known in advance, the easiest way for modifying the classes is as follows:\n\n1. Get a CtClass object by calling ClassPool.get(),\n2. Modify it, and\n3. Call writeFile() or toBytecode() on that CtClass object to obtain a modified class file.\nIf whether a class is modified or not is determined at load time, the users must make Javassist collaborate with a class loader. Javassist can be used with a class loader so that bytecode can be modified at load time. The users of Javassist can define their own version of class loader but they can also use a class loader provided by Javassist.\n\n\n\n## 3.1 The toClass method in CtClass\n\nCtClass 提供了一个便捷方法 toClass(), 该方法会将CtClass对象所代表的class通过当前线程的context 类加载器加载进虚拟机里. 在调用该方法之前, 调用者必须拥有权限, 否则会抛出 SecurityException 异常.\n\nThe CtClass provides a convenience method toClass(), which requests the context class loader for the current thread to load the class represented by the CtClass object. To call this method, the caller must have appropriate permission; otherwise, a SecurityException may be thrown.\n\nThe following program shows how to use toClass():\n\n下面的程序展示了如何使用toClass().\n```java\npublic class Hello {\n    public void say() {\n        System.out.println(\"Hello\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        ClassPool cp = ClassPool.getDefault();\n        CtClass cc = cp.get(\"Hello\");\n        CtMethod m = cc.getDeclaredMethod(\"say\");\n        m.insertBefore(\"{ System.out.println(\\\"Hello.say():\\\"); }\");\n        Class c = cc.toClass();\n        Hello h = (Hello)c.newInstance();\n        h.say();\n    }\n}\n```\n\nTest.main() 在Hello类的say()方法中插入了一个对 println() 的方法调用. 然后将修改过的Hello class构建一个实例出来, 接着调用该实例的say()方法.\n\nTest.main() inserts a call to println() in the method body of say() in Hello. Then it constructs an instance of the modified Hello class and calls say() on that instance.\n\n> 注意, 上面的程序能运行成功取决于在toClass()执行之前, Hello class从来没有被加载过. 如果Hello已经被加载过的话, 在toClass() 加载修改过的Hello class之前,  JVM会先将原生的Hello class加载进来. 因此加载修改过的Hello class就会失败(抛出LinkageError 错误). 例如:\n\nNote that the program above depends on the fact that the Hello class is never loaded before toClass() is invoked. If not, the JVM would load the original Hello class before toClass() requests to load the modified Hello class. Hence loading the modified Hello class would be failed (LinkageError is thrown). For example, if main() in Test is something like this:\n\n```java\npublic static void main(String[] args) throws Exception {\n    Hello orig = new Hello();\n    ClassPool cp = ClassPool.getDefault();\n    CtClass cc = cp.get(\"Hello\");\n        :\n}\n```\nmain 方法的第一行首先将原生的Hello class加载了进来, 后续再调用 toClass() 就会抛出异常, 这是因为同一个类加载器不能同时加载俩个相同版本的Hello class.\n\nthen the original Hello class is loaded at the first line of main and the call to toClass() throws an exception since the class loader cannot load two different versions of the Hello class at the same time.\n\n如果这个应用程序运行在一些如JBoss或者Tomcat的应用服务器桑, toClass() 直接使用context 类加载器 可能就不太正确了. 在上面的例子中, 你会看到一个未检查异常 ClassCastException 被抛出. 要避免这种异常, 你必须给 toClass() 一个合适的类加载器. 例如, 如果变量 bean 是你的session bean对象的话, 你可以采用下面的代码:\n\nIf the program is running on some application server such as JBoss and Tomcat, the context class loader used by toClass() might be inappropriate. In this case, you would see an unexpected ClassCastException. To avoid this exception, you must explicitly give an appropriate class loader to toClass(). For example, if bean is your session bean object, then the following code:\n\n```java\nCtClass cc = ...;\nClass c = cc.toClass(bean.getClass().getClassLoader());\n```\n上面的代码可以正确运行. 你应该将加载你程序的类加载器传递给toClass() (在上面的例子中, 是bean对象的class)\n\nwould work. You should give toClass() the class loader that has loaded your program (in the above example, the class of the bean object).\n\n`toClass()` 只是一个便捷方法. 如果你需要更复杂的功能, 你应该实现自己的类加载器.\n\ntoClass() is provided for convenience. If you need more complex functionality, you should write your own class loader.\n\n\n## 3.2 Class loading in Java\n\n在Java中, 多个class loader是可以共存的, 每个ClassLoader都有它自己的命名空间. 不同的类加载器可以加载相同名称的不同的class. 加载进来的class被视为不一样的. 这个特性允许我们在同一个JVM运行包含相同名称的class的多个应用程序.\n\nIn Java, multiple class loaders can coexist and each class loader creates its own name space. Different class loaders can load different class files with the same class name. The loaded two classes are regarded as different ones. This feature enables us to run multiple application programs on a single JVM even if these programs include different classes with the same name.\n\n> 注意, JVM不允许动态重新加载class. 一旦一个类加载器已经加载了一个class, 那么在运行期, 就不允许该类加载器再去加载一个已经修改过的class. 因此当JVM已经加载了一个class之后, 就不允许再去修改该class的定义了. 但是, JDPA(Java Platform Debugger Architecture) 提供了一些工具可以帮助重新加载一个类. See Section 3.6.\n\nNote: The JVM does not allow dynamically reloading a class. Once a class loader loads a class, it cannot reload a modified version of that class during runtime. Thus, you cannot alter the definition of a class after the JVM loads it. However, the JPDA (Java Platform Debugger Architecture) provides limited ability for reloading a class. See Section 3.6.\n\n如果相同的class 文件被不同的类加载器加载了, JVM就会创建俩个名称和定义相同的class. 但是这俩个class是被视为是不同的. 因为这俩个class是不同的, 一个class的实例是不允许赋值到另一个class的变量的. 在这俩个class之间的转换操作会失败, 同时抛出一个 ClassCastException.\n\nIf the same class file is loaded by two distinct class loaders, the JVM makes two distinct classes with the same name and definition. The two classes are regarded as different ones. Since the two classes are not identical, an instance of one class is not assignable to a variable of the other class. The cast operation between the two classes fails and throws a ClassCastException.\n\n例如, 下面的代码片段抛出的异常.\n\nFor example, the following code snippet throws an exception:\n```java\nMyClassLoader myLoader = new MyClassLoader();\nClass clazz = myLoader.loadClass(\"Box\");\nObject obj = clazz.newInstance();\nBox b = (Box)obj;    // this always throws ClassCastException.\n```\n\nBox class 被俩个类加载器加载. 假设一个类加载器 CL将上面的代码片段的一个类. CL会将上述代码片段的MyClassLoader, Class, Object, and Box进行加载(除非CL被代理给了其他类加载器). 因此变量b的类型是Box 是被CL加载的. 然而,  myLoader 也加载了Box class. 变量obj指向的对象就是被myLoader加载的Box的实例. 因此最后语句就会抛出异常ClassCastException, 因为obj的class和变量b所引用的class不是同一个.\n\nThe Box class is loaded by two class loaders. Suppose that a class loader CL loads a class including this code snippet. Since this code snippet refers to MyClassLoader, Class, Object, and Box, CL also loads these classes (unless it delegates to another class loader). Hence the type of the variable b is the Box class loaded by CL. On the other hand, myLoader also loads the Box class. The object obj is an instance of the Box class loaded by myLoader. Therefore, the last statement always throws a ClassCastException since the class of obj is a different verison of the Box class from one used as the type of the variable b.\n\n不同的类加载器构成了一个树结构. 除了bootstrap类加载器, 每个类加载器都有一个父加载器, which has normally loaded the class of that child class loader. 因为被请求加载的类可以被代理给这个层级中的其他类加载器, 因此一个class也许可以被不是你想使用的其他类加载器加载. 因此, 你希望加载类C的类加载器也许和实际加载类C的加载器不是同一个. 因此为了区分这俩个类加载器, 我们把前一个类加载器称为`the initiator of C`, 后一个类加载器称为`the real loader of C`.\n\nMultiple class loaders form a tree structure. Each class loader except the bootstrap loader has a parent class loader, which has normally loaded the class of that child class loader. Since the request to load a class can be delegated along this hierarchy of class loaders, a class may be loaded by a class loader that you do not request the class loading. Therefore, the class loader that has been requested to load a class C may be different from the loader that actually loads the class C. For distinction, we call the former loader the initiator of C and we call the latter loader the real loader of C.\n\n此外, 如果被请求加载类C的类加载器(`the initiator of C`)被代理给了父加载器PL, 那么类加载器CL也不会再起加载类C中依赖的任何其他的类. 类加载CL就不再是哪些类的initiator, 它的父加载器PL就成为了initiator, 然后PL负责去加载哪些类. 类C定义中指向的那些类将会被类C的真实加载器进行加载.\n\nFurthermore, if a class loader CL requested to load a class C (the initiator of C) delegates to the parent class loader PL, then the class loader CL is never requested to load any classes referred to in the definition of the class C. CL is not the initiator of those classes. Instead, the parent class loader PL becomes their initiators and it is requested to load them. The classes that the definition of a class C referes to are loaded by the real loader of C.\n\n下面看一个例子, 深入理解一下:\n\nTo understand this behavior, let's consider the following example.\n\n```java\npublic class Point {    // loaded by PL\n    private int x, y;\n    public int getX() { return x; }\n        :\n}\n\npublic class Box {      // the initiator is L but the real loader is PL\n    private Point upperLeft, size;\n    public int getBaseX() { return upperLeft.x; }\n        :\n}\n\npublic class Window {    // loaded by a class loader L\n    private Box box;\n    public int getBaseX() { return box.getBaseX(); }\n}\n```\n\n假设类`Window`是被类加载器`L`加载的. 那么类`Window`的initiator和真实加载器都是`L`. 因为`Window`定义里面指向了类`Box`, JVM还将事业`L`去加载类`Box`. 这里, 假设, `L`将加载动作委托给了父加载器`PL`. `Box`的initiator就是`L`, 但是真实加载器就成`PL`. 在这个例子中, `Point`的initiator就成了`PL`而不是`L`, 因为它和`Box`的真实加载器是一样的. 因此`L`从来都不会加载`Point`.\n\nSuppose that a class Window is loaded by a class loader L. Both the initiator and the real loader of Window are L. Since the definition of Window refers to Box, the JVM will request L to load Box. Here, suppose that L delegates this task to the parent class loader PL. The initiator of Box is L but the real loader is PL. In this case, the initiator of Point is not L but PL since it is the same as the real loader of Box. Thus L is never requested to load Point.\n\nNext, let's consider a slightly modified example.\n\n下面的例子对刚才进行了一些稍微的修改:\n\n```java\npublic class Point {\n    private int x, y;\n    public int getX() { return x; }\n        :\n}\n\npublic class Box {      // the initiator is L but the real loader is PL\n    private Point upperLeft, size;\n    public Point getSize() { return size; }\n        :\n}\n\npublic class Window {    // loaded by a class loader L\n    private Box box;\n    public boolean widthIs(int w) {\n        Point p = box.getSize();\n        return w == p.getX();\n    }\n}\n```\n现在, `Window`的定义也指向了`Point`. 在这个例子中, 如果类加载器`L`要加载`Point`, 它必须也被代理给`PL`. 你必须避免有俩个类加载器俩次加载相同一个类. 这俩个类加载器中的一个必须代理给另一个.\n\nNow, the definition of Window also refers to Point. In this case, the class loader L must also delegate to PL if it is requested to load Point. You must avoid having two class loaders doubly load the same class. One of the two loaders must delegate to the other.\n\n当`Point`被加载的时候, 如果`L`没有被代理给`PL`, `widthIs()` 将会抛出一个`ClassCastException`. 因为`Box`的真实类加载器是`PL`, `Box`中关联的`Point`也会被`PL`加载. 因此, `getSize()`真实调用的实例是由`PL`加载的类`Point`产生的, 而`widthIs()`中的变量`p`是由`L`加载的类`Point`. JVM将他们视作俩个类型, 因此会因为类型不匹配抛出一个异常.\n\nIf L does not delegate to PL when Point is loaded, widthIs() would throw a ClassCastException. Since the real loader of Box is PL, Point referred to in Box is also loaded by PL. Therefore, the resulting value of getSize() is an instance of Point loaded by PL whereas the type of the variable p in widthIs() is Point loaded by L. The JVM regards them as distinct types and thus it throws an exception because of type mismatch.\n\n这个行为看起来是有点不方便, 但是却很必须的. 看下面的代码:\n\nThis behavior is somewhat inconvenient but necessary. If the following statement:\n```java\nPoint p = box.getSize();\n```\n这就不会抛出异常, 写`Window`的程序员破坏了`Point`对象的封装. 例如, 被`PL`加载的类`Point`中有个字段`x`是私有的. 如果`L`加载下面程序描述的`Point`, `Window`类就可以直接访问`x`的值.\n\ndid not throw an exception, then the programmer of Window could break the encapsulation of Point objects. For example, the field x is private in Point loaded by PL. However, the Window class could directly access the value of x if L loads Point with the following definition:\n\n```java\npublic class Point {\n    public int x, y;    // not private\n    public int getX() { return x; }\n        :\n}\n```\n更多关于Java类加载器的细节, 下面的文章会更优帮助:\n\nFor more details of class loaders in Java, the following paper would be helpful:\n\n> Sheng Liang and Gilad Bracha, \"Dynamic Class Loading in the Java Virtual Machine\", \n> ACM OOPSLA'98, pp.36-44, 1998.\n\n## 3.3 Using javassist.Loader\n\nJavassist 提供了一个类加载器`javassist.Loader`. 这个类加载器使用`javassist.ClassPool`对象来读取class文件.\n\nJavassist provides a class loader javassist.Loader. This class loader uses a javassist.ClassPool object for reading a class file.\n\n例如, `javassist.Loader` 可以用来加载被Javassist修改过的class.\n\nFor example, javassist.Loader can be used for loading a particular class modified with Javassist.\n\n```java\nimport javassist.*;\nimport test.Rectangle;\n\npublic class Main {\n  public static void main(String[] args) throws Throwable {\n     ClassPool pool = ClassPool.getDefault();\n     Loader cl = new Loader(pool);\n\n     CtClass ct = pool.get(\"test.Rectangle\");\n     ct.setSuperclass(pool.get(\"test.Point\"));\n\n     Class c = cl.loadClass(\"test.Rectangle\");\n     Object rect = c.newInstance();\n         :\n  }\n}\n```\n\n这个应用程序修改了类`test.Rectangle`. `test.Rectangle`的父类被设置为了`test.Point`. 然后应用程序将修改过的class加载, 最后创建出一个新的`test.Rectangle`实例出来.\n\nThis program modifies a class test.Rectangle. The superclass of test.Rectangle is set to a test.Point class. Then this program loads the modified class, and creates a new instance of the test.Rectangle class.\n\n如果用户想要当class被加载后, 后台会自动修改class, 可以通过向`javassist.Loader`添加事件监听器来完成. 当类加载器加载类的时候会自动通知注册了的事件监听器. 事件监听器必须下面的接口.\n\nIf the users want to modify a class on demand when it is loaded, the users can add an event listener to a javassist.Loader. The added event listener is notified when the class loader loads a class. The event-listener class must implement the following interface:\n\n```java\npublic interface Translator {\n    public void start(ClassPool pool)\n        throws NotFoundException, CannotCompileException;\n    public void onLoad(ClassPool pool, String classname)\n        throws NotFoundException, CannotCompileException;\n}\n```\n\n当通过调用`javassist.Loader`的`addTranslator()`向`javassist.Loader`添加完成事件监听器后, `start()`方法就会被调用. `onLoad()`方法会在`javassist.Loader`加载类之前被调用. 可以在`onLoad()` 方法中修改一个类的定义.\n\nThe method start() is called when this event listener is added to a javassist.Loader object by addTranslator() in javassist.Loader. The method onLoad() is called before javassist.Loader loads a class. onLoad() can modify the definition of the loaded class.\n\n例如, 下面的事件监听器在class被加载之前全部被修改成`public`.\n\nFor example, the following event listener changes all classes to public classes just before they are loaded.\n\n```java\npublic class MyTranslator implements Translator {\n    void start(ClassPool pool)\n        throws NotFoundException, CannotCompileException {}\n    void onLoad(ClassPool pool, String classname)\n        throws NotFoundException, CannotCompileException\n    {\n        CtClass cc = pool.get(classname);\n        cc.setModifiers(Modifier.PUBLIC);\n    }\n}\n```\n\n> 注意, `onLoad()`方法中不用调用`toBytecode()` 或者 `writeFile()` 方法, `javassist.Loader`会自动去调用那些方法.\n\nNote that onLoad() does not have to call toBytecode() or writeFile() since javassist.Loader calls these methods to obtain a class file.\n\n\nTo run an application class MyApp with a MyTranslator object, write a main class as following:\n\n```java\nimport javassist.*;\n\npublic class Main2 {\n  public static void main(String[] args) throws Throwable {\n     Translator t = new MyTranslator();\n     ClassPool pool = ClassPool.getDefault();\n     Loader cl = new Loader();\n     cl.addTranslator(pool, t);\n     cl.run(\"MyApp\", args);\n  }\n}\n```\nTo run this program, do:\n\n运行程序:\n```java\n% java Main2 arg1 arg2...\n```\n\n类`MyApp`和程序中其他的类都会被`MyTranslator`修改.\n\nThe class MyApp and the other application classes are translated by MyTranslator.\n\n注意, 程序中像`MyApp`这样的类不能访问oader classes, 例如`Main2, MyTranslator, and ClassPool`, 因为它们是被不同的加载器加载的. 应用程序的类是被`javassist.Loader`而loader classes(例如`Main2`)是被Java默认的类加载器加载的.\n\nNote that application classes like MyApp cannot access the loader classes such as Main2, MyTranslator, and ClassPool because they are loaded by different loaders. The application classes are loaded by javassist.Loader whereas the loader classes such as Main2 are by the default Java class loader.\n\n`javassist.Loader`搜索类的顺序和`java.lang.ClassLoader`不一样. `ClassLoader`首先会将加载动作委托给他们父加载器, 只有当父加载器找不到, `ClassLoader`自己才会去加载. 而`javassist.Loader` 在委托给父类加载器之前, 自己首先加载一遍. 直接委托父加载器加载只取决于\n\n* 在调用`ClassPool`对象的`get()`方法是没有找到搜索的类\n* 或者通过`delegateLoadingOf()`设置指定由父加载器去进行加载.\n\njavassist.Loader searches for classes in a different order from java.lang.ClassLoader. ClassLoader first delegates the loading operations to the parent class loader and then attempts to load the classes only if the parent class loader cannot find them. On the other hand, javassist.Loader attempts to load the classes before delegating to the parent class loader. It delegates only if:\n\n* the classes are not found by calling get() on a ClassPool object, or\n* the classes have been specified by using delegateLoadingOf() to be loaded by the parent class loader.\n\n这种搜索顺序允许Javassist 加载修改过的类. 一旦它由于某些原因找不到修改过的类, 它仍然会将搜索动作委托给父加载器进行加载. 一旦类被父加载器加载到了, 那么类中其他的类也会被父加载器进行加载, 因此这些被父加载器加载的类是永远也不是被修改过的. 回想一下前文介绍的, 在类`C`中包含的类也会被`C`的真实加载器进行加载. 如果你的程序加载修改过的类失败了, 你应该确认一下使用那些类的其他类是否也被`javassist.Loader`进行加载的.\n\nThis search order allows loading modified classes by Javassist. However, it delegates to the parent class loader if it fails to find modified classes for some reason. Once a class is loaded by the parent class loader, the other classes referred to in that class will be also loaded by the parent class loader and thus they are never modified. Recall that all the classes referred to in a class C are loaded by the real loader of C. If your program fails to load a modified class, you should make sure whether all the classes using that class have been loaded by javassist.Loader.\n\n\n## 3.4 Writing a class loader\nA simple class loader using Javassist is as follows:\n\n使用Javassist中的类加载器很简单:\n\n```java\nimport javassist.*;\n\npublic class SampleLoader extends ClassLoader {\n    /* Call MyApp.main().\n     */\n    public static void main(String[] args) throws Throwable {\n        SampleLoader s = new SampleLoader();\n        Class c = s.loadClass(\"MyApp\");\n        c.getDeclaredMethod(\"main\", new Class[] { String[].class })\n         .invoke(null, new Object[] { args });\n    }\n\n    private ClassPool pool;\n\n    public SampleLoader() throws NotFoundException {\n        pool = new ClassPool();\n        pool.insertClassPath(\"./class\"); // MyApp.class must be there.\n    }\n\n    /* Finds a specified class.\n     * The bytecode for that class can be modified.\n     */\n    protected Class findClass(String name) throws ClassNotFoundException {\n        try {\n            CtClass cc = pool.get(name);\n            // modify the CtClass object here\n            byte[] b = cc.toBytecode();\n            return defineClass(name, b, 0, b.length);\n        } catch (NotFoundException e) {\n            throw new ClassNotFoundException();\n        } catch (IOException e) {\n            throw new ClassNotFoundException();\n        } catch (CannotCompileException e) {\n            throw new ClassNotFoundException();\n        }\n    }\n}\n```\n类`MyApp`是一个应用程序. 执行程序之前, 首先要将该类放到`./class`目录下, 但是不能包含在类搜索路径里. 否则`MyApp.class`会被系统默认的类加载器进行加载(会被`SampleLoader`父加载器加载). 通过在构建器中调用 `insertClassPath()` 设置了路径的名称`./class`. 你也可以不用`./class`, 换一个其他的名称, 然后执行:\n\nThe class MyApp is an application program. To execute this program, first put the class file under the ./class directory, which must not be included in the class search path. Otherwise, MyApp.class would be loaded by the default system class loader, which is the parent loader of SampleLoader. The directory name ./class is specified by insertClassPath() in the constructor. You can choose a different name instead of ./class if you want. Then do as follows:\n\n```\n% java SampleLoader\n```\n类加载器会从`./class/MyApp.class`加载类`MyApp`, 然后调用`MyApp.main()`方法.\n\nThe class loader loads the class MyApp (./class/MyApp.class) and calls MyApp.main() with the command line parameters.\n\n这是使用`Javassist`最简单的方式. 然而, 如果你写了一个复杂的类加载器, 你必须熟悉java类加载机制的细节. 例如, 上面的应用程序将`MyApp`放到了与`SampleLoader`所属的不同的一个名称空间里, 因为这俩个类是由不同的类加载器进行加载的. 因此`MyApp`不能直接访问类`SampleLoader`.\n\nThis is the simplest way of using Javassist. However, if you write a more complex class loader, you may need detailed knowledge of Java's class loading mechanism. For example, the program above puts the MyApp class in a name space separated from the name space that the class SampleLoader belongs to because the two classes are loaded by different class loaders. Hence, the MyApp class cannot directly access the class SampleLoader.\n\n\n## 3.5 Modifying a system class\n系统类例如`java.lang.String`除了系统类加载器之外不能被其他的类加载加载. 因此, 上面提到的`SampleLoader`或者`javassist.Loader`在加载时不能修改系统的类.\n\nThe system classes like java.lang.String cannot be loaded by a class loader other than the system class loader. Therefore, SampleLoader or javassist.Loader shown above cannot modify the system classes at loading time.\n\n但是如果你的程序想要修改系统类, 那么系统类必须被静态修改. 例如下面的程序在`java.lang.String`添加了一个字段`hiddenValue`:\n\nIf your application needs to do that, the system classes must be statically modified. For example, the following program adds a new field hiddenValue to java.lang.String:\n\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"java.lang.String\");\nCtField f = new CtField(CtClass.intType, \"hiddenValue\", cc);\nf.setModifiers(Modifier.PUBLIC);\ncc.addField(f);\ncc.writeFile(\".\");\n```\n这个程序产生了一个文件`./java/lang/String.class`.\n\nThis program produces a file \"./java/lang/String.class\".\n\nTo run your program MyApp with this modified String class, do as follows:\n\n在`MyApp`中使用这个修改过的类`String`, 例如:\n```java\n% java -Xbootclasspath/p:. MyApp arg1 arg2...\n```\n\n假设`MyApp`定义如下:\n\nSuppose that the definition of MyApp is as follows:\n```java\npublic class MyApp {\n    public static void main(String[] args) throws Exception {\n        System.out.println(String.class.getField(\"hiddenValue\").getName());\n    }\n}\n```\n如果修改过的`String`被正确地加载, `MyApp`会打印`hiddenValue`的值.\n\nIf the modified String class is correctly loaded, MyApp prints hiddenValue.\n\n> 注意, 应用程序使用这个技术在覆盖`rt.jar`中的系统类的时候不应该被部署, 否则会违反`Java 2 Runtime Environment binary code license` 授权.\n\nNote: Applications that use this technique for the purpose of overriding a system class in rt.jar should not be deployed as doing so would contravene the Java 2 Runtime Environment binary code license.\n\n\n\n## 3.6 Reloading a class at runtime\n\n如果JVM在运行时JPDA开启了, 类就可以动态重加载了. JVM加载一个类后, 旧版本的class可以被卸载, 新版本的class可以再次加载进来. 这样一来就完成了在运行期动态修改类. 但是, 新版本的类定义必须兼容旧版本的类定义. JVM不允许这俩个版本的类的schema发生改变. 他们必须拥有相同的方法和字段.\n\nJavassist提供了一个工具类用于在运行期动态重加载. 更多的细节信息参考API文档`javassist.tools.HotSwapper`.\n\nIf the JVM is launched with the JPDA (Java Platform Debugger Architecture) enabled, a class is dynamically reloadable. After the JVM loads a class, the old version of the class definition can be unloaded and a new one can be reloaded again. That is, the definition of that class can be dynamically modified during runtime. However, the new class definition must be somewhat compatible to the old one. The JVM does not allow schema changes between the two versions. They have the same set of methods and fields.\n\nJavassist provides a convenient class for reloading a class at runtime. For more information, see the API documentation of javassist.tools.HotSwapper.\n\n","source":"_posts/javassist/Javasist 3 Class loader.md","raw":"---\ntitle: Javasist Class Loader\ndate: 2019-05-03 20:15:00\n---\n\nIf what classes must be modified is known in advance, the easiest way for modifying the classes is as follows:\n\n1. Get a CtClass object by calling ClassPool.get(),\n2. Modify it, and\n3. Call writeFile() or toBytecode() on that CtClass object to obtain a modified class file.\nIf whether a class is modified or not is determined at load time, the users must make Javassist collaborate with a class loader. Javassist can be used with a class loader so that bytecode can be modified at load time. The users of Javassist can define their own version of class loader but they can also use a class loader provided by Javassist.\n\n\n\n## 3.1 The toClass method in CtClass\n\nCtClass 提供了一个便捷方法 toClass(), 该方法会将CtClass对象所代表的class通过当前线程的context 类加载器加载进虚拟机里. 在调用该方法之前, 调用者必须拥有权限, 否则会抛出 SecurityException 异常.\n\nThe CtClass provides a convenience method toClass(), which requests the context class loader for the current thread to load the class represented by the CtClass object. To call this method, the caller must have appropriate permission; otherwise, a SecurityException may be thrown.\n\nThe following program shows how to use toClass():\n\n下面的程序展示了如何使用toClass().\n```java\npublic class Hello {\n    public void say() {\n        System.out.println(\"Hello\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        ClassPool cp = ClassPool.getDefault();\n        CtClass cc = cp.get(\"Hello\");\n        CtMethod m = cc.getDeclaredMethod(\"say\");\n        m.insertBefore(\"{ System.out.println(\\\"Hello.say():\\\"); }\");\n        Class c = cc.toClass();\n        Hello h = (Hello)c.newInstance();\n        h.say();\n    }\n}\n```\n\nTest.main() 在Hello类的say()方法中插入了一个对 println() 的方法调用. 然后将修改过的Hello class构建一个实例出来, 接着调用该实例的say()方法.\n\nTest.main() inserts a call to println() in the method body of say() in Hello. Then it constructs an instance of the modified Hello class and calls say() on that instance.\n\n> 注意, 上面的程序能运行成功取决于在toClass()执行之前, Hello class从来没有被加载过. 如果Hello已经被加载过的话, 在toClass() 加载修改过的Hello class之前,  JVM会先将原生的Hello class加载进来. 因此加载修改过的Hello class就会失败(抛出LinkageError 错误). 例如:\n\nNote that the program above depends on the fact that the Hello class is never loaded before toClass() is invoked. If not, the JVM would load the original Hello class before toClass() requests to load the modified Hello class. Hence loading the modified Hello class would be failed (LinkageError is thrown). For example, if main() in Test is something like this:\n\n```java\npublic static void main(String[] args) throws Exception {\n    Hello orig = new Hello();\n    ClassPool cp = ClassPool.getDefault();\n    CtClass cc = cp.get(\"Hello\");\n        :\n}\n```\nmain 方法的第一行首先将原生的Hello class加载了进来, 后续再调用 toClass() 就会抛出异常, 这是因为同一个类加载器不能同时加载俩个相同版本的Hello class.\n\nthen the original Hello class is loaded at the first line of main and the call to toClass() throws an exception since the class loader cannot load two different versions of the Hello class at the same time.\n\n如果这个应用程序运行在一些如JBoss或者Tomcat的应用服务器桑, toClass() 直接使用context 类加载器 可能就不太正确了. 在上面的例子中, 你会看到一个未检查异常 ClassCastException 被抛出. 要避免这种异常, 你必须给 toClass() 一个合适的类加载器. 例如, 如果变量 bean 是你的session bean对象的话, 你可以采用下面的代码:\n\nIf the program is running on some application server such as JBoss and Tomcat, the context class loader used by toClass() might be inappropriate. In this case, you would see an unexpected ClassCastException. To avoid this exception, you must explicitly give an appropriate class loader to toClass(). For example, if bean is your session bean object, then the following code:\n\n```java\nCtClass cc = ...;\nClass c = cc.toClass(bean.getClass().getClassLoader());\n```\n上面的代码可以正确运行. 你应该将加载你程序的类加载器传递给toClass() (在上面的例子中, 是bean对象的class)\n\nwould work. You should give toClass() the class loader that has loaded your program (in the above example, the class of the bean object).\n\n`toClass()` 只是一个便捷方法. 如果你需要更复杂的功能, 你应该实现自己的类加载器.\n\ntoClass() is provided for convenience. If you need more complex functionality, you should write your own class loader.\n\n\n## 3.2 Class loading in Java\n\n在Java中, 多个class loader是可以共存的, 每个ClassLoader都有它自己的命名空间. 不同的类加载器可以加载相同名称的不同的class. 加载进来的class被视为不一样的. 这个特性允许我们在同一个JVM运行包含相同名称的class的多个应用程序.\n\nIn Java, multiple class loaders can coexist and each class loader creates its own name space. Different class loaders can load different class files with the same class name. The loaded two classes are regarded as different ones. This feature enables us to run multiple application programs on a single JVM even if these programs include different classes with the same name.\n\n> 注意, JVM不允许动态重新加载class. 一旦一个类加载器已经加载了一个class, 那么在运行期, 就不允许该类加载器再去加载一个已经修改过的class. 因此当JVM已经加载了一个class之后, 就不允许再去修改该class的定义了. 但是, JDPA(Java Platform Debugger Architecture) 提供了一些工具可以帮助重新加载一个类. See Section 3.6.\n\nNote: The JVM does not allow dynamically reloading a class. Once a class loader loads a class, it cannot reload a modified version of that class during runtime. Thus, you cannot alter the definition of a class after the JVM loads it. However, the JPDA (Java Platform Debugger Architecture) provides limited ability for reloading a class. See Section 3.6.\n\n如果相同的class 文件被不同的类加载器加载了, JVM就会创建俩个名称和定义相同的class. 但是这俩个class是被视为是不同的. 因为这俩个class是不同的, 一个class的实例是不允许赋值到另一个class的变量的. 在这俩个class之间的转换操作会失败, 同时抛出一个 ClassCastException.\n\nIf the same class file is loaded by two distinct class loaders, the JVM makes two distinct classes with the same name and definition. The two classes are regarded as different ones. Since the two classes are not identical, an instance of one class is not assignable to a variable of the other class. The cast operation between the two classes fails and throws a ClassCastException.\n\n例如, 下面的代码片段抛出的异常.\n\nFor example, the following code snippet throws an exception:\n```java\nMyClassLoader myLoader = new MyClassLoader();\nClass clazz = myLoader.loadClass(\"Box\");\nObject obj = clazz.newInstance();\nBox b = (Box)obj;    // this always throws ClassCastException.\n```\n\nBox class 被俩个类加载器加载. 假设一个类加载器 CL将上面的代码片段的一个类. CL会将上述代码片段的MyClassLoader, Class, Object, and Box进行加载(除非CL被代理给了其他类加载器). 因此变量b的类型是Box 是被CL加载的. 然而,  myLoader 也加载了Box class. 变量obj指向的对象就是被myLoader加载的Box的实例. 因此最后语句就会抛出异常ClassCastException, 因为obj的class和变量b所引用的class不是同一个.\n\nThe Box class is loaded by two class loaders. Suppose that a class loader CL loads a class including this code snippet. Since this code snippet refers to MyClassLoader, Class, Object, and Box, CL also loads these classes (unless it delegates to another class loader). Hence the type of the variable b is the Box class loaded by CL. On the other hand, myLoader also loads the Box class. The object obj is an instance of the Box class loaded by myLoader. Therefore, the last statement always throws a ClassCastException since the class of obj is a different verison of the Box class from one used as the type of the variable b.\n\n不同的类加载器构成了一个树结构. 除了bootstrap类加载器, 每个类加载器都有一个父加载器, which has normally loaded the class of that child class loader. 因为被请求加载的类可以被代理给这个层级中的其他类加载器, 因此一个class也许可以被不是你想使用的其他类加载器加载. 因此, 你希望加载类C的类加载器也许和实际加载类C的加载器不是同一个. 因此为了区分这俩个类加载器, 我们把前一个类加载器称为`the initiator of C`, 后一个类加载器称为`the real loader of C`.\n\nMultiple class loaders form a tree structure. Each class loader except the bootstrap loader has a parent class loader, which has normally loaded the class of that child class loader. Since the request to load a class can be delegated along this hierarchy of class loaders, a class may be loaded by a class loader that you do not request the class loading. Therefore, the class loader that has been requested to load a class C may be different from the loader that actually loads the class C. For distinction, we call the former loader the initiator of C and we call the latter loader the real loader of C.\n\n此外, 如果被请求加载类C的类加载器(`the initiator of C`)被代理给了父加载器PL, 那么类加载器CL也不会再起加载类C中依赖的任何其他的类. 类加载CL就不再是哪些类的initiator, 它的父加载器PL就成为了initiator, 然后PL负责去加载哪些类. 类C定义中指向的那些类将会被类C的真实加载器进行加载.\n\nFurthermore, if a class loader CL requested to load a class C (the initiator of C) delegates to the parent class loader PL, then the class loader CL is never requested to load any classes referred to in the definition of the class C. CL is not the initiator of those classes. Instead, the parent class loader PL becomes their initiators and it is requested to load them. The classes that the definition of a class C referes to are loaded by the real loader of C.\n\n下面看一个例子, 深入理解一下:\n\nTo understand this behavior, let's consider the following example.\n\n```java\npublic class Point {    // loaded by PL\n    private int x, y;\n    public int getX() { return x; }\n        :\n}\n\npublic class Box {      // the initiator is L but the real loader is PL\n    private Point upperLeft, size;\n    public int getBaseX() { return upperLeft.x; }\n        :\n}\n\npublic class Window {    // loaded by a class loader L\n    private Box box;\n    public int getBaseX() { return box.getBaseX(); }\n}\n```\n\n假设类`Window`是被类加载器`L`加载的. 那么类`Window`的initiator和真实加载器都是`L`. 因为`Window`定义里面指向了类`Box`, JVM还将事业`L`去加载类`Box`. 这里, 假设, `L`将加载动作委托给了父加载器`PL`. `Box`的initiator就是`L`, 但是真实加载器就成`PL`. 在这个例子中, `Point`的initiator就成了`PL`而不是`L`, 因为它和`Box`的真实加载器是一样的. 因此`L`从来都不会加载`Point`.\n\nSuppose that a class Window is loaded by a class loader L. Both the initiator and the real loader of Window are L. Since the definition of Window refers to Box, the JVM will request L to load Box. Here, suppose that L delegates this task to the parent class loader PL. The initiator of Box is L but the real loader is PL. In this case, the initiator of Point is not L but PL since it is the same as the real loader of Box. Thus L is never requested to load Point.\n\nNext, let's consider a slightly modified example.\n\n下面的例子对刚才进行了一些稍微的修改:\n\n```java\npublic class Point {\n    private int x, y;\n    public int getX() { return x; }\n        :\n}\n\npublic class Box {      // the initiator is L but the real loader is PL\n    private Point upperLeft, size;\n    public Point getSize() { return size; }\n        :\n}\n\npublic class Window {    // loaded by a class loader L\n    private Box box;\n    public boolean widthIs(int w) {\n        Point p = box.getSize();\n        return w == p.getX();\n    }\n}\n```\n现在, `Window`的定义也指向了`Point`. 在这个例子中, 如果类加载器`L`要加载`Point`, 它必须也被代理给`PL`. 你必须避免有俩个类加载器俩次加载相同一个类. 这俩个类加载器中的一个必须代理给另一个.\n\nNow, the definition of Window also refers to Point. In this case, the class loader L must also delegate to PL if it is requested to load Point. You must avoid having two class loaders doubly load the same class. One of the two loaders must delegate to the other.\n\n当`Point`被加载的时候, 如果`L`没有被代理给`PL`, `widthIs()` 将会抛出一个`ClassCastException`. 因为`Box`的真实类加载器是`PL`, `Box`中关联的`Point`也会被`PL`加载. 因此, `getSize()`真实调用的实例是由`PL`加载的类`Point`产生的, 而`widthIs()`中的变量`p`是由`L`加载的类`Point`. JVM将他们视作俩个类型, 因此会因为类型不匹配抛出一个异常.\n\nIf L does not delegate to PL when Point is loaded, widthIs() would throw a ClassCastException. Since the real loader of Box is PL, Point referred to in Box is also loaded by PL. Therefore, the resulting value of getSize() is an instance of Point loaded by PL whereas the type of the variable p in widthIs() is Point loaded by L. The JVM regards them as distinct types and thus it throws an exception because of type mismatch.\n\n这个行为看起来是有点不方便, 但是却很必须的. 看下面的代码:\n\nThis behavior is somewhat inconvenient but necessary. If the following statement:\n```java\nPoint p = box.getSize();\n```\n这就不会抛出异常, 写`Window`的程序员破坏了`Point`对象的封装. 例如, 被`PL`加载的类`Point`中有个字段`x`是私有的. 如果`L`加载下面程序描述的`Point`, `Window`类就可以直接访问`x`的值.\n\ndid not throw an exception, then the programmer of Window could break the encapsulation of Point objects. For example, the field x is private in Point loaded by PL. However, the Window class could directly access the value of x if L loads Point with the following definition:\n\n```java\npublic class Point {\n    public int x, y;    // not private\n    public int getX() { return x; }\n        :\n}\n```\n更多关于Java类加载器的细节, 下面的文章会更优帮助:\n\nFor more details of class loaders in Java, the following paper would be helpful:\n\n> Sheng Liang and Gilad Bracha, \"Dynamic Class Loading in the Java Virtual Machine\", \n> ACM OOPSLA'98, pp.36-44, 1998.\n\n## 3.3 Using javassist.Loader\n\nJavassist 提供了一个类加载器`javassist.Loader`. 这个类加载器使用`javassist.ClassPool`对象来读取class文件.\n\nJavassist provides a class loader javassist.Loader. This class loader uses a javassist.ClassPool object for reading a class file.\n\n例如, `javassist.Loader` 可以用来加载被Javassist修改过的class.\n\nFor example, javassist.Loader can be used for loading a particular class modified with Javassist.\n\n```java\nimport javassist.*;\nimport test.Rectangle;\n\npublic class Main {\n  public static void main(String[] args) throws Throwable {\n     ClassPool pool = ClassPool.getDefault();\n     Loader cl = new Loader(pool);\n\n     CtClass ct = pool.get(\"test.Rectangle\");\n     ct.setSuperclass(pool.get(\"test.Point\"));\n\n     Class c = cl.loadClass(\"test.Rectangle\");\n     Object rect = c.newInstance();\n         :\n  }\n}\n```\n\n这个应用程序修改了类`test.Rectangle`. `test.Rectangle`的父类被设置为了`test.Point`. 然后应用程序将修改过的class加载, 最后创建出一个新的`test.Rectangle`实例出来.\n\nThis program modifies a class test.Rectangle. The superclass of test.Rectangle is set to a test.Point class. Then this program loads the modified class, and creates a new instance of the test.Rectangle class.\n\n如果用户想要当class被加载后, 后台会自动修改class, 可以通过向`javassist.Loader`添加事件监听器来完成. 当类加载器加载类的时候会自动通知注册了的事件监听器. 事件监听器必须下面的接口.\n\nIf the users want to modify a class on demand when it is loaded, the users can add an event listener to a javassist.Loader. The added event listener is notified when the class loader loads a class. The event-listener class must implement the following interface:\n\n```java\npublic interface Translator {\n    public void start(ClassPool pool)\n        throws NotFoundException, CannotCompileException;\n    public void onLoad(ClassPool pool, String classname)\n        throws NotFoundException, CannotCompileException;\n}\n```\n\n当通过调用`javassist.Loader`的`addTranslator()`向`javassist.Loader`添加完成事件监听器后, `start()`方法就会被调用. `onLoad()`方法会在`javassist.Loader`加载类之前被调用. 可以在`onLoad()` 方法中修改一个类的定义.\n\nThe method start() is called when this event listener is added to a javassist.Loader object by addTranslator() in javassist.Loader. The method onLoad() is called before javassist.Loader loads a class. onLoad() can modify the definition of the loaded class.\n\n例如, 下面的事件监听器在class被加载之前全部被修改成`public`.\n\nFor example, the following event listener changes all classes to public classes just before they are loaded.\n\n```java\npublic class MyTranslator implements Translator {\n    void start(ClassPool pool)\n        throws NotFoundException, CannotCompileException {}\n    void onLoad(ClassPool pool, String classname)\n        throws NotFoundException, CannotCompileException\n    {\n        CtClass cc = pool.get(classname);\n        cc.setModifiers(Modifier.PUBLIC);\n    }\n}\n```\n\n> 注意, `onLoad()`方法中不用调用`toBytecode()` 或者 `writeFile()` 方法, `javassist.Loader`会自动去调用那些方法.\n\nNote that onLoad() does not have to call toBytecode() or writeFile() since javassist.Loader calls these methods to obtain a class file.\n\n\nTo run an application class MyApp with a MyTranslator object, write a main class as following:\n\n```java\nimport javassist.*;\n\npublic class Main2 {\n  public static void main(String[] args) throws Throwable {\n     Translator t = new MyTranslator();\n     ClassPool pool = ClassPool.getDefault();\n     Loader cl = new Loader();\n     cl.addTranslator(pool, t);\n     cl.run(\"MyApp\", args);\n  }\n}\n```\nTo run this program, do:\n\n运行程序:\n```java\n% java Main2 arg1 arg2...\n```\n\n类`MyApp`和程序中其他的类都会被`MyTranslator`修改.\n\nThe class MyApp and the other application classes are translated by MyTranslator.\n\n注意, 程序中像`MyApp`这样的类不能访问oader classes, 例如`Main2, MyTranslator, and ClassPool`, 因为它们是被不同的加载器加载的. 应用程序的类是被`javassist.Loader`而loader classes(例如`Main2`)是被Java默认的类加载器加载的.\n\nNote that application classes like MyApp cannot access the loader classes such as Main2, MyTranslator, and ClassPool because they are loaded by different loaders. The application classes are loaded by javassist.Loader whereas the loader classes such as Main2 are by the default Java class loader.\n\n`javassist.Loader`搜索类的顺序和`java.lang.ClassLoader`不一样. `ClassLoader`首先会将加载动作委托给他们父加载器, 只有当父加载器找不到, `ClassLoader`自己才会去加载. 而`javassist.Loader` 在委托给父类加载器之前, 自己首先加载一遍. 直接委托父加载器加载只取决于\n\n* 在调用`ClassPool`对象的`get()`方法是没有找到搜索的类\n* 或者通过`delegateLoadingOf()`设置指定由父加载器去进行加载.\n\njavassist.Loader searches for classes in a different order from java.lang.ClassLoader. ClassLoader first delegates the loading operations to the parent class loader and then attempts to load the classes only if the parent class loader cannot find them. On the other hand, javassist.Loader attempts to load the classes before delegating to the parent class loader. It delegates only if:\n\n* the classes are not found by calling get() on a ClassPool object, or\n* the classes have been specified by using delegateLoadingOf() to be loaded by the parent class loader.\n\n这种搜索顺序允许Javassist 加载修改过的类. 一旦它由于某些原因找不到修改过的类, 它仍然会将搜索动作委托给父加载器进行加载. 一旦类被父加载器加载到了, 那么类中其他的类也会被父加载器进行加载, 因此这些被父加载器加载的类是永远也不是被修改过的. 回想一下前文介绍的, 在类`C`中包含的类也会被`C`的真实加载器进行加载. 如果你的程序加载修改过的类失败了, 你应该确认一下使用那些类的其他类是否也被`javassist.Loader`进行加载的.\n\nThis search order allows loading modified classes by Javassist. However, it delegates to the parent class loader if it fails to find modified classes for some reason. Once a class is loaded by the parent class loader, the other classes referred to in that class will be also loaded by the parent class loader and thus they are never modified. Recall that all the classes referred to in a class C are loaded by the real loader of C. If your program fails to load a modified class, you should make sure whether all the classes using that class have been loaded by javassist.Loader.\n\n\n## 3.4 Writing a class loader\nA simple class loader using Javassist is as follows:\n\n使用Javassist中的类加载器很简单:\n\n```java\nimport javassist.*;\n\npublic class SampleLoader extends ClassLoader {\n    /* Call MyApp.main().\n     */\n    public static void main(String[] args) throws Throwable {\n        SampleLoader s = new SampleLoader();\n        Class c = s.loadClass(\"MyApp\");\n        c.getDeclaredMethod(\"main\", new Class[] { String[].class })\n         .invoke(null, new Object[] { args });\n    }\n\n    private ClassPool pool;\n\n    public SampleLoader() throws NotFoundException {\n        pool = new ClassPool();\n        pool.insertClassPath(\"./class\"); // MyApp.class must be there.\n    }\n\n    /* Finds a specified class.\n     * The bytecode for that class can be modified.\n     */\n    protected Class findClass(String name) throws ClassNotFoundException {\n        try {\n            CtClass cc = pool.get(name);\n            // modify the CtClass object here\n            byte[] b = cc.toBytecode();\n            return defineClass(name, b, 0, b.length);\n        } catch (NotFoundException e) {\n            throw new ClassNotFoundException();\n        } catch (IOException e) {\n            throw new ClassNotFoundException();\n        } catch (CannotCompileException e) {\n            throw new ClassNotFoundException();\n        }\n    }\n}\n```\n类`MyApp`是一个应用程序. 执行程序之前, 首先要将该类放到`./class`目录下, 但是不能包含在类搜索路径里. 否则`MyApp.class`会被系统默认的类加载器进行加载(会被`SampleLoader`父加载器加载). 通过在构建器中调用 `insertClassPath()` 设置了路径的名称`./class`. 你也可以不用`./class`, 换一个其他的名称, 然后执行:\n\nThe class MyApp is an application program. To execute this program, first put the class file under the ./class directory, which must not be included in the class search path. Otherwise, MyApp.class would be loaded by the default system class loader, which is the parent loader of SampleLoader. The directory name ./class is specified by insertClassPath() in the constructor. You can choose a different name instead of ./class if you want. Then do as follows:\n\n```\n% java SampleLoader\n```\n类加载器会从`./class/MyApp.class`加载类`MyApp`, 然后调用`MyApp.main()`方法.\n\nThe class loader loads the class MyApp (./class/MyApp.class) and calls MyApp.main() with the command line parameters.\n\n这是使用`Javassist`最简单的方式. 然而, 如果你写了一个复杂的类加载器, 你必须熟悉java类加载机制的细节. 例如, 上面的应用程序将`MyApp`放到了与`SampleLoader`所属的不同的一个名称空间里, 因为这俩个类是由不同的类加载器进行加载的. 因此`MyApp`不能直接访问类`SampleLoader`.\n\nThis is the simplest way of using Javassist. However, if you write a more complex class loader, you may need detailed knowledge of Java's class loading mechanism. For example, the program above puts the MyApp class in a name space separated from the name space that the class SampleLoader belongs to because the two classes are loaded by different class loaders. Hence, the MyApp class cannot directly access the class SampleLoader.\n\n\n## 3.5 Modifying a system class\n系统类例如`java.lang.String`除了系统类加载器之外不能被其他的类加载加载. 因此, 上面提到的`SampleLoader`或者`javassist.Loader`在加载时不能修改系统的类.\n\nThe system classes like java.lang.String cannot be loaded by a class loader other than the system class loader. Therefore, SampleLoader or javassist.Loader shown above cannot modify the system classes at loading time.\n\n但是如果你的程序想要修改系统类, 那么系统类必须被静态修改. 例如下面的程序在`java.lang.String`添加了一个字段`hiddenValue`:\n\nIf your application needs to do that, the system classes must be statically modified. For example, the following program adds a new field hiddenValue to java.lang.String:\n\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"java.lang.String\");\nCtField f = new CtField(CtClass.intType, \"hiddenValue\", cc);\nf.setModifiers(Modifier.PUBLIC);\ncc.addField(f);\ncc.writeFile(\".\");\n```\n这个程序产生了一个文件`./java/lang/String.class`.\n\nThis program produces a file \"./java/lang/String.class\".\n\nTo run your program MyApp with this modified String class, do as follows:\n\n在`MyApp`中使用这个修改过的类`String`, 例如:\n```java\n% java -Xbootclasspath/p:. MyApp arg1 arg2...\n```\n\n假设`MyApp`定义如下:\n\nSuppose that the definition of MyApp is as follows:\n```java\npublic class MyApp {\n    public static void main(String[] args) throws Exception {\n        System.out.println(String.class.getField(\"hiddenValue\").getName());\n    }\n}\n```\n如果修改过的`String`被正确地加载, `MyApp`会打印`hiddenValue`的值.\n\nIf the modified String class is correctly loaded, MyApp prints hiddenValue.\n\n> 注意, 应用程序使用这个技术在覆盖`rt.jar`中的系统类的时候不应该被部署, 否则会违反`Java 2 Runtime Environment binary code license` 授权.\n\nNote: Applications that use this technique for the purpose of overriding a system class in rt.jar should not be deployed as doing so would contravene the Java 2 Runtime Environment binary code license.\n\n\n\n## 3.6 Reloading a class at runtime\n\n如果JVM在运行时JPDA开启了, 类就可以动态重加载了. JVM加载一个类后, 旧版本的class可以被卸载, 新版本的class可以再次加载进来. 这样一来就完成了在运行期动态修改类. 但是, 新版本的类定义必须兼容旧版本的类定义. JVM不允许这俩个版本的类的schema发生改变. 他们必须拥有相同的方法和字段.\n\nJavassist提供了一个工具类用于在运行期动态重加载. 更多的细节信息参考API文档`javassist.tools.HotSwapper`.\n\nIf the JVM is launched with the JPDA (Java Platform Debugger Architecture) enabled, a class is dynamically reloadable. After the JVM loads a class, the old version of the class definition can be unloaded and a new one can be reloaded again. That is, the definition of that class can be dynamically modified during runtime. However, the new class definition must be somewhat compatible to the old one. The JVM does not allow schema changes between the two versions. They have the same set of methods and fields.\n\nJavassist provides a convenient class for reloading a class at runtime. For more information, see the API documentation of javassist.tools.HotSwapper.\n\n","slug":"javassist/Javasist 3 Class loader","published":1,"updated":"2019-11-04T05:49:02.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2k1g07h00085c37dzk94851","content":"<p>If what classes must be modified is known in advance, the easiest way for modifying the classes is as follows:</p>\n<ol>\n<li>Get a CtClass object by calling ClassPool.get(),</li>\n<li>Modify it, and</li>\n<li>Call writeFile() or toBytecode() on that CtClass object to obtain a modified class file.<br>If whether a class is modified or not is determined at load time, the users must make Javassist collaborate with a class loader. Javassist can be used with a class loader so that bytecode can be modified at load time. The users of Javassist can define their own version of class loader but they can also use a class loader provided by Javassist.</li>\n</ol>\n<h2 id=\"3-1-The-toClass-method-in-CtClass\"><a href=\"#3-1-The-toClass-method-in-CtClass\" class=\"headerlink\" title=\"3.1 The toClass method in CtClass\"></a>3.1 The toClass method in CtClass</h2><p>CtClass 提供了一个便捷方法 toClass(), 该方法会将CtClass对象所代表的class通过当前线程的context 类加载器加载进虚拟机里. 在调用该方法之前, 调用者必须拥有权限, 否则会抛出 SecurityException 异常.</p>\n<p>The CtClass provides a convenience method toClass(), which requests the context class loader for the current thread to load the class represented by the CtClass object. To call this method, the caller must have appropriate permission; otherwise, a SecurityException may be thrown.</p>\n<p>The following program shows how to use toClass():</p>\n<p>下面的程序展示了如何使用toClass().</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ClassPool cp = ClassPool.getDefault();</span><br><span class=\"line\">        CtClass cc = cp.get(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">        CtMethod m = cc.getDeclaredMethod(<span class=\"string\">\"say\"</span>);</span><br><span class=\"line\">        m.insertBefore(<span class=\"string\">\"&#123; System.out.println(\\\"Hello.say():\\\"); &#125;\"</span>);</span><br><span class=\"line\">        Class c = cc.toClass();</span><br><span class=\"line\">        Hello h = (Hello)c.newInstance();</span><br><span class=\"line\">        h.say();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Test.main() 在Hello类的say()方法中插入了一个对 println() 的方法调用. 然后将修改过的Hello class构建一个实例出来, 接着调用该实例的say()方法.</p>\n<p>Test.main() inserts a call to println() in the method body of say() in Hello. Then it constructs an instance of the modified Hello class and calls say() on that instance.</p>\n<blockquote>\n<p>注意, 上面的程序能运行成功取决于在toClass()执行之前, Hello class从来没有被加载过. 如果Hello已经被加载过的话, 在toClass() 加载修改过的Hello class之前,  JVM会先将原生的Hello class加载进来. 因此加载修改过的Hello class就会失败(抛出LinkageError 错误). 例如:</p>\n</blockquote>\n<p>Note that the program above depends on the fact that the Hello class is never loaded before toClass() is invoked. If not, the JVM would load the original Hello class before toClass() requests to load the modified Hello class. Hence loading the modified Hello class would be failed (LinkageError is thrown). For example, if main() in Test is something like this:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Hello orig = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">    ClassPool cp = ClassPool.getDefault();</span><br><span class=\"line\">    CtClass cc = cp.get(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>main 方法的第一行首先将原生的Hello class加载了进来, 后续再调用 toClass() 就会抛出异常, 这是因为同一个类加载器不能同时加载俩个相同版本的Hello class.</p>\n<p>then the original Hello class is loaded at the first line of main and the call to toClass() throws an exception since the class loader cannot load two different versions of the Hello class at the same time.</p>\n<p>如果这个应用程序运行在一些如JBoss或者Tomcat的应用服务器桑, toClass() 直接使用context 类加载器 可能就不太正确了. 在上面的例子中, 你会看到一个未检查异常 ClassCastException 被抛出. 要避免这种异常, 你必须给 toClass() 一个合适的类加载器. 例如, 如果变量 bean 是你的session bean对象的话, 你可以采用下面的代码:</p>\n<p>If the program is running on some application server such as JBoss and Tomcat, the context class loader used by toClass() might be inappropriate. In this case, you would see an unexpected ClassCastException. To avoid this exception, you must explicitly give an appropriate class loader to toClass(). For example, if bean is your session bean object, then the following code:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass cc = ...;</span><br><span class=\"line\">Class c = cc.toClass(bean.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>\n<p>上面的代码可以正确运行. 你应该将加载你程序的类加载器传递给toClass() (在上面的例子中, 是bean对象的class)</p>\n<p>would work. You should give toClass() the class loader that has loaded your program (in the above example, the class of the bean object).</p>\n<p><code>toClass()</code> 只是一个便捷方法. 如果你需要更复杂的功能, 你应该实现自己的类加载器.</p>\n<p>toClass() is provided for convenience. If you need more complex functionality, you should write your own class loader.</p>\n<h2 id=\"3-2-Class-loading-in-Java\"><a href=\"#3-2-Class-loading-in-Java\" class=\"headerlink\" title=\"3.2 Class loading in Java\"></a>3.2 Class loading in Java</h2><p>在Java中, 多个class loader是可以共存的, 每个ClassLoader都有它自己的命名空间. 不同的类加载器可以加载相同名称的不同的class. 加载进来的class被视为不一样的. 这个特性允许我们在同一个JVM运行包含相同名称的class的多个应用程序.</p>\n<p>In Java, multiple class loaders can coexist and each class loader creates its own name space. Different class loaders can load different class files with the same class name. The loaded two classes are regarded as different ones. This feature enables us to run multiple application programs on a single JVM even if these programs include different classes with the same name.</p>\n<blockquote>\n<p>注意, JVM不允许动态重新加载class. 一旦一个类加载器已经加载了一个class, 那么在运行期, 就不允许该类加载器再去加载一个已经修改过的class. 因此当JVM已经加载了一个class之后, 就不允许再去修改该class的定义了. 但是, JDPA(Java Platform Debugger Architecture) 提供了一些工具可以帮助重新加载一个类. See Section 3.6.</p>\n</blockquote>\n<p>Note: The JVM does not allow dynamically reloading a class. Once a class loader loads a class, it cannot reload a modified version of that class during runtime. Thus, you cannot alter the definition of a class after the JVM loads it. However, the JPDA (Java Platform Debugger Architecture) provides limited ability for reloading a class. See Section 3.6.</p>\n<p>如果相同的class 文件被不同的类加载器加载了, JVM就会创建俩个名称和定义相同的class. 但是这俩个class是被视为是不同的. 因为这俩个class是不同的, 一个class的实例是不允许赋值到另一个class的变量的. 在这俩个class之间的转换操作会失败, 同时抛出一个 ClassCastException.</p>\n<p>If the same class file is loaded by two distinct class loaders, the JVM makes two distinct classes with the same name and definition. The two classes are regarded as different ones. Since the two classes are not identical, an instance of one class is not assignable to a variable of the other class. The cast operation between the two classes fails and throws a ClassCastException.</p>\n<p>例如, 下面的代码片段抛出的异常.</p>\n<p>For example, the following code snippet throws an exception:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClassLoader myLoader = <span class=\"keyword\">new</span> MyClassLoader();</span><br><span class=\"line\">Class clazz = myLoader.loadClass(<span class=\"string\">\"Box\"</span>);</span><br><span class=\"line\">Object obj = clazz.newInstance();</span><br><span class=\"line\">Box b = (Box)obj;    <span class=\"comment\">// this always throws ClassCastException.</span></span><br></pre></td></tr></table></figure>\n\n<p>Box class 被俩个类加载器加载. 假设一个类加载器 CL将上面的代码片段的一个类. CL会将上述代码片段的MyClassLoader, Class, Object, and Box进行加载(除非CL被代理给了其他类加载器). 因此变量b的类型是Box 是被CL加载的. 然而,  myLoader 也加载了Box class. 变量obj指向的对象就是被myLoader加载的Box的实例. 因此最后语句就会抛出异常ClassCastException, 因为obj的class和变量b所引用的class不是同一个.</p>\n<p>The Box class is loaded by two class loaders. Suppose that a class loader CL loads a class including this code snippet. Since this code snippet refers to MyClassLoader, Class, Object, and Box, CL also loads these classes (unless it delegates to another class loader). Hence the type of the variable b is the Box class loaded by CL. On the other hand, myLoader also loads the Box class. The object obj is an instance of the Box class loaded by myLoader. Therefore, the last statement always throws a ClassCastException since the class of obj is a different verison of the Box class from one used as the type of the variable b.</p>\n<p>不同的类加载器构成了一个树结构. 除了bootstrap类加载器, 每个类加载器都有一个父加载器, which has normally loaded the class of that child class loader. 因为被请求加载的类可以被代理给这个层级中的其他类加载器, 因此一个class也许可以被不是你想使用的其他类加载器加载. 因此, 你希望加载类C的类加载器也许和实际加载类C的加载器不是同一个. 因此为了区分这俩个类加载器, 我们把前一个类加载器称为<code>the initiator of C</code>, 后一个类加载器称为<code>the real loader of C</code>.</p>\n<p>Multiple class loaders form a tree structure. Each class loader except the bootstrap loader has a parent class loader, which has normally loaded the class of that child class loader. Since the request to load a class can be delegated along this hierarchy of class loaders, a class may be loaded by a class loader that you do not request the class loading. Therefore, the class loader that has been requested to load a class C may be different from the loader that actually loads the class C. For distinction, we call the former loader the initiator of C and we call the latter loader the real loader of C.</p>\n<p>此外, 如果被请求加载类C的类加载器(<code>the initiator of C</code>)被代理给了父加载器PL, 那么类加载器CL也不会再起加载类C中依赖的任何其他的类. 类加载CL就不再是哪些类的initiator, 它的父加载器PL就成为了initiator, 然后PL负责去加载哪些类. 类C定义中指向的那些类将会被类C的真实加载器进行加载.</p>\n<p>Furthermore, if a class loader CL requested to load a class C (the initiator of C) delegates to the parent class loader PL, then the class loader CL is never requested to load any classes referred to in the definition of the class C. CL is not the initiator of those classes. Instead, the parent class loader PL becomes their initiators and it is requested to load them. The classes that the definition of a class C referes to are loaded by the real loader of C.</p>\n<p>下面看一个例子, 深入理解一下:</p>\n<p>To understand this behavior, let’s consider the following example.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;    <span class=\"comment\">// loaded by PL</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> x; &#125;</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span> </span>&#123;      <span class=\"comment\">// the initiator is L but the real loader is PL</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point upperLeft, size;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getBaseX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> upperLeft.x; &#125;</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Window</span> </span>&#123;    <span class=\"comment\">// loaded by a class loader L</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Box box;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getBaseX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> box.getBaseX(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设类<code>Window</code>是被类加载器<code>L</code>加载的. 那么类<code>Window</code>的initiator和真实加载器都是<code>L</code>. 因为<code>Window</code>定义里面指向了类<code>Box</code>, JVM还将事业<code>L</code>去加载类<code>Box</code>. 这里, 假设, <code>L</code>将加载动作委托给了父加载器<code>PL</code>. <code>Box</code>的initiator就是<code>L</code>, 但是真实加载器就成<code>PL</code>. 在这个例子中, <code>Point</code>的initiator就成了<code>PL</code>而不是<code>L</code>, 因为它和<code>Box</code>的真实加载器是一样的. 因此<code>L</code>从来都不会加载<code>Point</code>.</p>\n<p>Suppose that a class Window is loaded by a class loader L. Both the initiator and the real loader of Window are L. Since the definition of Window refers to Box, the JVM will request L to load Box. Here, suppose that L delegates this task to the parent class loader PL. The initiator of Box is L but the real loader is PL. In this case, the initiator of Point is not L but PL since it is the same as the real loader of Box. Thus L is never requested to load Point.</p>\n<p>Next, let’s consider a slightly modified example.</p>\n<p>下面的例子对刚才进行了一些稍微的修改:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> x; &#125;</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span> </span>&#123;      <span class=\"comment\">// the initiator is L but the real loader is PL</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point upperLeft, size;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Point <span class=\"title\">getSize</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> size; &#125;</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Window</span> </span>&#123;    <span class=\"comment\">// loaded by a class loader L</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Box box;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">widthIs</span><span class=\"params\">(<span class=\"keyword\">int</span> w)</span> </span>&#123;</span><br><span class=\"line\">        Point p = box.getSize();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> w == p.getX();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在, <code>Window</code>的定义也指向了<code>Point</code>. 在这个例子中, 如果类加载器<code>L</code>要加载<code>Point</code>, 它必须也被代理给<code>PL</code>. 你必须避免有俩个类加载器俩次加载相同一个类. 这俩个类加载器中的一个必须代理给另一个.</p>\n<p>Now, the definition of Window also refers to Point. In this case, the class loader L must also delegate to PL if it is requested to load Point. You must avoid having two class loaders doubly load the same class. One of the two loaders must delegate to the other.</p>\n<p>当<code>Point</code>被加载的时候, 如果<code>L</code>没有被代理给<code>PL</code>, <code>widthIs()</code> 将会抛出一个<code>ClassCastException</code>. 因为<code>Box</code>的真实类加载器是<code>PL</code>, <code>Box</code>中关联的<code>Point</code>也会被<code>PL</code>加载. 因此, <code>getSize()</code>真实调用的实例是由<code>PL</code>加载的类<code>Point</code>产生的, 而<code>widthIs()</code>中的变量<code>p</code>是由<code>L</code>加载的类<code>Point</code>. JVM将他们视作俩个类型, 因此会因为类型不匹配抛出一个异常.</p>\n<p>If L does not delegate to PL when Point is loaded, widthIs() would throw a ClassCastException. Since the real loader of Box is PL, Point referred to in Box is also loaded by PL. Therefore, the resulting value of getSize() is an instance of Point loaded by PL whereas the type of the variable p in widthIs() is Point loaded by L. The JVM regards them as distinct types and thus it throws an exception because of type mismatch.</p>\n<p>这个行为看起来是有点不方便, 但是却很必须的. 看下面的代码:</p>\n<p>This behavior is somewhat inconvenient but necessary. If the following statement:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point p = box.getSize();</span><br></pre></td></tr></table></figure>\n<p>这就不会抛出异常, 写<code>Window</code>的程序员破坏了<code>Point</code>对象的封装. 例如, 被<code>PL</code>加载的类<code>Point</code>中有个字段<code>x</code>是私有的. 如果<code>L</code>加载下面程序描述的<code>Point</code>, <code>Window</code>类就可以直接访问<code>x</code>的值.</p>\n<p>did not throw an exception, then the programmer of Window could break the encapsulation of Point objects. For example, the field x is private in Point loaded by PL. However, the Window class could directly access the value of x if L loads Point with the following definition:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> x, y;    <span class=\"comment\">// not private</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> x; &#125;</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多关于Java类加载器的细节, 下面的文章会更优帮助:</p>\n<p>For more details of class loaders in Java, the following paper would be helpful:</p>\n<blockquote>\n<p>Sheng Liang and Gilad Bracha, “Dynamic Class Loading in the Java Virtual Machine”,<br>ACM OOPSLA’98, pp.36-44, 1998.</p>\n</blockquote>\n<h2 id=\"3-3-Using-javassist-Loader\"><a href=\"#3-3-Using-javassist-Loader\" class=\"headerlink\" title=\"3.3 Using javassist.Loader\"></a>3.3 Using javassist.Loader</h2><p>Javassist 提供了一个类加载器<code>javassist.Loader</code>. 这个类加载器使用<code>javassist.ClassPool</code>对象来读取class文件.</p>\n<p>Javassist provides a class loader javassist.Loader. This class loader uses a javassist.ClassPool object for reading a class file.</p>\n<p>例如, <code>javassist.Loader</code> 可以用来加载被Javassist修改过的class.</p>\n<p>For example, javassist.Loader can be used for loading a particular class modified with Javassist.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javassist.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> test.Rectangle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">     ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">     Loader cl = <span class=\"keyword\">new</span> Loader(pool);</span><br><span class=\"line\"></span><br><span class=\"line\">     CtClass ct = pool.get(<span class=\"string\">\"test.Rectangle\"</span>);</span><br><span class=\"line\">     ct.setSuperclass(pool.get(<span class=\"string\">\"test.Point\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">     Class c = cl.loadClass(<span class=\"string\">\"test.Rectangle\"</span>);</span><br><span class=\"line\">     Object rect = c.newInstance();</span><br><span class=\"line\">         :</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个应用程序修改了类<code>test.Rectangle</code>. <code>test.Rectangle</code>的父类被设置为了<code>test.Point</code>. 然后应用程序将修改过的class加载, 最后创建出一个新的<code>test.Rectangle</code>实例出来.</p>\n<p>This program modifies a class test.Rectangle. The superclass of test.Rectangle is set to a test.Point class. Then this program loads the modified class, and creates a new instance of the test.Rectangle class.</p>\n<p>如果用户想要当class被加载后, 后台会自动修改class, 可以通过向<code>javassist.Loader</code>添加事件监听器来完成. 当类加载器加载类的时候会自动通知注册了的事件监听器. 事件监听器必须下面的接口.</p>\n<p>If the users want to modify a class on demand when it is loaded, the users can add an event listener to a javassist.Loader. The added event listener is notified when the class loader loads a class. The event-listener class must implement the following interface:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Translator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(ClassPool pool)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoad</span><span class=\"params\">(ClassPool pool, String classname)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当通过调用<code>javassist.Loader</code>的<code>addTranslator()</code>向<code>javassist.Loader</code>添加完成事件监听器后, <code>start()</code>方法就会被调用. <code>onLoad()</code>方法会在<code>javassist.Loader</code>加载类之前被调用. 可以在<code>onLoad()</code> 方法中修改一个类的定义.</p>\n<p>The method start() is called when this event listener is added to a javassist.Loader object by addTranslator() in javassist.Loader. The method onLoad() is called before javassist.Loader loads a class. onLoad() can modify the definition of the loaded class.</p>\n<p>例如, 下面的事件监听器在class被加载之前全部被修改成<code>public</code>.</p>\n<p>For example, the following event listener changes all classes to public classes just before they are loaded.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTranslator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Translator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(ClassPool pool)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> NotFoundException, CannotCompileException </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onLoad</span><span class=\"params\">(ClassPool pool, String classname)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> NotFoundException, CannotCompileException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        CtClass cc = pool.get(classname);</span><br><span class=\"line\">        cc.setModifiers(Modifier.PUBLIC);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意, <code>onLoad()</code>方法中不用调用<code>toBytecode()</code> 或者 <code>writeFile()</code> 方法, <code>javassist.Loader</code>会自动去调用那些方法.</p>\n</blockquote>\n<p>Note that onLoad() does not have to call toBytecode() or writeFile() since javassist.Loader calls these methods to obtain a class file.</p>\n<p>To run an application class MyApp with a MyTranslator object, write a main class as following:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javassist.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">     Translator t = <span class=\"keyword\">new</span> MyTranslator();</span><br><span class=\"line\">     ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">     Loader cl = <span class=\"keyword\">new</span> Loader();</span><br><span class=\"line\">     cl.addTranslator(pool, t);</span><br><span class=\"line\">     cl.run(<span class=\"string\">\"MyApp\"</span>, args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>To run this program, do:</p>\n<p>运行程序:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% java Main2 arg1 arg2...</span><br></pre></td></tr></table></figure>\n\n<p>类<code>MyApp</code>和程序中其他的类都会被<code>MyTranslator</code>修改.</p>\n<p>The class MyApp and the other application classes are translated by MyTranslator.</p>\n<p>注意, 程序中像<code>MyApp</code>这样的类不能访问oader classes, 例如<code>Main2, MyTranslator, and ClassPool</code>, 因为它们是被不同的加载器加载的. 应用程序的类是被<code>javassist.Loader</code>而loader classes(例如<code>Main2</code>)是被Java默认的类加载器加载的.</p>\n<p>Note that application classes like MyApp cannot access the loader classes such as Main2, MyTranslator, and ClassPool because they are loaded by different loaders. The application classes are loaded by javassist.Loader whereas the loader classes such as Main2 are by the default Java class loader.</p>\n<p><code>javassist.Loader</code>搜索类的顺序和<code>java.lang.ClassLoader</code>不一样. <code>ClassLoader</code>首先会将加载动作委托给他们父加载器, 只有当父加载器找不到, <code>ClassLoader</code>自己才会去加载. 而<code>javassist.Loader</code> 在委托给父类加载器之前, 自己首先加载一遍. 直接委托父加载器加载只取决于</p>\n<ul>\n<li>在调用<code>ClassPool</code>对象的<code>get()</code>方法是没有找到搜索的类</li>\n<li>或者通过<code>delegateLoadingOf()</code>设置指定由父加载器去进行加载.</li>\n</ul>\n<p>javassist.Loader searches for classes in a different order from java.lang.ClassLoader. ClassLoader first delegates the loading operations to the parent class loader and then attempts to load the classes only if the parent class loader cannot find them. On the other hand, javassist.Loader attempts to load the classes before delegating to the parent class loader. It delegates only if:</p>\n<ul>\n<li>the classes are not found by calling get() on a ClassPool object, or</li>\n<li>the classes have been specified by using delegateLoadingOf() to be loaded by the parent class loader.</li>\n</ul>\n<p>这种搜索顺序允许Javassist 加载修改过的类. 一旦它由于某些原因找不到修改过的类, 它仍然会将搜索动作委托给父加载器进行加载. 一旦类被父加载器加载到了, 那么类中其他的类也会被父加载器进行加载, 因此这些被父加载器加载的类是永远也不是被修改过的. 回想一下前文介绍的, 在类<code>C</code>中包含的类也会被<code>C</code>的真实加载器进行加载. 如果你的程序加载修改过的类失败了, 你应该确认一下使用那些类的其他类是否也被<code>javassist.Loader</code>进行加载的.</p>\n<p>This search order allows loading modified classes by Javassist. However, it delegates to the parent class loader if it fails to find modified classes for some reason. Once a class is loaded by the parent class loader, the other classes referred to in that class will be also loaded by the parent class loader and thus they are never modified. Recall that all the classes referred to in a class C are loaded by the real loader of C. If your program fails to load a modified class, you should make sure whether all the classes using that class have been loaded by javassist.Loader.</p>\n<h2 id=\"3-4-Writing-a-class-loader\"><a href=\"#3-4-Writing-a-class-loader\" class=\"headerlink\" title=\"3.4 Writing a class loader\"></a>3.4 Writing a class loader</h2><p>A simple class loader using Javassist is as follows:</p>\n<p>使用Javassist中的类加载器很简单:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javassist.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Call MyApp.main().</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        SampleLoader s = <span class=\"keyword\">new</span> SampleLoader();</span><br><span class=\"line\">        Class c = s.loadClass(<span class=\"string\">\"MyApp\"</span>);</span><br><span class=\"line\">        c.getDeclaredMethod(<span class=\"string\">\"main\"</span>, <span class=\"keyword\">new</span> Class[] &#123; String[]<span class=\"class\">.<span class=\"keyword\">class</span> &#125;)</span></span><br><span class=\"line\">         .invoke(null, new Object[] &#123; args &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassPool pool;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SampleLoader</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NotFoundException </span>&#123;</span><br><span class=\"line\">        pool = <span class=\"keyword\">new</span> ClassPool();</span><br><span class=\"line\">        pool.insertClassPath(<span class=\"string\">\"./class\"</span>); <span class=\"comment\">// MyApp.class must be there.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Finds a specified class.</span></span><br><span class=\"line\"><span class=\"comment\">     * The bytecode for that class can be modified.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Class <span class=\"title\">findClass</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            CtClass cc = pool.get(name);</span><br><span class=\"line\">            <span class=\"comment\">// modify the CtClass object here</span></span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] b = cc.toBytecode();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(name, b, <span class=\"number\">0</span>, b.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CannotCompileException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类<code>MyApp</code>是一个应用程序. 执行程序之前, 首先要将该类放到<code>./class</code>目录下, 但是不能包含在类搜索路径里. 否则<code>MyApp.class</code>会被系统默认的类加载器进行加载(会被<code>SampleLoader</code>父加载器加载). 通过在构建器中调用 <code>insertClassPath()</code> 设置了路径的名称<code>./class</code>. 你也可以不用<code>./class</code>, 换一个其他的名称, 然后执行:</p>\n<p>The class MyApp is an application program. To execute this program, first put the class file under the ./class directory, which must not be included in the class search path. Otherwise, MyApp.class would be loaded by the default system class loader, which is the parent loader of SampleLoader. The directory name ./class is specified by insertClassPath() in the constructor. You can choose a different name instead of ./class if you want. Then do as follows:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% java SampleLoader</span><br></pre></td></tr></table></figure>\n<p>类加载器会从<code>./class/MyApp.class</code>加载类<code>MyApp</code>, 然后调用<code>MyApp.main()</code>方法.</p>\n<p>The class loader loads the class MyApp (./class/MyApp.class) and calls MyApp.main() with the command line parameters.</p>\n<p>这是使用<code>Javassist</code>最简单的方式. 然而, 如果你写了一个复杂的类加载器, 你必须熟悉java类加载机制的细节. 例如, 上面的应用程序将<code>MyApp</code>放到了与<code>SampleLoader</code>所属的不同的一个名称空间里, 因为这俩个类是由不同的类加载器进行加载的. 因此<code>MyApp</code>不能直接访问类<code>SampleLoader</code>.</p>\n<p>This is the simplest way of using Javassist. However, if you write a more complex class loader, you may need detailed knowledge of Java’s class loading mechanism. For example, the program above puts the MyApp class in a name space separated from the name space that the class SampleLoader belongs to because the two classes are loaded by different class loaders. Hence, the MyApp class cannot directly access the class SampleLoader.</p>\n<h2 id=\"3-5-Modifying-a-system-class\"><a href=\"#3-5-Modifying-a-system-class\" class=\"headerlink\" title=\"3.5 Modifying a system class\"></a>3.5 Modifying a system class</h2><p>系统类例如<code>java.lang.String</code>除了系统类加载器之外不能被其他的类加载加载. 因此, 上面提到的<code>SampleLoader</code>或者<code>javassist.Loader</code>在加载时不能修改系统的类.</p>\n<p>The system classes like java.lang.String cannot be loaded by a class loader other than the system class loader. Therefore, SampleLoader or javassist.Loader shown above cannot modify the system classes at loading time.</p>\n<p>但是如果你的程序想要修改系统类, 那么系统类必须被静态修改. 例如下面的程序在<code>java.lang.String</code>添加了一个字段<code>hiddenValue</code>:</p>\n<p>If your application needs to do that, the system classes must be statically modified. For example, the following program adds a new field hiddenValue to java.lang.String:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"java.lang.String\"</span>);</span><br><span class=\"line\">CtField f = <span class=\"keyword\">new</span> CtField(CtClass.intType, <span class=\"string\">\"hiddenValue\"</span>, cc);</span><br><span class=\"line\">f.setModifiers(Modifier.PUBLIC);</span><br><span class=\"line\">cc.addField(f);</span><br><span class=\"line\">cc.writeFile(<span class=\"string\">\".\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这个程序产生了一个文件<code>./java/lang/String.class</code>.</p>\n<p>This program produces a file “./java/lang/String.class”.</p>\n<p>To run your program MyApp with this modified String class, do as follows:</p>\n<p>在<code>MyApp</code>中使用这个修改过的类<code>String</code>, 例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% java -Xbootclasspath/p:. MyApp arg1 arg2...</span><br></pre></td></tr></table></figure>\n\n<p>假设<code>MyApp</code>定义如下:</p>\n<p>Suppose that the definition of MyApp is as follows:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(String.class.getField(\"hiddenValue\").getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果修改过的<code>String</code>被正确地加载, <code>MyApp</code>会打印<code>hiddenValue</code>的值.</p>\n<p>If the modified String class is correctly loaded, MyApp prints hiddenValue.</p>\n<blockquote>\n<p>注意, 应用程序使用这个技术在覆盖<code>rt.jar</code>中的系统类的时候不应该被部署, 否则会违反<code>Java 2 Runtime Environment binary code license</code> 授权.</p>\n</blockquote>\n<p>Note: Applications that use this technique for the purpose of overriding a system class in rt.jar should not be deployed as doing so would contravene the Java 2 Runtime Environment binary code license.</p>\n<h2 id=\"3-6-Reloading-a-class-at-runtime\"><a href=\"#3-6-Reloading-a-class-at-runtime\" class=\"headerlink\" title=\"3.6 Reloading a class at runtime\"></a>3.6 Reloading a class at runtime</h2><p>如果JVM在运行时JPDA开启了, 类就可以动态重加载了. JVM加载一个类后, 旧版本的class可以被卸载, 新版本的class可以再次加载进来. 这样一来就完成了在运行期动态修改类. 但是, 新版本的类定义必须兼容旧版本的类定义. JVM不允许这俩个版本的类的schema发生改变. 他们必须拥有相同的方法和字段.</p>\n<p>Javassist提供了一个工具类用于在运行期动态重加载. 更多的细节信息参考API文档<code>javassist.tools.HotSwapper</code>.</p>\n<p>If the JVM is launched with the JPDA (Java Platform Debugger Architecture) enabled, a class is dynamically reloadable. After the JVM loads a class, the old version of the class definition can be unloaded and a new one can be reloaded again. That is, the definition of that class can be dynamically modified during runtime. However, the new class definition must be somewhat compatible to the old one. The JVM does not allow schema changes between the two versions. They have the same set of methods and fields.</p>\n<p>Javassist provides a convenient class for reloading a class at runtime. For more information, see the API documentation of javassist.tools.HotSwapper.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>If what classes must be modified is known in advance, the easiest way for modifying the classes is as follows:</p>\n<ol>\n<li>Get a CtClass object by calling ClassPool.get(),</li>\n<li>Modify it, and</li>\n<li>Call writeFile() or toBytecode() on that CtClass object to obtain a modified class file.<br>If whether a class is modified or not is determined at load time, the users must make Javassist collaborate with a class loader. Javassist can be used with a class loader so that bytecode can be modified at load time. The users of Javassist can define their own version of class loader but they can also use a class loader provided by Javassist.</li>\n</ol>\n<h2 id=\"3-1-The-toClass-method-in-CtClass\"><a href=\"#3-1-The-toClass-method-in-CtClass\" class=\"headerlink\" title=\"3.1 The toClass method in CtClass\"></a>3.1 The toClass method in CtClass</h2><p>CtClass 提供了一个便捷方法 toClass(), 该方法会将CtClass对象所代表的class通过当前线程的context 类加载器加载进虚拟机里. 在调用该方法之前, 调用者必须拥有权限, 否则会抛出 SecurityException 异常.</p>\n<p>The CtClass provides a convenience method toClass(), which requests the context class loader for the current thread to load the class represented by the CtClass object. To call this method, the caller must have appropriate permission; otherwise, a SecurityException may be thrown.</p>\n<p>The following program shows how to use toClass():</p>\n<p>下面的程序展示了如何使用toClass().</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ClassPool cp = ClassPool.getDefault();</span><br><span class=\"line\">        CtClass cc = cp.get(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">        CtMethod m = cc.getDeclaredMethod(<span class=\"string\">\"say\"</span>);</span><br><span class=\"line\">        m.insertBefore(<span class=\"string\">\"&#123; System.out.println(\\\"Hello.say():\\\"); &#125;\"</span>);</span><br><span class=\"line\">        Class c = cc.toClass();</span><br><span class=\"line\">        Hello h = (Hello)c.newInstance();</span><br><span class=\"line\">        h.say();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Test.main() 在Hello类的say()方法中插入了一个对 println() 的方法调用. 然后将修改过的Hello class构建一个实例出来, 接着调用该实例的say()方法.</p>\n<p>Test.main() inserts a call to println() in the method body of say() in Hello. Then it constructs an instance of the modified Hello class and calls say() on that instance.</p>\n<blockquote>\n<p>注意, 上面的程序能运行成功取决于在toClass()执行之前, Hello class从来没有被加载过. 如果Hello已经被加载过的话, 在toClass() 加载修改过的Hello class之前,  JVM会先将原生的Hello class加载进来. 因此加载修改过的Hello class就会失败(抛出LinkageError 错误). 例如:</p>\n</blockquote>\n<p>Note that the program above depends on the fact that the Hello class is never loaded before toClass() is invoked. If not, the JVM would load the original Hello class before toClass() requests to load the modified Hello class. Hence loading the modified Hello class would be failed (LinkageError is thrown). For example, if main() in Test is something like this:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Hello orig = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">    ClassPool cp = ClassPool.getDefault();</span><br><span class=\"line\">    CtClass cc = cp.get(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>main 方法的第一行首先将原生的Hello class加载了进来, 后续再调用 toClass() 就会抛出异常, 这是因为同一个类加载器不能同时加载俩个相同版本的Hello class.</p>\n<p>then the original Hello class is loaded at the first line of main and the call to toClass() throws an exception since the class loader cannot load two different versions of the Hello class at the same time.</p>\n<p>如果这个应用程序运行在一些如JBoss或者Tomcat的应用服务器桑, toClass() 直接使用context 类加载器 可能就不太正确了. 在上面的例子中, 你会看到一个未检查异常 ClassCastException 被抛出. 要避免这种异常, 你必须给 toClass() 一个合适的类加载器. 例如, 如果变量 bean 是你的session bean对象的话, 你可以采用下面的代码:</p>\n<p>If the program is running on some application server such as JBoss and Tomcat, the context class loader used by toClass() might be inappropriate. In this case, you would see an unexpected ClassCastException. To avoid this exception, you must explicitly give an appropriate class loader to toClass(). For example, if bean is your session bean object, then the following code:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CtClass cc = ...;</span><br><span class=\"line\">Class c = cc.toClass(bean.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>\n<p>上面的代码可以正确运行. 你应该将加载你程序的类加载器传递给toClass() (在上面的例子中, 是bean对象的class)</p>\n<p>would work. You should give toClass() the class loader that has loaded your program (in the above example, the class of the bean object).</p>\n<p><code>toClass()</code> 只是一个便捷方法. 如果你需要更复杂的功能, 你应该实现自己的类加载器.</p>\n<p>toClass() is provided for convenience. If you need more complex functionality, you should write your own class loader.</p>\n<h2 id=\"3-2-Class-loading-in-Java\"><a href=\"#3-2-Class-loading-in-Java\" class=\"headerlink\" title=\"3.2 Class loading in Java\"></a>3.2 Class loading in Java</h2><p>在Java中, 多个class loader是可以共存的, 每个ClassLoader都有它自己的命名空间. 不同的类加载器可以加载相同名称的不同的class. 加载进来的class被视为不一样的. 这个特性允许我们在同一个JVM运行包含相同名称的class的多个应用程序.</p>\n<p>In Java, multiple class loaders can coexist and each class loader creates its own name space. Different class loaders can load different class files with the same class name. The loaded two classes are regarded as different ones. This feature enables us to run multiple application programs on a single JVM even if these programs include different classes with the same name.</p>\n<blockquote>\n<p>注意, JVM不允许动态重新加载class. 一旦一个类加载器已经加载了一个class, 那么在运行期, 就不允许该类加载器再去加载一个已经修改过的class. 因此当JVM已经加载了一个class之后, 就不允许再去修改该class的定义了. 但是, JDPA(Java Platform Debugger Architecture) 提供了一些工具可以帮助重新加载一个类. See Section 3.6.</p>\n</blockquote>\n<p>Note: The JVM does not allow dynamically reloading a class. Once a class loader loads a class, it cannot reload a modified version of that class during runtime. Thus, you cannot alter the definition of a class after the JVM loads it. However, the JPDA (Java Platform Debugger Architecture) provides limited ability for reloading a class. See Section 3.6.</p>\n<p>如果相同的class 文件被不同的类加载器加载了, JVM就会创建俩个名称和定义相同的class. 但是这俩个class是被视为是不同的. 因为这俩个class是不同的, 一个class的实例是不允许赋值到另一个class的变量的. 在这俩个class之间的转换操作会失败, 同时抛出一个 ClassCastException.</p>\n<p>If the same class file is loaded by two distinct class loaders, the JVM makes two distinct classes with the same name and definition. The two classes are regarded as different ones. Since the two classes are not identical, an instance of one class is not assignable to a variable of the other class. The cast operation between the two classes fails and throws a ClassCastException.</p>\n<p>例如, 下面的代码片段抛出的异常.</p>\n<p>For example, the following code snippet throws an exception:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClassLoader myLoader = <span class=\"keyword\">new</span> MyClassLoader();</span><br><span class=\"line\">Class clazz = myLoader.loadClass(<span class=\"string\">\"Box\"</span>);</span><br><span class=\"line\">Object obj = clazz.newInstance();</span><br><span class=\"line\">Box b = (Box)obj;    <span class=\"comment\">// this always throws ClassCastException.</span></span><br></pre></td></tr></table></figure>\n\n<p>Box class 被俩个类加载器加载. 假设一个类加载器 CL将上面的代码片段的一个类. CL会将上述代码片段的MyClassLoader, Class, Object, and Box进行加载(除非CL被代理给了其他类加载器). 因此变量b的类型是Box 是被CL加载的. 然而,  myLoader 也加载了Box class. 变量obj指向的对象就是被myLoader加载的Box的实例. 因此最后语句就会抛出异常ClassCastException, 因为obj的class和变量b所引用的class不是同一个.</p>\n<p>The Box class is loaded by two class loaders. Suppose that a class loader CL loads a class including this code snippet. Since this code snippet refers to MyClassLoader, Class, Object, and Box, CL also loads these classes (unless it delegates to another class loader). Hence the type of the variable b is the Box class loaded by CL. On the other hand, myLoader also loads the Box class. The object obj is an instance of the Box class loaded by myLoader. Therefore, the last statement always throws a ClassCastException since the class of obj is a different verison of the Box class from one used as the type of the variable b.</p>\n<p>不同的类加载器构成了一个树结构. 除了bootstrap类加载器, 每个类加载器都有一个父加载器, which has normally loaded the class of that child class loader. 因为被请求加载的类可以被代理给这个层级中的其他类加载器, 因此一个class也许可以被不是你想使用的其他类加载器加载. 因此, 你希望加载类C的类加载器也许和实际加载类C的加载器不是同一个. 因此为了区分这俩个类加载器, 我们把前一个类加载器称为<code>the initiator of C</code>, 后一个类加载器称为<code>the real loader of C</code>.</p>\n<p>Multiple class loaders form a tree structure. Each class loader except the bootstrap loader has a parent class loader, which has normally loaded the class of that child class loader. Since the request to load a class can be delegated along this hierarchy of class loaders, a class may be loaded by a class loader that you do not request the class loading. Therefore, the class loader that has been requested to load a class C may be different from the loader that actually loads the class C. For distinction, we call the former loader the initiator of C and we call the latter loader the real loader of C.</p>\n<p>此外, 如果被请求加载类C的类加载器(<code>the initiator of C</code>)被代理给了父加载器PL, 那么类加载器CL也不会再起加载类C中依赖的任何其他的类. 类加载CL就不再是哪些类的initiator, 它的父加载器PL就成为了initiator, 然后PL负责去加载哪些类. 类C定义中指向的那些类将会被类C的真实加载器进行加载.</p>\n<p>Furthermore, if a class loader CL requested to load a class C (the initiator of C) delegates to the parent class loader PL, then the class loader CL is never requested to load any classes referred to in the definition of the class C. CL is not the initiator of those classes. Instead, the parent class loader PL becomes their initiators and it is requested to load them. The classes that the definition of a class C referes to are loaded by the real loader of C.</p>\n<p>下面看一个例子, 深入理解一下:</p>\n<p>To understand this behavior, let’s consider the following example.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;    <span class=\"comment\">// loaded by PL</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> x; &#125;</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span> </span>&#123;      <span class=\"comment\">// the initiator is L but the real loader is PL</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point upperLeft, size;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getBaseX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> upperLeft.x; &#125;</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Window</span> </span>&#123;    <span class=\"comment\">// loaded by a class loader L</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Box box;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getBaseX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> box.getBaseX(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设类<code>Window</code>是被类加载器<code>L</code>加载的. 那么类<code>Window</code>的initiator和真实加载器都是<code>L</code>. 因为<code>Window</code>定义里面指向了类<code>Box</code>, JVM还将事业<code>L</code>去加载类<code>Box</code>. 这里, 假设, <code>L</code>将加载动作委托给了父加载器<code>PL</code>. <code>Box</code>的initiator就是<code>L</code>, 但是真实加载器就成<code>PL</code>. 在这个例子中, <code>Point</code>的initiator就成了<code>PL</code>而不是<code>L</code>, 因为它和<code>Box</code>的真实加载器是一样的. 因此<code>L</code>从来都不会加载<code>Point</code>.</p>\n<p>Suppose that a class Window is loaded by a class loader L. Both the initiator and the real loader of Window are L. Since the definition of Window refers to Box, the JVM will request L to load Box. Here, suppose that L delegates this task to the parent class loader PL. The initiator of Box is L but the real loader is PL. In this case, the initiator of Point is not L but PL since it is the same as the real loader of Box. Thus L is never requested to load Point.</p>\n<p>Next, let’s consider a slightly modified example.</p>\n<p>下面的例子对刚才进行了一些稍微的修改:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> x; &#125;</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span> </span>&#123;      <span class=\"comment\">// the initiator is L but the real loader is PL</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Point upperLeft, size;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Point <span class=\"title\">getSize</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> size; &#125;</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Window</span> </span>&#123;    <span class=\"comment\">// loaded by a class loader L</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Box box;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">widthIs</span><span class=\"params\">(<span class=\"keyword\">int</span> w)</span> </span>&#123;</span><br><span class=\"line\">        Point p = box.getSize();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> w == p.getX();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在, <code>Window</code>的定义也指向了<code>Point</code>. 在这个例子中, 如果类加载器<code>L</code>要加载<code>Point</code>, 它必须也被代理给<code>PL</code>. 你必须避免有俩个类加载器俩次加载相同一个类. 这俩个类加载器中的一个必须代理给另一个.</p>\n<p>Now, the definition of Window also refers to Point. In this case, the class loader L must also delegate to PL if it is requested to load Point. You must avoid having two class loaders doubly load the same class. One of the two loaders must delegate to the other.</p>\n<p>当<code>Point</code>被加载的时候, 如果<code>L</code>没有被代理给<code>PL</code>, <code>widthIs()</code> 将会抛出一个<code>ClassCastException</code>. 因为<code>Box</code>的真实类加载器是<code>PL</code>, <code>Box</code>中关联的<code>Point</code>也会被<code>PL</code>加载. 因此, <code>getSize()</code>真实调用的实例是由<code>PL</code>加载的类<code>Point</code>产生的, 而<code>widthIs()</code>中的变量<code>p</code>是由<code>L</code>加载的类<code>Point</code>. JVM将他们视作俩个类型, 因此会因为类型不匹配抛出一个异常.</p>\n<p>If L does not delegate to PL when Point is loaded, widthIs() would throw a ClassCastException. Since the real loader of Box is PL, Point referred to in Box is also loaded by PL. Therefore, the resulting value of getSize() is an instance of Point loaded by PL whereas the type of the variable p in widthIs() is Point loaded by L. The JVM regards them as distinct types and thus it throws an exception because of type mismatch.</p>\n<p>这个行为看起来是有点不方便, 但是却很必须的. 看下面的代码:</p>\n<p>This behavior is somewhat inconvenient but necessary. If the following statement:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point p = box.getSize();</span><br></pre></td></tr></table></figure>\n<p>这就不会抛出异常, 写<code>Window</code>的程序员破坏了<code>Point</code>对象的封装. 例如, 被<code>PL</code>加载的类<code>Point</code>中有个字段<code>x</code>是私有的. 如果<code>L</code>加载下面程序描述的<code>Point</code>, <code>Window</code>类就可以直接访问<code>x</code>的值.</p>\n<p>did not throw an exception, then the programmer of Window could break the encapsulation of Point objects. For example, the field x is private in Point loaded by PL. However, the Window class could directly access the value of x if L loads Point with the following definition:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> x, y;    <span class=\"comment\">// not private</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> x; &#125;</span><br><span class=\"line\">        :</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多关于Java类加载器的细节, 下面的文章会更优帮助:</p>\n<p>For more details of class loaders in Java, the following paper would be helpful:</p>\n<blockquote>\n<p>Sheng Liang and Gilad Bracha, “Dynamic Class Loading in the Java Virtual Machine”,<br>ACM OOPSLA’98, pp.36-44, 1998.</p>\n</blockquote>\n<h2 id=\"3-3-Using-javassist-Loader\"><a href=\"#3-3-Using-javassist-Loader\" class=\"headerlink\" title=\"3.3 Using javassist.Loader\"></a>3.3 Using javassist.Loader</h2><p>Javassist 提供了一个类加载器<code>javassist.Loader</code>. 这个类加载器使用<code>javassist.ClassPool</code>对象来读取class文件.</p>\n<p>Javassist provides a class loader javassist.Loader. This class loader uses a javassist.ClassPool object for reading a class file.</p>\n<p>例如, <code>javassist.Loader</code> 可以用来加载被Javassist修改过的class.</p>\n<p>For example, javassist.Loader can be used for loading a particular class modified with Javassist.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javassist.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> test.Rectangle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">     ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">     Loader cl = <span class=\"keyword\">new</span> Loader(pool);</span><br><span class=\"line\"></span><br><span class=\"line\">     CtClass ct = pool.get(<span class=\"string\">\"test.Rectangle\"</span>);</span><br><span class=\"line\">     ct.setSuperclass(pool.get(<span class=\"string\">\"test.Point\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">     Class c = cl.loadClass(<span class=\"string\">\"test.Rectangle\"</span>);</span><br><span class=\"line\">     Object rect = c.newInstance();</span><br><span class=\"line\">         :</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个应用程序修改了类<code>test.Rectangle</code>. <code>test.Rectangle</code>的父类被设置为了<code>test.Point</code>. 然后应用程序将修改过的class加载, 最后创建出一个新的<code>test.Rectangle</code>实例出来.</p>\n<p>This program modifies a class test.Rectangle. The superclass of test.Rectangle is set to a test.Point class. Then this program loads the modified class, and creates a new instance of the test.Rectangle class.</p>\n<p>如果用户想要当class被加载后, 后台会自动修改class, 可以通过向<code>javassist.Loader</code>添加事件监听器来完成. 当类加载器加载类的时候会自动通知注册了的事件监听器. 事件监听器必须下面的接口.</p>\n<p>If the users want to modify a class on demand when it is loaded, the users can add an event listener to a javassist.Loader. The added event listener is notified when the class loader loads a class. The event-listener class must implement the following interface:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Translator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(ClassPool pool)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoad</span><span class=\"params\">(ClassPool pool, String classname)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当通过调用<code>javassist.Loader</code>的<code>addTranslator()</code>向<code>javassist.Loader</code>添加完成事件监听器后, <code>start()</code>方法就会被调用. <code>onLoad()</code>方法会在<code>javassist.Loader</code>加载类之前被调用. 可以在<code>onLoad()</code> 方法中修改一个类的定义.</p>\n<p>The method start() is called when this event listener is added to a javassist.Loader object by addTranslator() in javassist.Loader. The method onLoad() is called before javassist.Loader loads a class. onLoad() can modify the definition of the loaded class.</p>\n<p>例如, 下面的事件监听器在class被加载之前全部被修改成<code>public</code>.</p>\n<p>For example, the following event listener changes all classes to public classes just before they are loaded.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTranslator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Translator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(ClassPool pool)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> NotFoundException, CannotCompileException </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onLoad</span><span class=\"params\">(ClassPool pool, String classname)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> NotFoundException, CannotCompileException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        CtClass cc = pool.get(classname);</span><br><span class=\"line\">        cc.setModifiers(Modifier.PUBLIC);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意, <code>onLoad()</code>方法中不用调用<code>toBytecode()</code> 或者 <code>writeFile()</code> 方法, <code>javassist.Loader</code>会自动去调用那些方法.</p>\n</blockquote>\n<p>Note that onLoad() does not have to call toBytecode() or writeFile() since javassist.Loader calls these methods to obtain a class file.</p>\n<p>To run an application class MyApp with a MyTranslator object, write a main class as following:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javassist.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">     Translator t = <span class=\"keyword\">new</span> MyTranslator();</span><br><span class=\"line\">     ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">     Loader cl = <span class=\"keyword\">new</span> Loader();</span><br><span class=\"line\">     cl.addTranslator(pool, t);</span><br><span class=\"line\">     cl.run(<span class=\"string\">\"MyApp\"</span>, args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>To run this program, do:</p>\n<p>运行程序:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% java Main2 arg1 arg2...</span><br></pre></td></tr></table></figure>\n\n<p>类<code>MyApp</code>和程序中其他的类都会被<code>MyTranslator</code>修改.</p>\n<p>The class MyApp and the other application classes are translated by MyTranslator.</p>\n<p>注意, 程序中像<code>MyApp</code>这样的类不能访问oader classes, 例如<code>Main2, MyTranslator, and ClassPool</code>, 因为它们是被不同的加载器加载的. 应用程序的类是被<code>javassist.Loader</code>而loader classes(例如<code>Main2</code>)是被Java默认的类加载器加载的.</p>\n<p>Note that application classes like MyApp cannot access the loader classes such as Main2, MyTranslator, and ClassPool because they are loaded by different loaders. The application classes are loaded by javassist.Loader whereas the loader classes such as Main2 are by the default Java class loader.</p>\n<p><code>javassist.Loader</code>搜索类的顺序和<code>java.lang.ClassLoader</code>不一样. <code>ClassLoader</code>首先会将加载动作委托给他们父加载器, 只有当父加载器找不到, <code>ClassLoader</code>自己才会去加载. 而<code>javassist.Loader</code> 在委托给父类加载器之前, 自己首先加载一遍. 直接委托父加载器加载只取决于</p>\n<ul>\n<li>在调用<code>ClassPool</code>对象的<code>get()</code>方法是没有找到搜索的类</li>\n<li>或者通过<code>delegateLoadingOf()</code>设置指定由父加载器去进行加载.</li>\n</ul>\n<p>javassist.Loader searches for classes in a different order from java.lang.ClassLoader. ClassLoader first delegates the loading operations to the parent class loader and then attempts to load the classes only if the parent class loader cannot find them. On the other hand, javassist.Loader attempts to load the classes before delegating to the parent class loader. It delegates only if:</p>\n<ul>\n<li>the classes are not found by calling get() on a ClassPool object, or</li>\n<li>the classes have been specified by using delegateLoadingOf() to be loaded by the parent class loader.</li>\n</ul>\n<p>这种搜索顺序允许Javassist 加载修改过的类. 一旦它由于某些原因找不到修改过的类, 它仍然会将搜索动作委托给父加载器进行加载. 一旦类被父加载器加载到了, 那么类中其他的类也会被父加载器进行加载, 因此这些被父加载器加载的类是永远也不是被修改过的. 回想一下前文介绍的, 在类<code>C</code>中包含的类也会被<code>C</code>的真实加载器进行加载. 如果你的程序加载修改过的类失败了, 你应该确认一下使用那些类的其他类是否也被<code>javassist.Loader</code>进行加载的.</p>\n<p>This search order allows loading modified classes by Javassist. However, it delegates to the parent class loader if it fails to find modified classes for some reason. Once a class is loaded by the parent class loader, the other classes referred to in that class will be also loaded by the parent class loader and thus they are never modified. Recall that all the classes referred to in a class C are loaded by the real loader of C. If your program fails to load a modified class, you should make sure whether all the classes using that class have been loaded by javassist.Loader.</p>\n<h2 id=\"3-4-Writing-a-class-loader\"><a href=\"#3-4-Writing-a-class-loader\" class=\"headerlink\" title=\"3.4 Writing a class loader\"></a>3.4 Writing a class loader</h2><p>A simple class loader using Javassist is as follows:</p>\n<p>使用Javassist中的类加载器很简单:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javassist.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Call MyApp.main().</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        SampleLoader s = <span class=\"keyword\">new</span> SampleLoader();</span><br><span class=\"line\">        Class c = s.loadClass(<span class=\"string\">\"MyApp\"</span>);</span><br><span class=\"line\">        c.getDeclaredMethod(<span class=\"string\">\"main\"</span>, <span class=\"keyword\">new</span> Class[] &#123; String[]<span class=\"class\">.<span class=\"keyword\">class</span> &#125;)</span></span><br><span class=\"line\">         .invoke(null, new Object[] &#123; args &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassPool pool;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SampleLoader</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NotFoundException </span>&#123;</span><br><span class=\"line\">        pool = <span class=\"keyword\">new</span> ClassPool();</span><br><span class=\"line\">        pool.insertClassPath(<span class=\"string\">\"./class\"</span>); <span class=\"comment\">// MyApp.class must be there.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Finds a specified class.</span></span><br><span class=\"line\"><span class=\"comment\">     * The bytecode for that class can be modified.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Class <span class=\"title\">findClass</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            CtClass cc = pool.get(name);</span><br><span class=\"line\">            <span class=\"comment\">// modify the CtClass object here</span></span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] b = cc.toBytecode();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(name, b, <span class=\"number\">0</span>, b.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CannotCompileException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类<code>MyApp</code>是一个应用程序. 执行程序之前, 首先要将该类放到<code>./class</code>目录下, 但是不能包含在类搜索路径里. 否则<code>MyApp.class</code>会被系统默认的类加载器进行加载(会被<code>SampleLoader</code>父加载器加载). 通过在构建器中调用 <code>insertClassPath()</code> 设置了路径的名称<code>./class</code>. 你也可以不用<code>./class</code>, 换一个其他的名称, 然后执行:</p>\n<p>The class MyApp is an application program. To execute this program, first put the class file under the ./class directory, which must not be included in the class search path. Otherwise, MyApp.class would be loaded by the default system class loader, which is the parent loader of SampleLoader. The directory name ./class is specified by insertClassPath() in the constructor. You can choose a different name instead of ./class if you want. Then do as follows:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% java SampleLoader</span><br></pre></td></tr></table></figure>\n<p>类加载器会从<code>./class/MyApp.class</code>加载类<code>MyApp</code>, 然后调用<code>MyApp.main()</code>方法.</p>\n<p>The class loader loads the class MyApp (./class/MyApp.class) and calls MyApp.main() with the command line parameters.</p>\n<p>这是使用<code>Javassist</code>最简单的方式. 然而, 如果你写了一个复杂的类加载器, 你必须熟悉java类加载机制的细节. 例如, 上面的应用程序将<code>MyApp</code>放到了与<code>SampleLoader</code>所属的不同的一个名称空间里, 因为这俩个类是由不同的类加载器进行加载的. 因此<code>MyApp</code>不能直接访问类<code>SampleLoader</code>.</p>\n<p>This is the simplest way of using Javassist. However, if you write a more complex class loader, you may need detailed knowledge of Java’s class loading mechanism. For example, the program above puts the MyApp class in a name space separated from the name space that the class SampleLoader belongs to because the two classes are loaded by different class loaders. Hence, the MyApp class cannot directly access the class SampleLoader.</p>\n<h2 id=\"3-5-Modifying-a-system-class\"><a href=\"#3-5-Modifying-a-system-class\" class=\"headerlink\" title=\"3.5 Modifying a system class\"></a>3.5 Modifying a system class</h2><p>系统类例如<code>java.lang.String</code>除了系统类加载器之外不能被其他的类加载加载. 因此, 上面提到的<code>SampleLoader</code>或者<code>javassist.Loader</code>在加载时不能修改系统的类.</p>\n<p>The system classes like java.lang.String cannot be loaded by a class loader other than the system class loader. Therefore, SampleLoader or javassist.Loader shown above cannot modify the system classes at loading time.</p>\n<p>但是如果你的程序想要修改系统类, 那么系统类必须被静态修改. 例如下面的程序在<code>java.lang.String</code>添加了一个字段<code>hiddenValue</code>:</p>\n<p>If your application needs to do that, the system classes must be statically modified. For example, the following program adds a new field hiddenValue to java.lang.String:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPool pool = ClassPool.getDefault();</span><br><span class=\"line\">CtClass cc = pool.get(<span class=\"string\">\"java.lang.String\"</span>);</span><br><span class=\"line\">CtField f = <span class=\"keyword\">new</span> CtField(CtClass.intType, <span class=\"string\">\"hiddenValue\"</span>, cc);</span><br><span class=\"line\">f.setModifiers(Modifier.PUBLIC);</span><br><span class=\"line\">cc.addField(f);</span><br><span class=\"line\">cc.writeFile(<span class=\"string\">\".\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这个程序产生了一个文件<code>./java/lang/String.class</code>.</p>\n<p>This program produces a file “./java/lang/String.class”.</p>\n<p>To run your program MyApp with this modified String class, do as follows:</p>\n<p>在<code>MyApp</code>中使用这个修改过的类<code>String</code>, 例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% java -Xbootclasspath/p:. MyApp arg1 arg2...</span><br></pre></td></tr></table></figure>\n\n<p>假设<code>MyApp</code>定义如下:</p>\n<p>Suppose that the definition of MyApp is as follows:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(String.class.getField(\"hiddenValue\").getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果修改过的<code>String</code>被正确地加载, <code>MyApp</code>会打印<code>hiddenValue</code>的值.</p>\n<p>If the modified String class is correctly loaded, MyApp prints hiddenValue.</p>\n<blockquote>\n<p>注意, 应用程序使用这个技术在覆盖<code>rt.jar</code>中的系统类的时候不应该被部署, 否则会违反<code>Java 2 Runtime Environment binary code license</code> 授权.</p>\n</blockquote>\n<p>Note: Applications that use this technique for the purpose of overriding a system class in rt.jar should not be deployed as doing so would contravene the Java 2 Runtime Environment binary code license.</p>\n<h2 id=\"3-6-Reloading-a-class-at-runtime\"><a href=\"#3-6-Reloading-a-class-at-runtime\" class=\"headerlink\" title=\"3.6 Reloading a class at runtime\"></a>3.6 Reloading a class at runtime</h2><p>如果JVM在运行时JPDA开启了, 类就可以动态重加载了. JVM加载一个类后, 旧版本的class可以被卸载, 新版本的class可以再次加载进来. 这样一来就完成了在运行期动态修改类. 但是, 新版本的类定义必须兼容旧版本的类定义. JVM不允许这俩个版本的类的schema发生改变. 他们必须拥有相同的方法和字段.</p>\n<p>Javassist提供了一个工具类用于在运行期动态重加载. 更多的细节信息参考API文档<code>javassist.tools.HotSwapper</code>.</p>\n<p>If the JVM is launched with the JPDA (Java Platform Debugger Architecture) enabled, a class is dynamically reloadable. After the JVM loads a class, the old version of the class definition can be unloaded and a new one can be reloaded again. That is, the definition of that class can be dynamically modified during runtime. However, the new class definition must be somewhat compatible to the old one. The JVM does not allow schema changes between the two versions. They have the same set of methods and fields.</p>\n<p>Javassist provides a convenient class for reloading a class at runtime. For more information, see the API documentation of javassist.tools.HotSwapper.</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}